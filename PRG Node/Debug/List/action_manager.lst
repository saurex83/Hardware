###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               31/Mar/2020  11:31:32
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EWA733.tmp
#        (E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c -lc
#        "E:\Neocore\Hardware\PRG Node\Debug\List" -o "E:\Neocore\Hardware\PRG
#        Node\Debug\Obj" -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data --nr_virtual_regs 8 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.0\8051\LIB\DLIB\dl8051Normal.h" --no_path_in_file_macros -I
#        E:\Neocore\Hardware\Stack_core_src\ -On --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_cross_call --mfc
#        E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c
#        "E:\Neocore\Hardware\PRG Node\auth.c" "E:\Neocore\Hardware\PRG
#        Node\balancer.c" E:\Neocore\Hardware\STACK_CORE_SRC\buffer.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\coder.c
#        E:\Neocore\Hardware\Stack_core_src\config.c "E:\Neocore\Hardware\PRG
#        Node\controller.c" E:\Neocore\Hardware\Stack_core_src\cpu.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\debug.c
#        E:\Neocore\Hardware\Stack_core_src\dma.c "E:\Neocore\Hardware\PRG
#        Node\ethernet.c" E:\Neocore\Hardware\STACK_CORE_SRC\frame.c
#        "E:\Neocore\Hardware\PRG Node\ip.c"
#        E:\Neocore\Hardware\Stack_core_src\led.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\llc.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\mac.c "E:\Neocore\Hardware\PRG
#        Node\main.c" E:\Neocore\Hardware\STACK_CORE_SRC\mem_slots.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\mem_utils.c
#        E:\Neocore\Hardware\Stack_core_src\model.c "E:\Neocore\Hardware\PRG
#        Node\neigh.c" E:\Neocore\Hardware\STACK_CORE_SRC\radio.c
#        "E:\Neocore\Hardware\PRG Node\route.c"
#        E:\Neocore\Hardware\Stack_core_src\rtc.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\sync.c "E:\Neocore\Hardware\PRG
#        Node\tcp.c" E:\Neocore\Hardware\STACK_CORE_SRC\time_manager.c
#        "E:\Neocore\Hardware\PRG Node\udp.c"
#        E:\Neocore\Hardware\STACK_CORE_SRC\ustimer.c)
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        E:\Neocore\Hardware\PRG Node\Debug\List\action_manager.lst
#    Object file        =  
#        E:\Neocore\Hardware\PRG Node\Debug\Obj\action_manager.r51
#
###############################################################################

E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c
      1          #include "action_manager.h"
      2          #include "modules_list.h"
      3          #include "model.h"
      4          #include "debug.h"
      5          
      6          /**
      7          @file
      8          */
      9          
     10          /* Определения */
     11          #define ITEMS_COUNT(name) (sizeof(name)/sizeof(module_s*))
     12          #define RUNNER(array, fun) {\
     13          for (char i = 0; i < ITEMS_COUNT(array); i++){\
     14              ASSERT(array[i]->fun != NULL);\
     15              array[i]->fun();\
     16              }\
     17          };
     18          
     19          
     20          /* Локальные переменные */
     21          static module_s* COLD_MOD[] = COLD_MOD_DEF;
     22          static module_s* HOT_MOD[] = HOT_MOD_DEF;
     23          static module_s* HW_MOD[] = HW_MOD_DEF;
     24          static module_s* SW_MOD[] = SW_MOD_DEF;
     25          static module_s* IRQ_MOD[] = IRQ_MOD_DEF;
     26          
     27          static void (*CALLBACK)(void);
     28          
     29          void AM_set_callback(void (*fn)(void)){
     30            ASSERT(fn);
     31            CALLBACK = fn;
     32          }
     33          
     34          void AM_Callback(void){
     35            ASSERT(CALLBACK);
     36            CALLBACK();
     37          }
     38          
     39          void AM_Cold_start(void){
     40            RUNNER(COLD_MOD, Cold_Start);
     41          }
     42          
     43          void AM_Hot_start(void){
     44            RUNNER(HOT_MOD, Hot_Start);  
     45          }
     46          
     47          void AM_HW_Init(void){
     48            RUNNER(HW_MOD, HW_Init);      
     49          }
     50          
     51          void AM_SW_Init(void){
     52            RUNNER(SW_MOD, SW_Init);
     53          }
     54          
     55          void AM_IRQ_Init(void){
     56            RUNNER(IRQ_MOD, IRQ_Init);
     57          }
     58          
     59          
E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c
      1          #include "alarm_timer.h"
      2          #include "time_manager.h"
      3          #include "action_manager.h"
      4          #include "ioCC2530.h"
      5          #include "stdbool.h"
      6          #include "stdint.h"
      7          #include "debug.h"
      8          #include "cpu.h"
      9          
     10          /**
     11          @file
     12          */
     13          
     14          #define MAX_NWTIME (nwtime_t)32767
     15          
     16          static void HW_Init(void);  
     17          static inline void IRQEnable(bool state);
     18          static uint32_t ReadTimer(void);
     19          static inline bool isIRQEnable(void);
     20          static inline uint32_t calcCompareTime(nwtime_t time);
     21          static void loadTimerCompare(uint32_t ticks);
     22          
     23          module_s AT_MODULE = {ALIAS(HW_Init)};
     24          static nwtime_t TOFFSET; 
     25          static uint32_t COMPARE_TIME; //!< Значение в регистре compare
     26          
     27          
     28          static void HW_Init(void){
     29            TOFFSET = 0;
     30            COMPARE_TIME = 0;
     31            IRQEnable(false);
     32          };
     33          
     34          static void SW_Init(void){
     35            TOFFSET = 0;
     36            COMPARE_TIME = 0;
     37            IRQEnable(false);
     38          }; 
     39          
     40          void AT_enable(bool state){
     41            ATOMIC_BLOCK_RESTORE{
     42              IRQEnable(state);
     43            }
     44          };
     45          
     46          nwtime_t AT_interval(nwtime_t beg, nwtime_t end){
     47            return (beg > end) ? (beg - end) : (MAX_NWTIME - beg + end);
     48          }
     49          
     50          void AT_set_time(nwtime_t time){
     51            ASSERT(time <= MAX_NWTIME);
     52            nwtime_t timer = ReadTimer();
     53            TOFFSET = time - timer;
     54            TOFFSET &= 0x7FFF;
     55            // После установки времени нужно изменить compare time в таймере
     56            // Но только в случаи если прерывание активно
     57            if (isIRQEnable())
     58              AT_set_alarm(COMPARE_TIME);
     59          }
     60          
     61          nwtime_t AT_time(void){
     62            uint32_t val = ReadTimer();
     63            // TOFFSET = NETWORK TIME - TIMER
     64            // NETWORK TIME = TIMER + TOFFSET
     65            val +=TOFFSET;
     66            val &= 0x7FFF; // Приводим значения таймера к 0-32767
     67            return val;
     68          }
     69          
     70          /**
     71          @brief Ждем наступления определенного момента времени
     72          */
     73          void AT_wait(nwtime_t time){
     74            ASSERT(time <= MAX_NWTIME);  
     75            static union 
     76            {
     77              uint32_t val;
     78              uint8_t fild[4];
     79            } val;
     80            val.val = 0;
     81            // TOFFSET = NETWORK TIME - TIMER
     82            // NETWORK TIME = TIMER + TOFFSET
     83            // Ждем синхронизацию таймера после пробуждения
     84            while (!(SLEEPSTA & 0x01));
     85            do{
     86              // Соблюдаем порядок чтения регисторов ST  
     87              val.fild[0] = ST0;
     88              val.fild[1] = ST1;
     89              val.fild[2] = ST2;
     90              val.val +=TOFFSET;
     91              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
     92            } while (val.val < time);
     93          }
     94          
     95          /**
     96          @brief Разрешение прерываний таймера сна
     97          @params[in] state = true - разрешить обработку прерываний
     98          */
     99          static inline void IRQEnable(bool state){
    100            if (state)
    101              STIE = 1;
    102            else
    103              STIE = 0;
    104          }
    105          
    106          /**
    107          @brief Устанавливает время прерывания
    108          @details Время прерывания устанавливается относительно времени сети
    109          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    110          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    111          @params[in] ticks время сети в тиках когда нужно проснуться
    112          */
    113          void AT_set_alarm(nwtime_t alarm){
    114            ASSERT(alarm <= MAX_NWTIME);
    115            COMPARE_TIME = alarm; // Сохраняем установленное значение
    116            uint32_t compare_time = calcCompareTime(alarm);
    117            loadTimerCompare(compare_time);
    118            IRQEnable(true);
    119          }
    120          
    121          /**
    122          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    123          @params[in] time время сети в тикак
    124          */
    125          static inline uint32_t calcCompareTime(nwtime_t time){   
    126              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    127              //NETWORK TIME = TIMER + TOFFSET  
    128              // Приводим такты к тактам таймера
    129              uint16_t ticks_offset = (time - TOFFSET) & 0x7FFF;
    130              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    131              cmp_time |= ticks_offset; // Вычисляем новое время
    132              if (cmp_time <= timer){
    133                cmp_time += 0x8000;
    134                cmp_time &=0xFFFFFF;
    135              }
    136               LOG_OFF("Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    137                    timer, ticks, cmp_time );
    138              return cmp_time;
    139          }
    140          
    141          /**
    142          @brief Возвращает текущее значение таймера
    143          @return Текущие ticks
    144          */
    145          static uint32_t ReadTimer(void){
    146            static union 
    147            {
    148              uint32_t val;
    149              uint8_t fild[4];
    150            } ret_val;
    151            ret_val.val = 0;
    152            // Ждем синхронизацию таймера после пробуждения
    153            while (!(SLEEPSTA & 0x01));
    154            // Соблюдаем порядок чтения регисторов ST  
    155            ret_val.fild[0] = ST0;
    156            ret_val.fild[1] = ST1;
    157            ret_val.fild[2] = ST2;
    158            return ret_val.val;
    159          }
    160          
    161          /**
    162          @brief Устанавливает время пробуждения микроконтролера
    163          @params[in] ticks 24 битное значение времени пробуждения в ticks
    164          */
    165          static void loadTimerCompare(uint32_t ticks){
    166            union 
    167            {
    168              uint32_t val;
    169              uint8_t fild[4];
    170            } value;
    171            value.val = ticks;
    172            // Ждем разрешения на запись нового значения
    173            while (!(STLOAD & 0x01));
    174            // Регистр ST0 должен быть записан в последнию очередь
    175            ST2 = value.fild[2];
    176            ST1 = value.fild[1];
    177            ST0 = value.fild[0];
    178          }
    179          
    180          /**
    181          @brief Проверка активности прерывания таймера
    182          @return true если прерывание установленно
    183          */
    184          static inline bool isIRQEnable(void){
    185            return STIE;
    186          }
    187          
    188          /**
    189          @brief Обработчик прерывания таймера сна
    190          */
    191          #pragma vector=ST_VECTOR
    192          __interrupt void TimerCompareInterrupt(void){ 
    193            nwtime_t time = AT_time();
    194            // Отключаем прерывание таймера. Забота пользователя его включить
    195            IRQEnable(false); 
    196            TM_IRQ(time); // Передаем управление менеджеру времени
    197            STIF = 0; // Очищаем флаг прерывания
    198          }
E:\Neocore\Hardware\PRG Node\balancer.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "buffer.h"
      4          
      5          
      6          void TB_Receive(struct frame *frame){
      7          }
E:\Neocore\Hardware\STACK_CORE_SRC\buffer.c
      1          #include "debug.h"
      2          #include "macros.h"
      3          #include "frame.h"
      4          #include "stdbool.h"
      5          #include "cpu.h"
      6          #include "list.h"
      7          
      8          #include "action_manager.h"
      9          static void SW_Init(void);
     10          static void IRQ_Init(void);
     11          module_s BF_MODULE = {ALIAS(SW_Init),ALIAS(IRQ_Init)};
     12          
     13          struct node {
     14            struct frame *frame;
     15            struct list_head list ;
     16          };
     17          
     18          static struct node NODE_LIST[MAX_TXRX_BUFF_SIZE];
     19          LIST_HEAD(TX_LIST_HEAD);
     20          LIST_HEAD(RX_LIST_HEAD);
     21          static int TX_BUFF_FRAME_COUNT;
     22          static int RX_BUFF_FRAME_COUNT;
     23          
     24          static void IRQ_Init(void){};
     25          
     26          static void SW_Init(void){
     27            TX_BUFF_FRAME_COUNT = 0;
     28            RX_BUFF_FRAME_COUNT = 0;
     29            INIT_LIST_HEAD(&TX_LIST_HEAD);
     30            INIT_LIST_HEAD(&RX_LIST_HEAD);
     31            
     32            for_each_type(struct node, NODE_LIST, node){
     33              node->frame = NULL;
     34              INIT_LIST_HEAD(&node->list);
     35            }
     36          };
     37          
     38          int BF_rx_busy(){
     39            return RX_BUFF_FRAME_COUNT;
     40          };
     41          
     42          int BF_tx_busy(){
     43            return TX_BUFF_FRAME_COUNT;
     44          }
     45          
     46          int BF_available(){
     47            int summ = RX_BUFF_FRAME_COUNT + TX_BUFF_FRAME_COUNT;
     48            ASSERT(summ <= MAX_TXRX_BUFF_SIZE);
     49            return MAX_TXRX_BUFF_SIZE - summ;
     50          }
     51          
     52          int BF_available_tx(){
     53            int summ = MAX_TX_BUFF - TX_BUFF_FRAME_COUNT;
     54            return summ;
     55          }
     56          
     57          int BF_available_rx(){
     58            int summ = MAX_RX_BUFF - RX_BUFF_FRAME_COUNT;
     59            return summ;
     60          }
     61          
     62          static inline struct node* find_free_node(void){
     63            for_each_type(struct node, NODE_LIST, node)
     64              if (node->frame == NULL){
     65                INIT_LIST_HEAD(&node->list);
     66                return node;
     67              }
     68            return NULL;
     69          };
     70          
     71          
     72          static inline bool _push(struct list_head *list, struct frame *frame){
     73            ASSERT(frame != NULL);
     74            struct node *node = find_free_node();
     75            if (!node) // Нет свободных мест
     76              return false;
     77            node->frame = frame;
     78            list_add(&node->list , list);
     79            return true;
     80          };
     81          
     82          bool BF_push_tx(struct frame *frame){
     83            bool res = false;
     84            ATOMIC_BLOCK_RESTORE{
     85              if (TX_BUFF_FRAME_COUNT < MAX_TX_BUFF){
     86                res = _push(&TX_LIST_HEAD, frame);
     87                if (res)
     88                  TX_BUFF_FRAME_COUNT++;
     89              }
     90            };
     91            return res;
     92          };
     93          
     94          bool BF_push_rx(struct frame *frame){
     95            bool res = false;
     96            ATOMIC_BLOCK_RESTORE{
     97              if (RX_BUFF_FRAME_COUNT < MAX_RX_BUFF){
     98                res = _push(&RX_LIST_HEAD, frame);
     99                if (res)
    100                  RX_BUFF_FRAME_COUNT++;
    101              }
    102            };
    103            return res;
    104          };
    105          
    106          void* BF_cursor_rx(void){
    107            if (list_empty(&RX_LIST_HEAD)) 
    108              return NULL;
    109            void *ret_val;
    110            ATOMIC_BLOCK_RESTORE{   
    111              struct node *node = list_first_entry(&RX_LIST_HEAD, struct node, list);
    112              ret_val =  node;
    113            }
    114            return ret_val;
    115          }
    116          
    117          void* BF_cursor_tx(void){
    118            if (list_empty(&TX_LIST_HEAD)) 
    119              return NULL;
    120            void *ret_val;
    121            ATOMIC_BLOCK_RESTORE{   
    122              struct node *node = list_first_entry(&TX_LIST_HEAD, struct node, list);
    123              ret_val =  node;
    124            }
    125            return ret_val;
    126          }  
    127          
    128          void* BF_cursor_next(void* cursor){
    129            if (!cursor)
    130              return NULL;
    131            void *ret_val;
    132            ATOMIC_BLOCK_RESTORE{  
    133              TRY{
    134                struct node *node = (struct node*)(cursor);
    135              
    136                // Убедимся что это не конец списков
    137                if (list_is_last(&node->list, &TX_LIST_HEAD))
    138                  THROW(1);
    139             
    140                if (list_is_last(&node->list, &RX_LIST_HEAD))
    141                  THROW(1); 
    142              
    143                struct node *next = list_next_entry(node, struct node, list);
    144                ret_val = next;
    145              }
    146              CATCH(1){
    147                ret_val = NULL;
    148              } 
    149              ETRY;
    150            };
    151            return ret_val;
    152          }
    153          
    154          bool BF_remove_tx(void *cursor){
    155            if (!cursor)
    156              return false;
    157            ATOMIC_BLOCK_RESTORE{
    158              struct node *node = (struct node*)(cursor);    
    159              node->frame = NULL;
    160              list_del(&node->list);    
    161              TX_BUFF_FRAME_COUNT--; 
    162            };  
    163            return true;
    164          }
    165          
    166          bool BF_remove_rx(void *cursor){
    167            if (!cursor)
    168              return false;
    169            ATOMIC_BLOCK_RESTORE{
    170              struct node *node = (struct node*)(cursor);    
    171              node->frame = NULL;
    172              list_del(&node->list);    
    173              RX_BUFF_FRAME_COUNT--; 
    174            };  
    175            return true;
    176          }
    177          
    178          struct frame* BF_content(void* cursor){
    179            if (!cursor)
    180              return NULL;
    181            struct node *node = (struct node*)(cursor);
    182            return node->frame;
    183          }
E:\Neocore\Hardware\STACK_CORE_SRC\coder.c
      1          #include "coder.h"
      2          #include "ioCC2530.h"
      3          #include "string.h"
      4          #include "ustimer.h" // Для профилирования, Отладка
      5          #include "dma.h"
      6          #include "action_manager.h"
      7          #include "model.h"
      8          #include "mem_utils.h"
      9          
     10          static void HW_Init(void);
     11          module_s CODER_MODULE = {ALIAS(HW_Init)};
     12          
     13          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     14          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     15          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     16          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     17          
     18          #define BV(n)                   (1 << (n))
     19          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     20          
     21          // Режимы шифрования
     22          #define AES_MODE_CBC            0x00
     23          #define AES_MODE_CFB            0x10
     24          #define AES_MODE_OFB            0x20
     25          #define AES_MODE_CTR            0x30
     26          #define AES_MODE_ECB            0x40
     27          #define AES_MODE_CBCMAC         0x50
     28          
     29          // Операции 
     30          #define AES_ENCRYPT             0x00
     31          #define AES_DECRYPT             0x02
     32          #define AES_LOAD_KEY            0x04
     33          #define AES_LOAD_IV             0x06
     34          
     35          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     36          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     37          
     38          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     39          
     40          
     41          // Приватные функции
     42          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     43                                                 uint8_t f, uint8_t lm);
     44          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     45          
     46          /**
     47          @brief Локальный буфер для работы режима CCM
     48          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     49           16 длина дополнения нулями
     50          */
     51          static uint8_t buf[128+18+16]; 
     52          
     53          
     54          typedef struct //!< Структура блока B0 для режима CCM
     55          {
     56            struct 
     57            {
     58              uint8_t L:3;
     59              uint8_t M:3;
     60              uint8_t A_Data:1;
     61            } flag;
     62            uint16_t nonce[9];
     63            uint8_t L_M[6];
     64          } __attribute__((packed)) B0_s;
     65          
     66          typedef struct //!< Структура блока A0 для режима CCM
     67          {
     68            struct 
     69            {
     70              uint8_t L:3;
     71            } flag;
     72            uint8_t nonce[11];
     73            uint8_t ctr;
     74          } __attribute__((packed)) A0_s;
     75          
     76          
     77          
     78          /**
     79          @brief Иницилизация модуля
     80          @detail Модуль использует DMA каналы 0 и 1
     81          */
     82          void HW_Init(void)
     83          {
     84            char STREAM_KEY[16] = DEFAULT_STREAM_KEY;
     85            char STREAM_IV[16] = DEFAULT_STREAM_IV;
     86            char CCM_KEY[16] = DEFAULT_CCM_KEY;
     87            char CCM_IV[16] = DEFAULT_CCM_IV;
     88            MEMCPY(MODEL.AES.STREAM_KEY, STREAM_KEY, 16);
     89            MEMCPY(MODEL.AES.STREAM_IV, STREAM_IV, 16);
     90            MEMCPY(MODEL.AES.CCM_KEY, CCM_KEY, 16);
     91            MEMCPY(MODEL.AES.CCM_IV, CCM_IV, 16);
     92            
     93            //DMA_AES_s DMA_CH[0]; //!< DMA на запись будет DMA[0]
     94            //DMA_AES_s DMA_CH[1]; //!< DMA на чтение DMA_CH[1]
     95            
     96            ST_DEF(DMA_CH[0], DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
     97            ST_DEF(DMA_CH[0], DSTADDRL, 0xB1); //  
     98            ST_DEF(DMA_CH[0], PRIORITY, 0x00); // Низкий приоритет
     99            ST_DEF(DMA_CH[0], M8, 0x00); // Используем 8 бит для счетика длинны
    100            ST_DEF(DMA_CH[0], IRQMASK, 0x00); // Запрещаем генерировать перывания
    101            ST_DEF(DMA_CH[0], DESTINC, 0x00); // Не увеличиваем адресс назначения
    102            ST_DEF(DMA_CH[0], SRCINC, 0x01); // Увеличиваем адресс источника
    103            ST_DEF(DMA_CH[0], TRIG, ENC_DW); // Тригер по загрузке
    104            ST_DEF(DMA_CH[0], WORDSIZE, 0x00); // Копируем по 1 байту
    105            ST_DEF(DMA_CH[0], TMODE, 0x01); //  Блочное копирование по тригеру
    106            ST_DEF(DMA_CH[0], VLEN, 0x00); //  Количество байт определяет поле LEN  
    107            ST_DEF(DMA_CH[0], LENH, 0x00); 
    108            
    109            ST_DEF(DMA_CH[1], SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    110            ST_DEF(DMA_CH[1], SRCADDRL, 0xB2);  
    111            ST_DEF(DMA_CH[1], PRIORITY, 0x00); // Низкий приоритет
    112            ST_DEF(DMA_CH[1], M8, 0x00); // Используем 8 бит для счетика длинны
    113            ST_DEF(DMA_CH[1], IRQMASK, 0x00); // Запрещаем генерировать перывания
    114            ST_DEF(DMA_CH[1], DESTINC, 0x01); // Увеличиваем адресс назначения
    115            ST_DEF(DMA_CH[1], SRCINC, 0x00); // Не увеличиваем адресс источника
    116            ST_DEF(DMA_CH[1], TRIG, ENC_UP); // Тригер по выгрузке
    117            ST_DEF(DMA_CH[1], WORDSIZE, 0x00); // Копируем по 1 байту
    118            ST_DEF(DMA_CH[1], TMODE, 0x01); //  Блочное копирование по тригеру
    119            ST_DEF(DMA_CH[1], VLEN, 0x00); //  Количество байт определяет поле LEN  
    120            ST_DEF(DMA_CH[1], LENH, 0x00); 
    121          }
    122          
    123          /**
    124          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    125          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    126          @param[in] src Указатель на данные подлежащии шифрованию
    127          @param[in] dst Указтель куда будут помещены зашифрованные данные
    128          @param[in] key Указатье на ключ. 16 байт
    129          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    130          @param[in] len Длинна данных
    131          */
    132          void AES_StreamCoder(bool enc_mode, char *src, char *dst, uint8_t len)
    133          {
    134            // Установим метод кодироваения
    135            AES_SET_MODE(STREAM_ENC_MODE);
    136            uint8_t *key = (uint8_t*)MODEL.AES.STREAM_KEY;  
    137            uint8_t *iv = (uint8_t*)MODEL.AES.STREAM_IV; 
    138            // Загружаем ключ
    139            AES_SET_OPERATION(AES_LOAD_KEY);
    140            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    141            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    142            ST_DEF(DMA_CH[0], LENL, 16);
    143            DMAARM |= 0x01;
    144            while(!AES_RDY());
    145            AES_START();
    146            while (DMAARM&0x01);
    147          
    148            // Загружаем IV
    149            AES_SET_OPERATION(AES_LOAD_IV);
    150            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    151            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    152            ST_DEF(DMA_CH[0], LENL, 16);
    153            DMAARM |= 0x01;
    154            while(!AES_RDY());
    155            AES_START();
    156            while (DMAARM&0x01);
    157          
    158            // Установим необходимую операцию AES
    159            if (enc_mode) 
    160              AES_SET_OPERATION(AES_ENCRYPT)
    161            else 
    162              AES_SET_OPERATION(AES_DECRYPT)
    163            
    164            switch(STREAM_ENC_MODE) 
    165            {
    166            case AES_MODE_ECB: // ECB, CBC не реализованы
    167            case AES_MODE_CBC:
    168              break;
    169            case AES_MODE_CFB:
    170            case AES_MODE_OFB:
    171            case AES_MODE_CTR:
    172              {
    173                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    174                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    175                uint8_t ptr, sub_ptr; // Смещение
    176                char *download, *upload;
    177                
    178                // Для этих типов шифрования длина блоков по 4 байта
    179                ST_DEF(DMA_CH[0], LENL, 4);
    180                ST_DEF(DMA_CH[1], LENL, 4);
    181                
    182                // Шифруем все целые блоки
    183                for (uint8_t block = 0; block < nbrBlocks; block ++)
    184                {
    185                  ptr = 16 * block;
    186                  while(!AES_RDY());
    187                  AES_START();
    188                  for (uint8_t j = 0; j < 4; j++)
    189                  {
    190                    sub_ptr = ptr + 4*j;
    191                    download = &src[sub_ptr];
    192                    upload = &dst[sub_ptr];
    193                    // Указываем адресс DMA откуда читать данные
    194                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    195                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    196                    // Указываем адрес DMA куда записывать данные          
    197                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    198                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    199                    // Активируем DMA
    200                    DMAARM |= 0x03;  
    201                    DMAREQ |= 0x01;
    202                    while (DMAARM&0x03);          
    203                  }
    204                }     
    205                // Шифруем последний блок
    206                uint8_t block_len = len % 16; // Размер последнего блока
    207                
    208                // Завершаем работу если блок пустой
    209                if (!block_len)
    210                  return;
    211                
    212                char padding_block[16]; // Блок заполненый нулями
    213                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    214                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    215                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    216                
    217                while(!AES_RDY());
    218                AES_START();
    219                for (uint8_t j = 0; j < 4; j++)
    220                  {
    221                    sub_ptr = 4*j;
    222                    download = &padding_block[sub_ptr];
    223                    // Указываем адресс DMA откуда читать данные
    224                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    225                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    226                    // Указываем аддрес DMA куда записывать данные          
    227                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    228                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    229                    // Активируем DMA
    230                    DMAARM |= 0x03;  
    231                    DMAREQ |= 0x01;
    232                    while (DMAARM&0x03);
    233                  }
    234                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    235                
    236              } //CASE
    237              
    238              break;
    239            } 
    240          }
    241          
    242          /**
    243          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    244          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    245          @param[in] src Указатель на данные подлежащии шифрованию
    246          @param[in] dst Указтель куда будут помещены зашифрованные данные
    247          @param[in] key Указатье на ключ. 16 байт
    248          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    249          @param[in] len Длинна данных
    250          */
    251          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    252                                   uint8_t *iv, uint8_t len)
    253          {
    254            // Установим метод кодироваения
    255            AES_SET_MODE(AES_MODE_CTR);
    256            
    257            // Загружаем ключ
    258            AES_SET_OPERATION(AES_LOAD_KEY);
    259            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    260            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    261            ST_DEF(DMA_CH[0], LENL, 16);
    262            DMAARM |= 0x01;
    263            while(!AES_RDY());
    264            AES_START();
    265            while (DMAARM&0x01);
    266          
    267            // Загружаем IV
    268            AES_SET_OPERATION(AES_LOAD_IV);
    269            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    270            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    271            ST_DEF(DMA_CH[0], LENL, 16);
    272            DMAARM |= 0x01;
    273            while(!AES_RDY());
    274            AES_START();
    275            while (DMAARM&0x01);
    276          
    277            // Установим необходимую операцию AES
    278            if (enc_mode) 
    279              AES_SET_OPERATION(AES_ENCRYPT)
    280            else 
    281              AES_SET_OPERATION(AES_DECRYPT)
    282            
    283            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    284            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    285            uint8_t ptr, sub_ptr; // Смещение
    286            uint8_t *download, *upload;
    287                
    288            // Для этих типов шифрования длина блоков по 4 байта
    289            ST_DEF(DMA_CH[0], LENL, 4);
    290            ST_DEF(DMA_CH[1], LENL, 4);
    291                
    292            // Шифруем все целые блоки
    293            for (uint8_t block = 0; block < nbrBlocks; block ++)
    294              {
    295                ptr = 16 * block;
    296                while(!AES_RDY());
    297                AES_START();
    298                for (uint8_t j = 0; j < 4; j++)
    299                  {
    300                    sub_ptr = ptr + 4*j;
    301                    download = &src[sub_ptr];
    302                    upload = &dst[sub_ptr];
    303                    // Указываем адресс DMA откуда читать данные
    304                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    305                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    306                    // Указываем адрес DMA куда записывать данные          
    307                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    308                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    309                    // Активируем DMA
    310                    DMAARM |= 0x03;  
    311                    DMAREQ |= 0x01;
    312                    while (DMAARM&0x03);          
    313                  }
    314              }     
    315              // Шифруем последний блок
    316              uint8_t block_len = len % 16; // Размер последнего блока
    317                
    318              // Завершаем работу если блок пустой
    319              if (!block_len)
    320                return;
    321                
    322              uint8_t padding_block[16]; // Блок заполненый нулями
    323              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    324              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    325              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    326              
    327              while(!AES_RDY());
    328              AES_START();
    329              for (uint8_t j = 0; j < 4; j++)
    330                {
    331                  sub_ptr = 4*j;
    332                  download = &padding_block[sub_ptr];
    333                  // Указываем адресс DMA откуда читать данные
    334                  ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    335                  ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    336                  // Указываем аддрес DMA куда записывать данные          
    337                  ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    338                  ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    339                  // Активируем DMA
    340                  DMAARM |= 0x03;  
    341                  DMAREQ |= 0x01;
    342                  while (DMAARM&0x03);
    343                }
    344              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    345          }
    346          
    347          /**
    348          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    349          @param[in] len улинна последовательности для вычисления MAC
    350          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    351          */
    352          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    353          {
    354            uint8_t IV[16];
    355            
    356            // Заполняем вектор нулями
    357            memset(IV, 0x00, sizeof(IV));
    358            
    359            // Установим метод кодироваения
    360            AES_SET_MODE(AES_MODE_CBCMAC);  
    361            
    362            { // Сворачиваем код для улучшения чтения
    363            // Загружаем ключ
    364            AES_SET_OPERATION(AES_LOAD_KEY);
    365            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    366            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    367            ST_DEF(DMA_CH[0], LENL, 16);
    368            DMAARM |= 0x01;
    369            while(!AES_RDY());
    370            AES_START();
    371            while (DMAARM&0x01);
    372          
    373            // Загружаем IV
    374            AES_SET_OPERATION(AES_LOAD_IV);
    375            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(IV));
    376            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(IV));
    377            ST_DEF(DMA_CH[0], LENL, 16);
    378            DMAARM |= 0x01;
    379            while(!AES_RDY());
    380            AES_START();
    381            while (DMAARM&0x01);
    382            };
    383            
    384            // Устанавливаем операцию шифрования
    385            AES_SET_OPERATION(AES_ENCRYPT);
    386            
    387            // Загрузка блоками по 128 бит
    388            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    389            uint8_t block_len = len % 16; // Размер последнего блока
    390            uint8_t ptr; // Смещение
    391                
    392            // Для этого типа шифрования длина блоков по 16 байт
    393            ST_DEF(DMA_CH[0], LENL, 16);
    394            // Устанавливаем куда будем выгружать вычисленный MAC
    395            ST_DEF(DMA_CH[1], DSTADDRL, LADDR(mac));
    396            ST_DEF(DMA_CH[1], DSTADDRH, HADDR(mac));
    397            ST_DEF(DMA_CH[1], LENL, 16);
    398            
    399            // Шифруем все целые блоки
    400            for (uint8_t block = 0; block < nbrBlocks; block ++)
    401              {
    402                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    403                // кратного 16 байтам.
    404                if (!block_len && (block == nbrBlocks - 1))
    405                  AES_SET_MODE(AES_MODE_CBC);
    406                    
    407                ptr = 16 * block;
    408                while(!AES_RDY());
    409                AES_START();
    410                // Указываем адресс DMA откуда читать данные
    411                ST_DEF(DMA_CH[0], SRCADDRL, LADDR(buf[ptr]));
    412                ST_DEF(DMA_CH[0], SRCADDRH, HADDR(buf[ptr]));
    413                // Активируем DMA
    414                DMAARM |= 0x01;  
    415                // Активируем выгрузку только последнего блока
    416                if (!block_len && (block == nbrBlocks - 1))
    417                  DMAARM |= 0x03;
    418                
    419                DMAREQ |= 0x01;
    420                while (DMAARM&0x03);          
    421               }
    422                 
    423            // Шифруем последний блок в режиме CBC
    424            AES_SET_MODE(AES_MODE_CBC);
    425                    
    426            // Завершаем работу если блок пустой
    427            if (!block_len)
    428              return;
    429                
    430            uint8_t padding_block[16]; // Блок заполненый нулями
    431            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    432            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    433            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    434                
    435            while(!AES_RDY());
    436            AES_START();
    437            // Указываем адресс DMA откуда читать данные
    438            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(padding_block));
    439            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(padding_block));
    440            // Активируем DMA и выгрузку MAC
    441            DMAARM |= 0x03;  
    442            DMAREQ |= 0x01;
    443            while (DMAARM&0x03);
    444          }
    445          
    446          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    447                                                 uint8_t f, uint8_t lm)
    448          {
    449            memcpy(buf, nonce,16);
    450            
    451            // Буфер от 0 до 15 байта специальный блок B0
    452            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    453            buf[0]=  0x01;  
    454            // Если есть данные для авторизации установим A_Data 
    455            if (f > 0)
    456              buf[0] |= 0x40;
    457            
    458            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    459            
    460            // Устанавливаем длинну сообщения
    461            buf[14] = 0x00;
    462            buf[15] = c;
    463            
    464            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    465            buf[16]= 0;
    466            buf[17]= f;
    467            
    468            // Копируем данные авторизации в буфер
    469            memcpy(&buf[18], src, f);
    470            
    471            // Смещение на следующий байт после данных авторизации.
    472            // Данные авторизации занимают положение в буфере [18, 18+f]
    473            uint8_t ptr_end= 18 + f;
    474            // Заполняем нулями до границы 16 байт  
    475            while (ptr_end & 0x0f)
    476              buf[ptr_end++] = 0x00;
    477            
    478            // Копируем данные для шифрования в буфер после нулей
    479            memcpy(&buf[ptr_end], &src[f], c);
    480            
    481            // Возвращаем размер данных в буфере
    482            return ptr_end+c;
    483          };
    484          
    485          /**
    486          @brief Шифрует/дешифрует данные с проверкой MIC
    487          @param[in] src Указатель на данные подлежащии шифрованию
    488          @param[in] len Размер данных
    489          @param[in] с Количество байт для шифрования
    490          @param[in] f Количество байт для авторизации
    491          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    492          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    493          @param[in] len Длинна данных
    494          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    495          */
    496          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m, uint8_t *MIC)
    497          {
    498            uint8_t *key = (uint8_t*)MODEL.AES.CCM_KEY;  
    499            uint8_t *nonce = (uint8_t*)MODEL.AES.CCM_IV; 
    500            uint8_t lm = MIC_2_MICLEN(m);
    501            
    502            // Генерируем данные для авторизации
    503            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    504            
    505            uint8_t mac[16]; // Сюда пишем мак
    506            CBCMAC_buf_encrypt(dlen, key, mac);
    507            
    508            // Шифруем MAC
    509            uint8_t CTR_IV[16];
    510            memcpy(CTR_IV, nonce, 16);
    511            CTR_IV[0] = 0x01; // Флаг режима CTR
    512            CTR_IV[15] = 0;   // Значение счетчика
    513            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    514            
    515            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    516            // dlen-c, dlen
    517            uint8_t ds = dlen - c; // Начало данных для шифрования
    518            
    519            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    520            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    521            CTR_IV[15] = 1; // Счетчик CTR
    522            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    523            
    524            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    525            // src[f, f+c] это шифрованные данные.
    526            memcpy(&src[f], &buf[ds], c); 
    527            memcpy(MIC, mac, lm);
    528            
    529            //https://github.com/zhaohengyi/CC2530Example/blob/
    530            //master/source/components/radios/cc2530/hal_rf_security.c
    531          }
    532          
    533          /**
    534          @brief Дешифрует данные с проверкой MIC
    535          @param[in] src Указатель на данные подлежащии шифрованию
    536          @param[in] len Размер данных
    537          @param[in] с Количество байт для шифрования
    538          @param[in] f Количество байт для авторизации
    539          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    540          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    541          @param[in] len Длинна данных
    542          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    543          */
    544          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m, uint8_t *MIC)
    545          {
    546            uint8_t *key = (uint8_t*)MODEL.AES.CCM_KEY;  
    547            uint8_t *nonce = (uint8_t*)MODEL.AES.CCM_IV;  
    548            uint8_t lm = MIC_2_MICLEN(m);
    549            
    550            // Расшифровываем MAC
    551            uint8_t mac[16]; // Расшифрованый мак
    552            uint8_t CTR_IV[16];
    553            memcpy(CTR_IV, nonce, 16);
    554            CTR_IV[0] = 0x01; // Флаг режима CTR
    555            CTR_IV[15] = 0;   // Значение счетчика
    556            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    557            
    558            // Генерируем данные для авторизации
    559            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    560            
    561            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    562            // dlen-c, dlen
    563            uint8_t ds = dlen - c; // Начало данных для дешифрования
    564            
    565            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    566            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    567            CTR_IV[15] = 1; // Счетчик CTR
    568            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    569            
    570            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    571            CBCMAC_buf_encrypt(dlen, key, new_mac);
    572            
    573            // Проверяем что маки совпадают, значит дешифровано верно
    574            bool mac_equal = true;
    575            for (uint8_t i = 0 ; i < lm ; i++)
    576            {
    577              if (mac[i] != new_mac[i])
    578              mac_equal = false;
    579              break;
    580            }
    581            
    582            // Выходим если MACи не совпали  
    583            if (!mac_equal)
    584              return false;
    585            
    586            // Копируем  расшифрованные данные
    587            memcpy(&src[f], &buf[ds], c); 
    588            return true;
    589          }
E:\Neocore\Hardware\Stack_core_src\config.c
      1          #include "stdint.h"
      2          #include "string.h"
      3          #include "stdbool.h"
      4          #include "string.h"
      5          #include "basic.h"
      6          #include "config.h"
      7          
      8          static uint8_t default_key[16] = DEFAULT_KEY;
      9          static uint8_t default_iv[16] = DEFAULT_IV;
     10          database_s CONFIG;
     11          
     12          
     13          void CF_init()
     14          {
     15            // Загрузка данных из различных источников
     16            memcpy(CONFIG.stream_key, default_key, 16); 
     17            memcpy(CONFIG.stream_iv,  default_iv, 16);
     18            CONFIG.node_ver = NODE_VER;
     19            CONFIG.node_type = NODE_TYPE;
     20            CONFIG.sync_channel = DEFAULT_SYNC_CHANNEL;
     21            CONFIG.sys_channel = DEFAULT_SYS_CHANNEL;
     22            CONFIG.tx_power = DEFAULT_TX_POWER;
     23            CONFIG.panid = DEFAULT_PANID;
     24          }
E:\Neocore\Hardware\PRG Node\controller.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "buffer.h"
      4          #include "action_manager.h"
      5          #include "ethernet.h"
      6          
      7          static void HP_callback(void);
      8          
      9          void HP_Init(void){
     10              AM_set_callback(HP_callback);
     11          #warning Call other protocols init
                  ^
Warning[Pe1105]: #warning directive: Call other protocols init
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\controller.c"
     12          }
     13          
     14          static void HP_callback(void){
     15            ethernet_process();
     16          };
     17          
E:\Neocore\Hardware\Stack_core_src\cpu.c
      1          #include "action_manager.h"
      2          #include "ioCC2530.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          static void HW_Init(void);   
      9           
     10          module_s CPU_MODULE = {ALIAS(HW_Init)};
     11          
     12          static void HW_Init(void){
     13            /* Сбрасываем бит OSC32K, будет выбран 32.768 кварц */
     14            CLKCONCMD &= ~(1<<7); 
     15            /* Ждем пока бит не станет 0 */
     16            while (CLKCONSTA & (1<<7)); 
     17            /* Переходим на 32 Мгц */
     18            CLKCONCMD = 0;// (1<<3);
     19            while (CLKCONSTA&(1<<6));
     20            EA = 1;
     21          };  
E:\Neocore\Hardware\STACK_CORE_SRC\debug.c
      1          #include "debug.h"
      2          #include "action_manager.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          static void HW_Init(void);  
      9          static void uart_init(void);
     10           
     11          module_s DBG_MODULE = {ALIAS(HW_Init)};
     12          
     13          static void HW_Init(void){
     14          #ifndef DEBUG
     15            return;
     16          #endif
     17          #ifdef PRINT_TO_TERMINAL  
     18            uart_init();
     19          #endif
     20          #ifdef SIG_DEBUG
     21            P1DIR |=0x01;
     22            P1_0 |= 0x01;  
     23          #endif
     24          };  
     25          
     26          
     27          void DBG_CORE_HALT(void){
     28            while(1);
     29          }
     30          
     31          void DBG_CORE_FAULT(void){
     32            while(1);
     33          }
     34          
     35          // Настройка порта uart для отладки
     36          static void uart_init(void){
     37            // Выбор расположения UART на выводах
     38            char U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     39            PERCFG |= (U0CFG<<0); 
     40            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     41            U0CSR = (1<<7); // Выбираем режим uart  
     42            // Настройка скорости передачи данных на 2М  
     43            U0BAUD = 0;  // табличные значения из pdf
     44            U0GCR =  16;
     45            // Включаем альтернативные функции выводов
     46            P0SEL = (1<<2)|(1<<3);
     47            U0CSR |= (1<<6);
     48          }
     49          
     50          #ifdef PRINT_TO_TERMINAL 
     51          #include <yfuns.h>
     52          _STD_BEGIN
     53          #pragma module_name = "?__write"
     54          
     55          int MyLowLevelPutchar(int x){
     56            while( U0CSR&(1<<0));
     57            U0DBUF = x;
     58            return x;
     59          }
     60          
     61          size_t __write(int handle, const unsigned char * buffer, size_t size){
     62            /* Remove the #if #endif pair to enable the implementation */
     63            size_t nChars = 0;
     64            if (buffer == 0)  {
     65              return 0;
     66            }
     67            /* This template only writes to "standard out" and "standard err",
     68             * for all other file handles it returns failure. */
     69            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)  {
     70              return _LLIO_ERROR;
     71            }
     72          
     73            for (/* Empty */; size != 0; --size){
     74              if (MyLowLevelPutchar(*buffer++) < 0){
     75                return _LLIO_ERROR;
     76              }
     77              ++nChars;
     78            }
     79            return nChars;
     80          }
     81          _STD_END
     82          
     83          #endif
     84          
E:\Neocore\Hardware\Stack_core_src\dma.c
      1          #include "dma.h"
      2          #include "ioCC2530.h"
      3          #include "action_manager.h"
      4          
      5          static void HW_Init(void);
      6          module_s DMA_MODULE = {ALIAS(HW_Init)};
      7          
      8            
      9          DMA_s DMA_CH[5];
     10          
     11          /**
     12          @brief Настройка DMA каналов.
     13          @detail Согласно документации каналы 1-4 идут последовательно
     14          */
     15          static void HW_Init(void){
     16              // Настроим канал 0 DMA для загрузки данных в AES
     17            uint16_t CONF_ADDR = (uint16_t)&DMA_CH[0];
     18            DMA0CFGH = CONF_ADDR >> 8;
     19            DMA0CFGL = CONF_ADDR & 0xFF;
     20            
     21            // Настроим канал 1 DMA для выгрузки данных из AES
     22            CONF_ADDR = (uint16_t)&DMA_CH[1];
     23            DMA1CFGH = CONF_ADDR >> 8;
     24            DMA1CFGL = CONF_ADDR & 0xFF;
     25          }
E:\Neocore\Hardware\PRG Node\ethernet.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "buffer.h"
      4          #include "route.c"

    #warning update route tables
     ^
"E:\Neocore\Hardware\PRG Node\route.c",21  Warning[Pe1105]: #warning directive:
          update route tables
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\ethernet.c"
      5          
      6          #define ETH_LAY_SIZE sizeof(struct ETH_LAY)
      7          
      8          struct ETH_LAY{  
      9            union{
     10              uint8_t value;
     11              struct {
     12                char PID:4;
     13                char UNUSED:1;
     14                char ETH_VER:3;
     15              } bits;
     16            } ETH_T;
     17          
     18            char NETID;
     19            unsigned int NDST;
     20            unsigned int NSRC;
     21          } __attribute__((packed));
     22          
     23          static bool frame_filter(struct frame *frame){
     24            struct ETH_LAY *eth_header = (struct ETH_LAY*)frame->payload;
     25          
     26            // Фильтр 1: по размеру кадра
     27            if (frame->len < ETH_LAY_SIZE)
     28              return false;
     29          
     30            // Фильтр 2: по версии протокола
     31            if (eth_header->ETH_T.bits.ETH_VER != HEADER_ETH_VER)
     32              return false;
     33          
     34            // Фильтр 3: по идентификатору сети
     35            if (eth_header->NETID!= MODEL.SYNC.panid)
     36              return false;
     37          
     38            // Фильтр 4: по адресу получателю
     39            if (eth_header->NDST != 0xffff )
     40              if (eth_header->NDST != MODEL.node_adr)
     41                return false;
     42            return true;
     43          }
     44          
     45          static inline void fill_meta_data(struct frame *frame){
     46            // Заполняем метаданные
     47            struct ETH_LAY *eth_header = (struct ETH_LAY*)frame->payload;
     48            frame->meta.NDST = eth_header->NDST;
     49            frame->meta.NSRC = eth_header->NSRC;
     50            frame->meta.PID = eth_header->ETH_T.bits.PID;  
     51          }
     52          
     53          static void parse_frame(struct frame *frame){
     54            // Разбор пакета
     55            if (!frame_filter(frame))
     56              return;
     57            
     58            fill_meta_data(frame);
     59            FR_del_header(frame, ETH_LAY_SIZE);
     60            RP_Receive(frame);  
     61          }
     62          
     63          void ethernet_process(void){
     64            // Извлекает все принятые пакеты из буфера
     65            void* cursor = BF_cursor_rx();
     66            void *cursor_delete;
     67            
     68            struct frame *rx_frame;
     69            
     70            while (cursor){
     71              rx_frame = BF_content(cursor);
     72              parse_frame(rx_frame);
     73              
     74              if (!FR_delete(rx_frame))
     75                HALT("Delete");
     76              
     77              cursor_delete = cursor;
     78              if (!BF_remove_rx(cursor_delete))
     79                HALT("Remove");
     80              
     81              cursor = BF_cursor_next(cursor);
     82            }
     83            if (!BF_remove_rx(cursor))
     84              HALT("Remove error");  
     85          };
E:\Neocore\Hardware\STACK_CORE_SRC\frame.c
      1          #include "action_manager.h"
      2          #include "frame.h"
      3          #include "debug.h"
      4          #include "global.h"
      5          #include "mem_utils.h"
      6          #include "mem_slots.h"
      7          
      8          /**
      9          @file Статическое хранение принятых пакетов
     10          */
     11          
     12          static void SW_Init(void); 
     13          
     14          module_s FR_MODULE = {ALIAS(SW_Init)};
     15          
     16          static void SW_Init(void){ 
     17          }; 
     18          
     19          struct frame* FR_create(){
     20            return (struct frame*)SL_alloc();
     21          };
     22          
     23          bool FR_delete(struct frame *frame){
     24            return SL_free((char*)frame);
     25          }
     26          
     27          bool FR_add_header(struct frame* frame ,void *head, char len){
     28            int new_len = frame->len + len;
     29            if (!(new_len < MAX_PAYLOAD_SIZE))
     30              return false;
     31            
     32            // Сдвинем данные на размер вставки при необходимости
     33            if (frame->len != 0)
     34              MEMCPY(&frame->payload[len], frame->payload, len);
     35            
     36            // Скопируем новые данные
     37            MEMCPY(frame->payload, head, len);
     38            frame->len = new_len;
     39            return true;
     40          };
     41          
     42          bool FR_del_header(struct frame* frame, char len){
     43            if (len == 0 || len > frame->len )
     44              return false;
     45            MEMCPY(frame->payload, &frame->payload[len], len);
     46            
     47            #ifdef FRAME_FOOTER_DEL
     48            MEMSET(&frame->payload[len], 0, len);
     49            #endif
     50            
     51            frame->len = frame->len - len;;
     52            return true;
     53          }
     54          
     55          int FR_busy(){
     56            return SL_busy();
     57          }
     58          
     59          int FR_available(){
     60            return SL_available();
     61          };
E:\Neocore\Hardware\PRG Node\ip.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "buffer.h"
      4          
      5          
      6          void IP_Receive(struct frame *frame){
      7          }
E:\Neocore\Hardware\Stack_core_src\led.c
      1          #include "action_manager.h"
      2          
      3          static void HW_Init(void);
      4          static void SW_Init(void);
      5          static void Cold_Start(void);
      6          static void Hot_Start(void);
      7          
      8          module_s LED_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
      9            ALIAS(Hot_Start), ALIAS(HW_Init)};
     10          
     11          static void HW_Init(void){};
     12          static void SW_Init(void){};
     13          static void Cold_Start(void){};
     14          static void Hot_Start(void){};
E:\Neocore\Hardware\STACK_CORE_SRC\llc.c
      1          #include "action_manager.h"
      2          #include "buffer.h"
      3          #include "stddef.h"
      4          #include "macros.h"
      5          #include "model.h"
      6          #include "debug.h"
      7          #include "radio.h"
      8          #include "mac.h"
      9          
     10          
     11          #define MAX_SLOTS 50
     12          
     13          #define RX_ALARM (1<<0)
     14          #define TX_ALARM (1<<1)
     15          
     16          static void SW_Init(void);
     17          static void Cold_Start(void);
     18          static void Hot_Start(void);
     19          static void IRQ_Init(void);
     20          
     21          module_s LLC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
     22            ALIAS(Hot_Start), ALIAS(IRQ_Init)};
     23          
     24          struct action{
     25            channel_t rx;
     26            struct frame *frame_tx;
     27          };
     28          
     29          static struct action ACTIONSLOTS[MAX_SLOTS];
     30          
     31          static void IRQ_Init(void){
     32            for_each_type(struct action, ACTIONSLOTS, slot){
     33              slot->rx = 0;
     34              slot->frame_tx = NULL;
     35            }
     36          };
     37          
     38          static void SW_Init(void){
     39            for_each_type(struct action, ACTIONSLOTS, slot){
     40              slot->rx = 0;
     41              slot->frame_tx = NULL;
     42            }
     43          };
     44          
     45          void LLC_open_slot(timeslot_t ts, channel_t ch){
     46            ASSERT(ts >= 1 && ts < MAX_SLOTS);
     47            ASSERT(ch >= MIN_CH && ch <= MAX_CH);
     48            ACTIONSLOTS[ts].rx = ch;
     49          }
     50          
     51          void LLC_close_slot(timeslot_t ts){
     52            ASSERT(ts >= 1 && ts < MAX_SLOTS);
     53            ACTIONSLOTS[ts].rx = 0;
     54          }
     55          
     56          bool LLC_add_tx_frame(struct frame *frame){
     57            ASSERT(frame);
     58            AES_StreamCoder(true, frame->payload, frame->payload, frame->len);    
     59            if (BF_push_tx(frame))
     60              return true;
     61            return false;
     62          }
     63          
     64          static void scheduler_tx(void){
     65            void *cursor = BF_cursor_tx();
     66            if (!cursor)
     67              return;
     68            
     69            struct frame *frame = NULL;
     70            while(cursor){
     71              frame = BF_content(cursor);
     72              ASSERT(frame->meta.TS != 0);
     73              // Если у нас есть что передавать, берем следующий кадр из буфера
     74              if (ACTIONSLOTS[frame->meta.TS].frame_tx){
     75                cursor = BF_cursor_next(cursor);
     76                continue;
     77              }
     78              ACTIONSLOTS[frame->meta.TS].frame_tx = frame;
     79              TM_SetAlarm(frame->meta.TS, TX_ALARM); 
     80              void* cursor_for_delete = cursor;
     81              cursor = BF_cursor_next(cursor);
     82              if (!BF_remove_tx(cursor_for_delete))
     83                HALT(FLASH_STR("Error"));
     84            }
     85          }
     86          
     87          static void scheduler_rx(void){
     88            ASSERT(ACTIONSLOTS[0].rx == 0);
     89            for (char i = 1; i < MAX_SLOTS; i++)
     90              if (ACTIONSLOTS[i].rx)
     91                TM_SetAlarm(i, RX_ALARM);
     92              else
     93                TM_ClrAlarm(i, RX_ALARM);
     94          }
     95          
     96          static void Cold_Start(void){
     97          // Планировщик планирует на один суперфрейм в начале ts0
     98            if (MODEL.TM.timeslot != 0)
     99              return;
    100            
    101            scheduler_tx();
    102            scheduler_rx();
    103          };
    104          
    105          static inline void receive(){
    106            timeslot_t ts = MODEL.TM.timeslot;
    107            MAC_Receive(ACTIONSLOTS[ts].rx);
    108          }
    109          
    110          static void transmite(void){
    111            timeslot_t ts = MODEL.TM.timeslot;
    112            struct frame *frame = ACTIONSLOTS[ts].frame_tx;
    113            
    114            if (!frame)
    115              HALT(FLASH_STR("Error"))
    116            
    117            // Неудачные передачи учитывает MAC_Send()
    118            int send_res = MAC_Send(frame);
    119            switch (send_res) {
    120              case 1: { // удачная передача
    121                TM_ClrAlarm(ts, TX_ALARM);
    122                ACTIONSLOTS[ts].frame_tx = NULL;
    123                LOG_ON("Send success");
    124                break;
    125              }
    126              case 0: { // неудачная передача. ACK не получен или CCA
    127                LOG_ON("CCA/ACK err")
    128                break;
    129              }
    130              case -1: { // Исчерпаны попытки отправки
    131                TM_ClrAlarm(ts, TX_ALARM);
    132                ACTIONSLOTS[ts].frame_tx = NULL;
    133                LOG_ON("Attempts exired");
    134                break;
    135              }
    136              default:
    137                HALT(FLASH_STR("Error"));
    138            };
    139          }
    140          
    141          static void Hot_Start(void){
    142            timeslot_t ts = MODEL.TM.timeslot;
    143            if (ts == 0)
    144              return;
    145            char alarm = MODEL.TM.alarm;
    146            
    147            if (alarm & TX_ALARM)
    148              transmite();
    149            else if (alarm & RX_ALARM)
    150              receive();
    151          };
E:\Neocore\Hardware\STACK_CORE_SRC\mac.c
      1          #include "action_manager.h"
      2          #include "frame.h"
      3          #include "coder.h"
      4          #include "radio.h"
      5          #include "ustimer.h"
      6          #include "debug.h"
      7          #include "model.h"
      8          #include "buffer.h"
      9          
     10          #define RECV_TIMEOUT 2500
     11          
     12          static void SW_Init(void);
     13          static void IRQ_Init(void);
     14          
     15          module_s MAC_MODULE = {ALIAS(SW_Init), ALIAS(IRQ_Init)};
     16          
     17          struct ack{ // Формат структуры пакета ACK
     18            char CRC8;
     19          } __attribute__((packed));
     20          
     21          static void SW_Init(void){};
     22          static void IRQ_Init(void){};
     23          
     24          
     25          static inline struct frame* _recv_frame(channel_t ch){
     26            if(!RI_SetChannel(ch))
     27              HALT(FLASH_STR("Wrong channel"));
     28            
     29            //UST_delay(400);
     30            nwtime_t NOW1 = AT_time();
     31            struct frame *frame = RI_Receive(RECV_TIMEOUT); //
     32            nwtime_t NOW2 = AT_time();
     33            return frame;
     34          }
     35          
     36          static uint8_t xor_calc(struct frame *frame){
     37            uint8_t crc = 0x34; // Начальное значение
     38            uint8_t *val = (uint8_t*)frame->payload;
     39            for (uint8_t i = 0; i < frame->len; i++)
     40              crc ^= val[i];
     41            return crc;
     42          }
     43          
     44          static inline void _send_ack(struct frame *frame){
     45            struct ack ack;
     46            struct frame *ack_frame;
     47            // Создаем подтверждение кадра
     48            ack.CRC8 = xor_calc(frame);
     49            // Создаем кадр для отправки
     50            ack_frame = FR_create();
     51            FR_add_header(ack_frame, &ack, sizeof(struct ack));
     52            ack_frame->meta.SEND_TIME = 0;
     53            RI_Send(ack_frame);
     54            FR_delete(ack_frame);  
     55          }
     56          
     57          void MAC_Receive(channel_t ch){
     58            struct frame *frame = _recv_frame(ch);
     59            if (!frame)
     60              return;
     61            
     62            frame->meta.TS = MODEL.TM.timeslot;
     63            if (MODEL.TM.timeslot > 1) // не системный таймслот требует подтверждения
     64              _send_ack(frame);
     65            
     66            AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
     67            
     68            LOG_ON("push");
     69            bool push_res = BF_push_rx(frame);
     70            if (!push_res){
     71              FR_delete(frame);
     72              LOG_ON("push del");
     73            }
     74            
     75          }
     76          
     77          static inline bool _send_frame(struct frame *frame){
     78            if(!RI_SetChannel(frame->meta.CH))
     79              HALT(FLASH_STR("Wrong channel"));  
     80            
     81            UST_delay(918);
     82            bool tx_success = RI_Send(frame);
     83            return tx_success;
     84          }
     85          
     86          static inline bool _recv_ack(struct frame *frame){
     87            return true;
     88          }
     89          
     90          int MAC_Send(struct frame *frame){
     91            bool tx_success = _send_frame(frame);
     92            
     93            bool ack_success = false;
     94            if (MODEL.TM.timeslot > 1) // Ждем подтверждения ack для не системных слотов
     95              ack_success = _recv_ack(frame);
     96            else
     97              ack_success = true;
     98            
     99            if (tx_success && ack_success){ // Удачная передача
    100              FR_delete(frame);
    101              return 1;
    102            }
    103            else{ // неудачная передача
    104              if (frame->meta.tx_attempts > 0)
    105                frame->meta.tx_attempts --;
    106              
    107              if (!frame->meta.tx_attempts){ // кончились попытки передачи
    108                FR_delete(frame);
    109                return -1;
    110              }
    111            }
    112            return 0;
    113          }
E:\Neocore\Hardware\PRG Node\main.c
      1          #include "action_manager.h"
      2          #include "time_manager.h"
      3          #include "debug.h"
      4          #include "model.h"
      5          #include "sync.h"
      6          #include "action_manager.h"
      7          #include "frame.h"
      8          #include "buffer.h"
      9          #include "model.h"
     10          #include "radio.h"
     11          #include "llc.h"
     12          
     13          static struct frame* get_frame(void){
     14            struct frame *frame = FR_create(); 
     15            char data[10] = {1,2,3,4,5,6,7,8,9,0};
     16            FR_add_header(frame, data, sizeof(data));
     17            frame->meta.tx_attempts = 3;
     18            frame->meta.TS = 2;
     19            frame->meta.CH = CH20;
     20            return frame;
     21          }
     22          
     23          static void callback(void){
     24            if (!(MODEL.RTC.rtc % 5))
     25              return;
     26            
     27            int tx_num = BF_tx_busy();
     28            
     29            if (tx_num){
     30              //LOG_ON("tx frames in buff %d", tx_num);
     31              return;  
     32            }
     33            
     34            struct frame *frame = get_frame();
     35            LLC_add_tx_frame(frame);
     36            LOG_ON("TX FRAME PUSH");
     37          }
     38          //TODO alarm manager вызывает из прерывания TM_IRQ
     39          //в TM_IRQ засоряется стек прерывания
     40          static void pre_init(void){
     41            AM_HW_Init();
     42            AM_SW_Init();
     43            LOG_ON("Hardware inited");
     44            MODEL.SYNC.mode = 1;
     45            MODEL.TM.MODE = 1;
     46            AM_set_callback(callback);
     47          }
     48          // TODO добавить в buffer.c размер RX и TX очереди
     49          void main(void){
     50            pre_init();
     51            LOG_ON("Node started");
     52            
     53            while (1){
     54              MODEL.SYNC.mode = 1;
     55              MODEL.TM.MODE = 1;
     56              while (!network_sync(1000000U));
     57              LOG_ON("Synced");
     58              Neocore_start();
     59              AM_SW_Init();
     60              LOG_ON("START RESYNC");
     61            }
     62          };
E:\Neocore\Hardware\STACK_CORE_SRC\mem_slots.c
      1          #include "debug.h"
      2          #include "global.h"
      3          #include "macros.h"
      4          #include "stdbool.h"
      5          #include "action_manager.h"
      6          #include "mem_utils.h"  
      7          #include "cpu.h"
      8          
      9          //!< Максимальный размер данных в одном слоте
     10          #define SLOT_BUFFER_SIZE 150
     11          #define RED_ZONE_CODE 0x73
     12          
     13          typedef char red_zone_t;
     14          
     15          static void SW_Init(void);
     16          module_s MS_MODULE = {ALIAS(SW_Init)};
     17          
     18          struct property{
     19            char taken: 1;
     20          };
     21          
     22          struct slot{
     23            struct property property;
     24            red_zone_t red_zone_1;
     25            char buffer[SLOT_BUFFER_SIZE];
     26            red_zone_t red_zone_2;
     27          };
     28          
     29          //!< Хранилище слотов
     30          static struct slot SLOT_POOL[SLOT_POOL_ITEMS];
     31          //!< Количество занятых слотов
     32          static int slot_busy;
     33          
     34          void SW_Init(void){
     35            slot_busy = 0;
     36            for_each_type(struct slot, SLOT_POOL, slot){
     37              slot->property.taken = false;
     38              #ifdef FILL_SLOT_ZERO
     39                MEMSET(slot->buffer, 0, SLOT_BUFFER_SIZE);
     40              #endif    
     41              slot->red_zone_1 = RED_ZONE_CODE;
     42              slot->red_zone_2 = RED_ZONE_CODE;
     43            }
     44          };
     45          
     46          /**
     47          @brief Возвращает указатель на буфер или NULL. Буфер заполнен 0
     48          @detail 
     49          */
     50          char* SL_alloc(void){  
     51            char *ret_ptr = NULL;
     52            ATOMIC_BLOCK_RESTORE{
     53              for_each_type(struct slot, SLOT_POOL, slot){
     54                if (!slot->property.taken){
     55                  slot->property.taken = true;
     56                  slot_busy++;
     57                  #ifdef FILL_SLOT_ZERO
     58                    MEMSET(slot->buffer, 0, SLOT_BUFFER_SIZE);
     59                  #endif
     60                  ret_ptr = slot->buffer;
     61                  break;
     62                };
     63              };  
     64            };
     65            return ret_ptr;
     66          };
     67          
     68          static bool _free(char *buff){
     69            struct slot *slot = container_of(buff, struct slot, buffer);
     70            
     71            if (!is_array_ptr(SLOT_POOL, slot, sizeof(struct slot)))
     72              return false;
     73            
     74            size_t index = array_index(SLOT_POOL, slot, sizeof(struct slot));
     75            if (!(index < SLOT_BUFFER_SIZE))
     76              return false;
     77            
     78            if (slot->property.taken != true)
     79              return false;
     80              
     81            slot->property.taken = false;
     82            slot_busy--;
     83            return true;
     84          }
     85          
     86          bool SL_free(char *buff){
     87            bool res;
     88            ATOMIC_BLOCK_RESTORE{
     89              res = _free(buff);
     90            }
     91            return res;
     92          };
     93          
     94          
     95          int SL_busy(){
     96            ASSERT(slot_busy <= SLOT_POOL_ITEMS);
     97            return slot_busy;
     98          };
     99          
    100          int SL_available(){
    101            ASSERT(slot_busy <= SLOT_POOL_ITEMS);  
    102            return SLOT_POOL_ITEMS - slot_busy;
    103          };
    104          
    105          int SL_zone_check(){
    106            int index = 0;
    107            for_each_type(struct slot, SLOT_POOL, slot){
    108              if (!(slot->red_zone_1 == RED_ZONE_CODE &&
    109                    slot->red_zone_2 == RED_ZONE_CODE))
    110                return index;
    111              index++;
    112            }
    113            return -1;
    114          };
    115          
E:\Neocore\Hardware\STACK_CORE_SRC\mem_utils.c
      1          #include "mem_utils.h"
      2          #include "debug.h"
      3          
      4          /**
      5          @file Реентерабельное копирование
      6          */
      7          
      8          void MEM_memcpy(struct memcpy *memcpy){
      9            while (memcpy->len > 0){
     10              *memcpy->dst = *memcpy->src;
     11              memcpy->dst++;
     12              memcpy->src++;
     13              memcpy->len--;
     14            }
     15          };
     16          
     17          void MEM_memset(struct memset *memset){
     18            while (memset->len > 0){
     19              *memset->dst = memset->val;
     20              memset->dst++;
     21              memset->len--;
     22            }  
     23          };
     24          
     25          
E:\Neocore\Hardware\Stack_core_src\model.c
      1          #include "model.h"
      2          #include "action_manager.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          MODEL_s MODEL;
      9          
     10            
     11          static void SW_Init(void); 
     12          
     13          module_s MD_MODULE = {ALIAS(SW_Init)};
     14          
     15           
     16          static void SW_Init(void){}; 
     17          
     18          
E:\Neocore\Hardware\PRG Node\neigh.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "buffer.h"
      4          
      5          #define NB_TABLE_ITEMS 20
      6          #define MAX_OPEN_SLOTS 2
      7          #define REQ_CMD  0
      8          #define NB_FRAME_CARD_SIZE sizeof(struct frame_card)
      9          #define NB_FRAME_REQ_SIZE sizeof(struct frame_req)
     10          #define NB_TABLE_SIZE sizeof(struct table)
     11          
     12          #warning GW may open lot of slots
                  ^
Warning[Pe1105]: #warning directive: GW may open lot of slots
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
     13          // Шлюз имеет предопределенные временные слоты и каналы?
     14          struct frame_card{ // Информационная карточка узла
     15              char ts_slots[MAX_OPEN_SLOTS]; // Временые слоты приема пакетов
     16              char ch_slots[MAX_OPEN_SLOTS]; // Частоты приема пакетов
     17              char ETX; // 0 - шлюз, 1 - одна передача до шлюза
     18          }__attribute__((packed));
     19          
     20          struct frame_req{ //Запрос от другого узла
     21            uint8_t cmd_req; // 0 - запрос информации
     22          }__attribute__((packed));
     23          
     24          
     25          struct table{
     26            unsigned int node_addr; // Адрес узла
     27            signed char RSSI_SIG;
     28            signed char LIQ;
     29            char weight; // Качество узла от 0 до 255. 0 - плохо
     30            struct frame_card card; // Информация об узле
     31            unsigned long update_time; // Время обновления записи
     32            bool record_active; // Запись действительна 
     33          } ;
     34          
     35          static struct table NB_TABLE[NB_TABLE_ITEMS];
     36          static unsigned long LAST_TIME_CARD_RECIEVED;
     37          
     38          static int find_index(struct frame *frame){
     39            // Попробуем найти пакет
     40            for (uint8_t i = 0; i < NB_TABLE_ITEMS; i++)
     41              if (NB_TABLE[i].node_addr == frame->meta.NSRC)
     42                if (NB_TABLE[i].record_active)
     43                  return i;
     44            return -1;
     45          }
     46          
     47          /**
     48          
     49          @brief Ищем свободное место
     50          
     51          @return -1 
     52          
     53          */
     54          
     55          static int find_free_index(){
     56            for (uint8_t i = 0; i < NB_TABLE_ITEMS; i++)
     57              if (!NB_TABLE[i].record_active)
     58                return i;
     59            return -1;
     60          }
     61          
     62          /**
     63          @brief Вычисляет вес карты
     64          @return 0 - плохо, 255 отлично
     65          */
     66          static uint8_t calc_weight(struct frame_card *card){
     67            // Сравнивает две карты по ETX, LIQ(пока не доступно), RSSI
     68            // ПОДУМАТЬ. При маршрутизаии от шлюза сохраняются маршруты до соседей
     69            // Если нет соседа ( выкинули его) то маршрут разрушится
     70            return 0;
     71          }
     72          
     73          /**
     74          
     75          @brief Обновление карточки по индексу
     76          
     77          */
     78          
     79          static void update_record(struct frame *frame, uint8_t index){
     80            struct frame_card *card = (struct frame_card*)frame->payload;
     81            re_memcpy(&NB_TABLE[index].card, card, NB_FRAME_CARD_SIZE);
                   ^
Warning[Pe223]: function "re_memcpy" declared implicitly
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
     82            NB_TABLE[index].update_time = MODEL.RTC.uptime;
     83            uint8_t weight = calc_weight(card);
     84            NB_TABLE[index].weight = weight;
     85            NB_TABLE[index].node_addr = frame->meta.NSRC;
     86            NB_TABLE[index].record_active = true;
     87            NB_TABLE[index].RSSI_SIG = frame->meta.RSSI_SIG;
     88            NB_TABLE[index].LIQ = frame->meta.LIQ;
     89          }
     90          
     91          static void insert_record(struct frame *frame){
     92            int index = find_free_index();
     93            struct frame_card *card = (struct frame_card*)frame->payload;
     94            uint8_t weight = calc_weight(card);
     95            if (index != -1){ // Нашли место, запихиваем карточку
     96              update_record(frame,index);
     97              LOG_ON("Card inserted.")
     98              return;
     99            }
    100            
    101            uint8_t bad_index, bad_weight = 255;
    102            bool found = false;
    103          
    104            // Свободных мест нет. Ищем самую плохую запись
    105            for (uint8_t i = 0; i < NB_TABLE_ITEMS; i++)
    106              if (NB_TABLE[i].record_active){
    107                if (NB_TABLE[i].weight < bad_weight){
    108                  bad_weight = NB_TABLE[i].weight ;
    109                  bad_index = i;
    110                  found = true;
    111                 }
    112              }
    113          
    114            if (!found){ // Если нету записей.
    115              LOG_ON("Card is bad. not inserted")
    116              return;
    117            }
    118            if (weight > bad_weight){ //// Карточка лучше чем самая плохая в таблице
    119              LOG_ON("Better card inserted")
    120              update_record(frame, bad_index);
    121            }
    122          }
    123          
    124          static bool frame_filter_card(struct frame *frame){ 
    125            // Фильтр 1: по размеру кадра
    126            if (frame->len < NB_FRAME_CARD_SIZE)
    127              return false;
    128            // struct frame_card *card = (struct frame_card*)frame->payload;
    129            // TODO Тут интелектуалные фильтры по содержимому
    130            // Желательно проверять что именно нам прислали и являются
    131            // ли данные корректными
    132            return true;
    133          }
    134          
    135          static bool frame_filter_cmd_req(struct frame *frame){
    136            // Фильтр 1: по размеру кадра
    137            if (frame->len < NB_FRAME_REQ_SIZE)
    138              return false;
    139            // TODO проверить доступные команды
    140            //struct frame_req *cmd_req = (struct frame_req*)frame->payload;
    141            return true;
    142          }
    143          /**
    144          
    145          @brief Обработка принятой карты 
    146          
    147          */
    148          
    149          static void process_card(struct frame *frame){
    150            int index = find_index(frame);
    151          
    152            if (index == -1) // Если нет записи об этом узле, вставим
    153              insert_record(frame);
    154            else{ // Если запись есть, то обновим 
    155              LOG_ON("Update card")
    156              update_record(frame, index);
    157            }
    158            // Обновим время получения последней карточки
    159            // мне не важно вставили или нет, главное что они регулярно приходят
    160            LAST_TIME_CARD_RECIEVED = MODEL.RTC.uptime;
    161          }
    162          
    163          static void send_card(void){
    164            struct frame_card card;
    165          
    166            int etx = NP_GetETX();
                             ^
Warning[Pe223]: function "NP_GetETX" declared implicitly
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    167            
    168            // Выходим если ETX не определен
    169            if (etx == -1){
    170              // Раз нет ETX то продлим время отправки карты
    171              uint32_t now = MODEL.RTC.uptime();
                                    ^
Error[Pe109]: expression preceding parentheses of apparent call must have
          (pointer-to-) function type
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    172              NEXT_CARD_SEND_TIME = now + NEIGHBOR_CARD_SEND_INTERVAL + 
                     ^
Error[Pe020]: identifier "NEXT_CARD_SEND_TIME" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"

      NEXT_CARD_SEND_TIME = now + NEIGHBOR_CARD_SEND_INTERVAL + 
                                  ^
"E:\Neocore\Hardware\PRG Node\neigh.c",172  Error[Pe020]: identifier
          "NEIGHBOR_CARD_SEND_INTERVAL" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    173                rand() % NEIGHBOR_CARD_SEND_INTERVAL_DEV;
                       ^
Warning[Pe223]: function "rand" declared implicitly
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"

        rand() % NEIGHBOR_CARD_SEND_INTERVAL_DEV;
                 ^
"E:\Neocore\Hardware\PRG Node\neigh.c",173  Error[Pe020]: identifier
          "NEIGHBOR_CARD_SEND_INTERVAL_DEV" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    174              LOG_ON("ETX not defind. Card not sended.")
    175              return;
    176            }
    177          
    178            card.ETX = etx;
    179          
    180            // Проверим что у нас есть открытые слоты
    181            bool opened = false;
    182            for (uint8_t i = 0; i < MAX_OPEN_SLOTS; i++){
    183            if (CONFIG.ts_slots[i] !=0 )
                       ^
Error[Pe020]: identifier "CONFIG" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    184              if (CONFIG.ch_slots[i] !=0){
    185                opened = true;
    186                break;
    187              }
    188            }
    189          
    190           
    191            if (!opened){
    192              uint32_t now = TIC_GetUptime();
                                    ^
Warning[Pe223]: function "TIC_GetUptime" declared implicitly
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    193              NEXT_CARD_SEND_TIME = now + NEIGHBOR_CARD_SEND_INTERVAL + 
                     ^
Error[Pe020]: identifier "NEXT_CARD_SEND_TIME" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"

      NEXT_CARD_SEND_TIME = now + NEIGHBOR_CARD_SEND_INTERVAL + 
                                  ^
"E:\Neocore\Hardware\PRG Node\neigh.c",193  Error[Pe020]: identifier
          "NEIGHBOR_CARD_SEND_INTERVAL" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    194                rand() % NEIGHBOR_CARD_SEND_INTERVAL_DEV;
                       ^
Warning[Pe223]: function "rand" declared implicitly
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"

        rand() % NEIGHBOR_CARD_SEND_INTERVAL_DEV;
                 ^
"E:\Neocore\Hardware\PRG Node\neigh.c",194  Error[Pe020]: identifier
          "NEIGHBOR_CARD_SEND_INTERVAL_DEV" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    195              LOG_ON("Slots not opened. Card not sended.")
    196              return;
    197            }
    198          
    199            for (uint8_t i = 0; i < MAX_OPEN_SLOTS; i++){
    200              card.ts_slots[i] = CONFIG.ts_slots[i];
                                        ^
Error[Pe020]: identifier "CONFIG" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    201              card.ch_slots[i] = CONFIG.ch_slots[i];
    202            }
    203          
    204            frame_s *fr = frame_create();
                   ^
Error[Pe020]: identifier "frame_s" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"

    frame_s *fr = frame_create();
             ^
"E:\Neocore\Hardware\PRG Node\neigh.c",204  Error[Pe020]: identifier "fr" is
          undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"

    frame_s *fr = frame_create();
                  ^
"E:\Neocore\Hardware\PRG Node\neigh.c",204  Warning[Pe223]: function
          "frame_create" declared implicitly
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    205            frame_addHeader(fr, &card, NB_FRAME_CARD_SIZE);
                   ^
Warning[Pe223]: function "frame_addHeader" declared implicitly
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    206            fr->meta.PID = PID_NP;
                                  ^
Error[Pe020]: identifier "PID_NP" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    207            fr->meta.NDST = 0xffff;
    208            fr->meta.NSRC = CONFIG.node_adr; 
                                   ^
Error[Pe020]: identifier "CONFIG" is undefined
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    209            fr->meta.TS = 0;
    210            fr->meta.CH = CONFIG.sys_channel;
    211            fr->meta.TX_METHOD = BROADCAST;
    212            RP_Send(fr);
                   ^
Warning[Pe223]: function "RP_Send" declared implicitly
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
    213            LOG_ON("NP Card sended");
    214          }
    215          
    216          
    217          /**
    218          @brief Обработка принятой команды
    219          */
    220          static void process_cmd_req(struct frame *frame){
    221            struct frame_req *cmd_req = (struct frame_req*)frame->payload;  
    222          
    223            // Запрос информации об узле
    224            if (cmd_req->cmd_req == REQ_CMD)
    225              send_card();
    226            LOG_ON("CMD reques processed.")
    227          }
    228          
    229          void NP_Receive(struct frame *frame){
    230            if (frame->meta.NSRC == 0xffff)
    231              return;
    232            
    233            if (frame_filter_card(frame))
    234                process_card(frame);
    235            else if (frame_filter_cmd_req(frame))
    236                process_cmd_req(frame);
    237          }
E:\Neocore\Hardware\STACK_CORE_SRC\radio.c
      1          #include "radio.h"
      2          #include "mem_utils.h"
      3          #include "debug.h"
      4          #include "radio_defs.h"
      5          #include "ustimer.h"
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "alarm_timer.h"
      9          #include "model.h"
     10          #include "action_manager.h"
     11          #include "frame.h"
     12          #include "macros.h"
     13          #include "stdlib.h"
     14          
     15          static void HW_Init(void);
     16          static void SW_Init(void);
     17          module_s RADIO_MODULE = {ALIAS(SW_Init), ALIAS(HW_Init)};
     18          
     19          static void random_core_init(void);
     20          static char RXBUFF[128];
     21          
     22          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     23          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     24          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     25          /*!
     26          \details 
     27           Расчет качества связи. Коэффициенты получаются эксперементально.
     28           Есть предположение, что количество ошибок будет пропорционально квадрату
     29           коеффициента корреляции сигнала.
     30           LIQ = 255 передача 1000 пакетов без ошибок CRC
     31           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     32           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     33          */ 
     34          
     35          #define CONST_A (int8_t)0 //!< Коэффициент A
     36          #define CONST_B (int8_t)1 //!< Коэффициент B
     37          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     38          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     39          
     40          #ifdef RADIO_DEBUG
     41            #define WRITE_TIME_DBG(where) (where) = AT_time()
     42            #define WRITE_PARA_DBG(where,val) (where) = (val) 
     43          #else
     44            #define WRITE_TIME_DBG(where) {}
     45            #define WRITE_PARA_DBG(where,val)
     46          #endif
     47          
     48          static void SW_Init(void){
     49            // Настройки поумолчанию
     50            MODEL.RADIO.CRCError = 0;
     51            MODEL.RADIO.CCAReject = 0;
     52            MODEL.RADIO.channel = CH11;
     53            MODEL.RADIO.power_tx = m0x5;
     54            // Пост действия с радио
     55            random_core_init();
     56          }
     57          
     58          static void HW_Init(void){
     59            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
     60            MDMTEST1_u MDM1; // Устанавливаем режим модуляции
     61            MDM1.value = MDMTEST1;
     62            MDM1.bits.MODULATION_MODE = IEEE_MODE;
     63            MDMTEST1 = MDM1.value;   
     64          }
     65          
     66          static inline void setFreq(channel_t ch)
     67          {
     68            ASSERT( (ch >= MIN_CH) && (ch <= MAX_CH));
     69            // Устанавливаем частоту радиопередатчика
     70            FREQCTRL_u FRQ;
     71            FRQ.value = FRQ_CALC(MODEL.RADIO.channel);
     72            FREQCTRL = FRQ.value;  
     73          }
     74          
     75          static inline void pre_config(void){
     76            setFreq(MODEL.RADIO.channel); 
     77            TXPOWER = MODEL.RADIO.power_tx;
     78          }
     79          
     80          bool RI_SetChannel(channel_t channel){
     81            if (!(channel >= MIN_CH) && (channel <= MAX_CH))
     82              return false;
     83            MODEL.RADIO.channel = channel;
     84            return true;
     85          }
     86          
     87          static void LoadTXData(char *src, size_t len){
     88            ISFLUSHTX(); // Очищаем буфер передатчика
     89            RFD = len + 2; // Поле LEN на два байта больше
     90            for (size_t i = 0 ; i < len; i++)
     91              RFD = src[i];
     92            RFD = 0x00; // Добавляем CRC1,2
     93            RFD = 0x00;
     94          };
     95          
     96          static bool SendData(struct frame *fr){
     97            LoadTXData(fr->payload, fr->len);
     98            
     99            // Прежде чем включать радио нужно подождать
    100            if (fr->meta.SEND_TIME != 0) 
    101                AT_wait(fr->meta.SEND_TIME - 29);
    102            
    103            ISRXON();
    104            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.isrxon);
    105            RFIRQF1 &= ~RFIRQF1_TXDONE;
    106            RFIRQF0 &= ~RFIRQF0_SFD; 
    107            bool result = true;
    108            while(!RSSISTAT);
    109            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.rssistat);
    110            TRY{
    111              if (fr->meta.SEND_TIME != 0) // Отправка в определеное время
    112                AT_wait(fr->meta.SEND_TIME - 13); 
    113              ISTXONCCA();
    114              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.istxoncca);
    115              if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    116                THROW(1);
    117              // Ждем отправки SFD
    118              while (!(RFIRQF0 & RFIRQF0_SFD));
    119              fr->meta.TIMESTAMP = AT_time();
    120              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.sfd);
    121              // Ждем завершения отправки сообщения
    122              while (!(RFIRQF1 & RFIRQF1_TXDONE));
    123              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.txdone);
    124              
    125            }
    126            CATCH(1){ //SAMPLED_CCA == 0
    127              result = false;
    128            }
    129            FINALLY{
    130              ISRFOFF();
    131            }
    132            ETRY;  
    133            return result;
    134          }
    135          
    136          /*!
    137          \brief Передает данные в эфир
    138          */
    139          bool RI_Send(struct frame *fr){
    140            ASSERT(fr != NULL);
    141            pre_config();
    142            stamp_t start = UST_now();
    143            bool send_res = SendData(fr);
    144            stamp_t stop = UST_now();
    145            //TODO Неверно считает интервал так как при отправке
    146            // sync пакета мы ждем
    147            ustime_t tx_time = UST_interval(start, stop); 
    148            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.fulltime, tx_time);
    149            MODEL.RADIO.UptimeTX += tx_time;
    150            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.ccasampled, send_res);
    151            if (!send_res)
    152              MODEL.RADIO.CCAReject++;
    153            return send_res;
    154          }
    155          
    156          
    157          static void UnLoadRXData(char *src, size_t len){
    158            for (size_t i = 0 ; i < len; i++)
    159              src[i] = RFD;
    160          };
    161          
    162          
    163          static bool RecvData(ustime_t timeout, nwtime_t *sfd_stamp){   
    164            bool recv_result = true;
    165            
    166            ISFLUSHRX();
    167            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    168            RFIRQF0 &= ~RFIRQF0_SFD; 
    169            ISRXON();
    170            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.isrxon);
    171            stamp_t start = UST_now();
    172            TRY{
    173              while(true){
    174                if (UST_time_over(start, timeout))
    175                  THROW(1);
    176                
    177                if ((RFIRQF0 & RFIRQF0_SFD)){ // Принят сигнал SFD
    178                  *sfd_stamp = AT_time(); 
    179                  WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.sfd);
    180                  break;
    181                }
    182              }
    183              // Ждем окончания приема пакета
    184              while (!(RFIRQF0 & RFIRQF0_RXPKTDONE));
    185              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.rxdone);
    186            }
    187            CATCH(1){ // Вышло время ожидания
    188              recv_result = false;
    189            }
    190            FINALLY{
    191              ISRFOFF();
    192            }
    193            ETRY;
    194            return recv_result;
    195          }
    196          
    197          /*!
    198          \brief Принимает данные из эфира
    199          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    200          RI_CRC_ERROR. Отмечает время прихода SFD в тактах сетевого времени .
    201          \param[in] timeout Время ожидания данных в микросекундах
    202          \return Возвращает NULL если данных нет
    203          */
    204          struct frame* RI_Receive(ustime_t timeout){
    205            // Устанавливаем частоту передачи пакета
    206            pre_config();
    207            nwtime_t sfd_stamp;
    208               
    209            // Принимаем пакет 
    210            stamp_t start = UST_now();
    211            bool recv_res = RecvData(timeout, &sfd_stamp);
    212            stamp_t stop = UST_now();
    213            ustime_t rx_time = UST_interval(start, stop); 
    214            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_RX.fulltime, rx_time);
    215            MODEL.RADIO.UptimeRX += rx_time;
    216            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_RX.received, recv_res);
    217            if (!recv_res) // Нет пакета, возвращаем NULL
    218              return NULL;
    219            
    220            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    221            
    222            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    223            if (frame_size <= 2)
    224              return NULL;
    225            
    226            UnLoadRXData(RXBUFF, frame_size);
    227            
    228            int8_t  FCS1 = RXBUFF[frame_size - 2]; // RSSI
    229            uint8_t FCS2 = RXBUFF[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    230            uint8_t LEN_F = RXBUFF[0]; // Поле LEN
    231            
    232            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    233            // с фактической длинной принятых данных
    234            if (LEN_F != frame_size - 1){
    235              MODEL.RADIO.CRCError++;
    236              return NULL;
    237            }
    238            
    239            // Проверим поле CRCOK
    240            if (!(FCS2 && 1<<7)){
    241              MODEL.RADIO.CRCError++;
    242              return NULL;
    243            }
    244            
    245            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    246            struct frame *frame = FR_create();
    247            ASSERT(frame);
    248            bool add_h = FR_add_header(frame, &RXBUFF[1], frame_size - 3);
    249            ASSERT(add_h);
    250            
    251            frame->meta.TIMESTAMP = sfd_stamp;
    252            frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    253            uint8_t corr = FCS2 & 0x7F;
    254            frame->meta.LIQ = LIQ_CALC(corr);
    255            frame->meta.CH = MODEL.RADIO.channel;
    256            return frame;
    257          }
    258          
    259          
    260          /**
    261          @breif Подссчет количества бит в байте
    262          @return Возвращает количество бит
    263          */
    264          static uint8_t bits_count(uint8_t value) {
    265            int ret = 0;
    266            for ( ; value; value = value >> 1 )
    267              ret += value & 1;
    268            return ret;
    269          }
    270          
    271          /**
    272          @brief Возращает 1 байт случайного числа
    273          @details Радио выдает всего лишь дви бита, нам нужно 8 
    274          */
    275          static inline uint8_t getRNDByte(void)
    276          {
    277            uint8_t val = 0;
    278            val |= RFRND << 0;
    279            val |= RFRND << 2;
    280            val |= RFRND << 4;
    281            val |= RFRND << 6;
    282            return val;
    283          }
    284          
    285          /**
    286          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    287          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    288          возвращает гарантированно новое значение. 
    289          @return возвращает случайное число.
    290          */
    291          static inline uint8_t readRandom(void)
    292          {
    293            uint8_t rnd_val = 0;
    294            uint8_t bit_cnt = 0;
    295            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    296            {
    297              rnd_val = getRNDByte();
    298              while (rnd_val == getRNDByte());
    299              rnd_val = getRNDByte();
    300              bit_cnt = bits_count(rnd_val);
    301            }
    302            return rnd_val;
    303          }
    304          
    305          /*!
    306          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    307          */
    308          static void random_core_init(void)  
    309          {
    310            unsigned int rnd_core = 0;;
    311               
    312            pre_config();
    313            FREQCTRL = 0x00; // Выбираем не используемую частоту
    314          
    315            // TODO По какой то причине OP_EXE не выполняет команду.
    316            // регистра RFST читается как 0xD0. это его состояние при reset
    317            // Включаем демодулятор
    318            ISRXON();
    319            
    320            // Ждем пока статус RSSI_VALID станет true
    321            while(!RSSISTAT);
    322            
    323            // Ждем случайных чисел
    324            while (RFRND == 0);
    325            
    326            // Настраиваем ядро случайного генератора
    327            rnd_core = readRandom();
    328            rnd_core |= (unsigned int)readRandom()<<8;
    329            srand(rnd_core);
    330            
    331            // Выключаем демодулятор
    332            ISRFOFF();
    333            // Первая генерация случайного числа занимает много времени.
    334            // Влияло на работу радио, так как использовались случайные посылки
    335            rand(); 
    336          }
    337          
    338          /**
    339          @brief Измерение мощности сигнала
    340          @details Частота = 2394+fch. fch = [0..113]. 2394MHz to 2507MHz.
    341           Устройство поддерживает частоты до 2507 МГц
    342          @param[in] fch номер ЧАСТОТНОГО канала
    343          @param[in] timeout_ms время сканирования в мс
    344          @param[out] Максимальная мощность сигнала за время сканирования
    345          @return true если успешно
    346          */
    347          bool RI_Measure_POW(char fch, ustime_t timeout, 
    348                              int8_t *RSSI_SIG){
    349            if (fch > 113)
    350              return false;
    351            //(2394+FREQCTRL.FREQ[6:0])
    352            FREQCTRL = fch; // Выбираем не используемую частоту
    353            ISRXON();
    354            while(!RSSISTAT);
    355            FRMCTRL0 |= 1<<4; // включаем ENERGY_SCAN, детектор пикового сигнала
    356            UST_delay(timeout);
    357            int8_t rssi = RSSI + RSSI_OFFSET;
    358            *RSSI_SIG = rssi;
    359            ISRFOFF();
    360            return true;
    361          }
    362          
E:\Neocore\Hardware\PRG Node\route.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "buffer.h"
      4          #include "protocol_defs.h"
      5          #include "ip.h"
      6          #include "neigh.h"
      7          #include "balancer.h"
      8          
      9          #define ROUTE_TABLE_ITEMS 20
     10          
     11          struct route_record{
     12            unsigned int nsrc;
     13            unsigned int fsrc;
     14            unsigned long update_time;
     15            bool record_active;
     16          } __attribute__((packed));
     17          
     18          static struct route_record ROUTE_TABLE[ROUTE_TABLE_ITEMS];
     19          
     20          void RP_Receive(struct frame *frame){
     21            #warning update route tables
                    ^
Warning[Pe1105]: #warning directive: update route tables
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\route.c"
     22            switch (frame->meta.PID){
     23            case PID_IP: 
     24              IP_Receive(frame);
     25              break;
     26            case PID_NP: 
     27              NP_Receive(frame);
     28              break;
     29            default:
     30              return; // Пакет удалит ethernet
     31            };
     32            
     33            TB_Receive(frame);  
     34          };
     35          
     36          void RP_Send_GW(struct frame *frame){
     37          };
     38          
     39          void RP_Send(struct frame *frame){
     40          };
     41          
     42          void RP_SendRT_GW(struct frame *frame){
     43          };
     44          
     45          void RP_SendRT_RT(struct frame *frame){
     46          };
E:\Neocore\Hardware\Stack_core_src\rtc.c
      1          #include "action_manager.h"
      2          #include "model.h"
      3           
      4          static void SW_Init(void); 
      5          static void Cold_Start(void);
      6          static void Hot_Start(void);
      7          
      8          module_s RTC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
      9            ALIAS(Hot_Start)};
     10           
     11          static void SW_Init(void){}; 
     12          static void Cold_Start(void){};
     13          
     14          
     15          static void Hot_Start(void){
     16            if (MODEL.TM.timeslot != 0)
     17              return;    
     18            MODEL.RTC.uptime++;
     19            MODEL.RTC.rtc++;
     20          };
E:\Neocore\Hardware\STACK_CORE_SRC\sync.c
      1          #include "sync.h"
      2          #include "action_manager.h"
      3          #include "radio.h"
      4          #include "model.h"
      5          #include "alarm_timer.h"
      6          #include "debug.h"
      7          #include "frame.h"
      8          #include "coder.h"
      9          #include "stdlib.h"
     10          #include "macros.h"
     11          #include "global.h"
     12          
     13          #define MODE_0 0 // Отклчена модуль синхронизации 
     14          #define MODE_1 1 // Прием, ретрансляция, синхронизация
     15          #define MODE_2 2 // Периодическое вещание
     16          #define SYNC_TS 0 // Слот для синхронизации
     17          #define MAGIC 0x19833891 // Проверка что пакет действительно sync
     18          #define SYNC_TIME 163 // Точное время отправки пакета.nwtime
     19          #define NEG_RECV_OFFSET 33 // nwtime
     20          #define POS_RECV_OFFSET 33 // nwtime
     21          #define SEND_PERIOD 10 // Периодичность отправки пакетов
     22          #define RETRANSMITE_TRY 3 // Кол-во попыток отправки sync
     23          #define PROBABILIT 40 // % вероятность одной попытки отправки 
     24          #define UNSYNC_TIME 60 // Время в секундах рассинхронизации сети
     25          
     26          static void SW_Init(void);
     27          static void Cold_Start(void);
     28          static void Hot_Start(void);
     29          static bool send_sync(void);
     30          static struct frame* recv_sync(void);
     31          static char retransmite;
     32          
     33          module_s SYNC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
     34            ALIAS(Hot_Start)};
     35          
     36          struct sync{
     37            char sys_ch;
     38            char tx_power;
     39            char panid;
     40            unsigned long rtc;
     41            unsigned long magic;
     42          } __attribute__((packed));
     43          
     44          static void SW_Init(void){ 
     45            MODEL.SYNC.next_sync_send = 0;
     46            MODEL.SYNC.next_time_recv = 0;
     47            MODEL.SYNC.last_time_recv = 0;
     48            MODEL.SYNC.sys_channel = DEFAULT_SYS_CH;
     49            MODEL.SYNC.sync_channel = DEFAULT_SYNC_CH;
     50            retransmite = 0;
     51          };
     52          
     53          static void Cold_Start(void){
     54          };
     55          
     56          static inline bool validate_sync(struct sync *sync){
     57            bool valid = 
     58              (sync->magic == MAGIC) &&
     59              (sync->panid == MODEL.SYNC.panid);
     60            return valid;
     61          }
     62          
     63          static inline void accept_sync_data(struct sync *sync){
     64            MODEL.RTC.rtc = sync->rtc;
     65          };
     66          
     67          static inline void syncronize_timer(struct frame *frame){
     68            nwtime_t now = AT_time();
     69            // Время прошедшее с момента получения пакета
     70            // RI_Send корректриует время, чтобы SFD был передан в SEND_TIME
     71            // Поэтому нам корректировать ненужно
     72            nwtime_t passed = AT_interval(now, frame->meta.TIMESTAMP);  
     73            AT_set_time(SYNC_TIME + passed);
     74            MODEL.SYNC.sync_err = SYNC_TIME - frame->meta.TIMESTAMP;
     75            LOG_ON("Sync err %d", MODEL.SYNC.sync_err);
     76          };
     77          
     78          static inline void mode_1_receive_process(void){
     79            LOW(PIN1);
     80            struct frame *fr = recv_sync();
     81            if (!fr)
     82              return;
     83            
     84            struct sync *sync = (struct sync*)(fr->payload);
     85            if (!validate_sync(sync)){
     86              FR_delete(fr);
     87              return;
     88            }
     89            syncronize_timer(fr);
     90            accept_sync_data(sync);
     91            FR_delete(fr);
     92            LOG_ON("Sichronize sync RSSI = %d", fr->meta.RSSI_SIG);
     93            retransmite = RETRANSMITE_TRY;
     94            MODEL.SYNC.next_time_recv = MODEL.RTC.uptime + SEND_PERIOD;
     95            MODEL.SYNC.last_time_recv = MODEL.RTC.uptime;   
     96            HIGH(PIN1);
     97          }
     98          
     99          static inline bool _throw_dice(void){
    100            return  ((rand() % 100) <= PROBABILIT) ? true : false;
    101          };
    102          
    103          static inline void mode_1_retransmition_process(void){
    104            retransmite--;
    105            if (!_throw_dice())
    106              return;
    107            send_sync();
    108            retransmite = 0;
    109          }
    110          
    111          static void mode_1_process(){
    112           // Прием, ретрансляция, синхронизация   
    113            if ( MODEL.RTC.uptime >= MODEL.SYNC.next_time_recv)
    114              mode_1_receive_process();
    115            else if(retransmite)
    116              mode_1_retransmition_process();
    117            
    118            if (MODEL.RTC.uptime - MODEL.SYNC.last_time_recv > UNSYNC_TIME){
    119              MODEL.SYNC.synced = false;
    120              MODEL.SYNC.mode = 0;
    121              MODEL.TM.MODE = 0;
    122              LOG_ON("unsynced");
    123            }
    124          }
    125          
    126          static void mode_2_process(){
    127            // Периодическое вещание
    128            if ( MODEL.RTC.uptime < MODEL.SYNC.next_sync_send)
    129              return;
    130            MODEL.SYNC.next_sync_send = MODEL.RTC.uptime + SEND_PERIOD;
    131            LOW(PIN1);
    132            send_sync();
    133            HIGH(PIN1);
    134          }
    135          
    136          static void Hot_Start(void){
    137            if (MODEL.TM.timeslot != SYNC_TS)
    138              return;
    139            switch(MODEL.SYNC.mode){
    140              case MODE_0: break;
    141              case MODE_1: mode_1_process(); break;
    142              case MODE_2: mode_2_process(); break;
    143              default:
    144              HALT(FLASH_STR("Wrong mode"));
    145            }
    146          };
    147          
    148          static struct frame* recv_sync(void){
    149            if(!RI_SetChannel(MODEL.SYNC.sync_channel))
    150              HALT(FLASH_STR("Wrong channel"));
    151            struct frame *frame;
    152            
    153            AT_wait(SYNC_TIME - NEG_RECV_OFFSET);
    154            ustime_t recv_time = NWTIME_TO_US(NEG_RECV_OFFSET + POS_RECV_OFFSET);
    155            TRY{
    156              frame = RI_Receive(recv_time);
    157              if (!frame)
    158                THROW(1);
    159              if (frame->len != sizeof(struct sync))
    160                THROW(2);
    161              AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
    162              return frame;
    163            }
    164            CATCH(1){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    165              return NULL;
    166            }
    167            CATCH(2){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    168              FR_delete(frame);
    169              return NULL;
    170            }
    171            ETRY;
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    172            return frame;
    173          }
    174          
    175          static bool send_sync(void){
    176            struct sync sync;
    177            sync.sys_ch = MODEL.SYNC.sys_channel;
    178            sync.tx_power = MODEL.RADIO.power_tx;
    179            sync.panid = MODEL.SYNC.panid;
    180            sync.rtc = MODEL.RTC.rtc;
    181            sync.magic = MAGIC;
    182            
    183            struct frame *fr = FR_create();
    184            ASSERT(fr);
    185            FR_add_header(fr, &sync, sizeof(struct sync));
    186            
    187            fr->meta.SEND_TIME = (nwtime_t)SYNC_TIME;
    188            AES_StreamCoder(true, fr->payload, fr->payload, fr->len);
    189            
    190            bool set_ch_res = RI_SetChannel(MODEL.SYNC.sync_channel);
    191            ASSERT(set_ch_res);
    192            bool res = RI_Send(fr);
    193            FR_delete(fr);
    194            LOG_ON("SYNC sended, res = %d", res);
    195            return res;
    196          }
    197          
    198          static struct frame* network_recv_sync(ustime_t timeout){
    199            if(!RI_SetChannel(MODEL.SYNC.sync_channel))
    200              HALT(FLASH_STR("Wrong channel"));
    201            
    202            struct frame *frame = NULL;
    203            TRY{
    204              frame = RI_Receive(timeout);
    205              if (!frame)
    206                THROW(1);
    207              if (frame->len != sizeof(struct sync))
    208                THROW(2);
    209              AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
    210              return frame;
    211            }
    212            CATCH(1){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    213              return NULL;
    214            }
    215            CATCH(2){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    216              FR_delete(frame);
    217              return NULL;
    218            }
    219            ETRY;
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    220            return frame;
    221          }
    222          
    223          bool network_sync(ustime_t timeout){  
    224            stamp_t now = UST_now();
    225            struct frame *frame;
    226            struct sync *sync;
    227            
    228            TRY{
    229              while(true){
    230                if(UST_time_over(now, timeout))
    231                   THROW(1);
    232                
    233                frame = network_recv_sync(timeout);
    234                if (!frame)
    235                   continue;
    236                
    237                sync = (struct sync*)frame->payload;
    238                if (sync->magic != MAGIC){
    239                  FR_delete(frame);
    240                  continue;
    241                }
    242               
    243                syncronize_timer(frame);
    244                
    245                MODEL.SYNC.synced = true;
    246                MODEL.SYNC.sys_channel = sync->sys_ch;
    247                MODEL.SYNC.panid = sync->panid;
    248                MODEL.RADIO.power_tx = sync->tx_power;
    249                MODEL.RTC.rtc = sync->rtc;
    250                
    251                retransmite = RETRANSMITE_TRY;
    252                MODEL.SYNC.next_time_recv = MODEL.RTC.uptime +  SEND_PERIOD ;
    253                MODEL.SYNC.last_time_recv = MODEL.RTC.uptime;     
    254                break;
    255              }
    256            }
    257            CATCH(1){
    258              FR_delete(frame);
    259              return false; // timeout
    260            }
    261            FINALLY{
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"

  static void SW_Init(void){
              ^
"E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c",34  Warning[Pe177]: function
          "SW_Init" was declared but never referenced
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c"

  static unsigned long LAST_TIME_CARD_RECIEVED;
                       ^
"E:\Neocore\Hardware\PRG Node\neigh.c",36  Warning[Pe550]: variable
          "LAST_TIME_CARD_RECIEVED" was set but never used
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"

  static struct route_record ROUTE_TABLE[ROUTE_TABLE_ITEMS];
                             ^
"E:\Neocore\Hardware\PRG Node\route.c",18  Warning[Pe177]: variable
          "ROUTE_TABLE" was declared but never referenced
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\route.c"
    262              FR_delete(frame);
    263            }
    264            ETRY;
    265            return true;  
    266          }
E:\Neocore\Hardware\STACK_CORE_SRC\time_manager.c
      1          #include "time_manager.h"
      2          #include "model.h"
      3          #include "action_manager.h"
      4          #include "debug.h"
      5          #include "cpu.h"
      6          #include "macros.h"
      7          
      8          /**
      9          @file
     10          */
     11          
     12          #define MAX_TIME_SLOTS 50
     13          
     14          #define ACTIVE_INTERVAL (nwtime_t)327 // 9.979 мс
     15          #define SLEEP_INTERVAL (nwtime_t)327  // 9.979 мс
     16          #define UNACCOUNTED 68 // Остаток времени после 50ого интервала.
     17          #define FULL_INTERVAL (ACTIVE_INTERVAL + SLEEP_INTERVAL)
     18          #define SLOT_TO_NWTIME(slot) ((nwtime_t)((slot) * FULL_INTERVAL)) 
     19          #define NWTIME_TO_SLOT(nwtime) ((timeslot_t)((time)/FULL_INTERVAL))
     20           
     21          //!< Список задач менеджера. Индекс - номер слота, значение-действие
     22          static char ALARMS[MAX_TIME_SLOTS];
     23          
     24          
     25          void TM_SetAlarm(timeslot_t slot, char alarm){
     26            ASSERT(slot < MAX_TIME_SLOTS);
     27            ALARMS[slot] |= alarm;
     28          }
     29          
     30          void TM_ClrAlarm(timeslot_t slot, char alarm){
     31            ASSERT(slot < MAX_TIME_SLOTS);
     32            ALARMS[slot] &= ~alarm;
     33          }
     34          
     35          static inline timeslot_t _inc_timeslot(timeslot_t slot){
     36            slot++;
     37            return (slot >= MAX_TIME_SLOTS) ? 0 : slot;
     38          }
     39          
     40          static inline timeslot_t _find_next_active(timeslot_t slot){
     41            slot = _inc_timeslot(slot);
     42            while (slot && !ALARMS[slot])
     43              slot = _inc_timeslot(slot);
     44            return slot;
     45          }
     46          
     47          static void scheulder_next_alarm(nwtime_t time){
     48            timeslot_t slot = NWTIME_TO_SLOT(time);
     49            slot = _find_next_active(slot);
     50            AT_set_alarm(SLOT_TO_NWTIME(slot));
     51          }
     52          
     53          void TM_IRQ(nwtime_t time){
     54            if (MODEL.TM.MODE == 0){
     55              AT_enable(false);
     56              return;
     57            }
     58            
     59            ATOMIC_BLOCK_RESTORE{     
     60              MODEL.TM.timeslot = NWTIME_TO_SLOT(time);
     61              MODEL.TM.time = time;
     62              MODEL.TM.alarm = ALARMS[ MODEL.TM.timeslot];
     63              scheulder_next_alarm(time);
     64              AM_Hot_start();
     65              AM_Cold_start();
     66            };
     67          }
     68          
     69          static inline void mcu_sleep(void){
     70            SLEEPCMD = 2; // Режим PM2
     71            PCON = 1;
     72          }
     73          
     74          static inline void _clr_all(void){
     75            for_each_type(char, ALARMS, i)
     76              *i = 0;
     77          }
     78          
     79          static void init(void){
     80            _clr_all();
     81            scheulder_next_alarm(0);
     82            AT_enable(true);
     83          }
     84          
     85          static void start_mode_1(void){
     86            AM_IRQ_Init();
     87            init();
     88            while (true){
     89              mcu_sleep();
     90              if (MODEL.TM.MODE == 0){
     91                AT_enable(false);
     92                break;
     93              }
     94              
     95              AM_Callback();    
     96            }  
     97          }
     98          
     99          static void start_mode_2(void){
    100            AM_IRQ_Init();
    101            init();
    102          }
    103          
    104          void Neocore_start(void){
    105            switch (MODEL.TM.MODE){
    106            case 0:
    107              return;
    108            case 1:
    109              start_mode_1();
    110              break;
    111            case 2:
    112              start_mode_2();
    113              break;
    114            default: 
    115              HALT(FLASH_STR("Incorrect MODEL.TM.MODE"));
    116            }
    117          }
E:\Neocore\Hardware\STACK_CORE_SRC\ustimer.c
      1          #include "ioCC2530.h"
      2          #include "ustimer.h"
      3          #include "stdint.h"
      4          #include "action_manager.h"
      5          #include "stdbool.h"
      6          
      7          
      8          #define ACCURATE_VAL_US 500 
      9          
     10          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     11          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     12          static uint32_t DELAY_CALIBRATE_TICS; // Калибровка функции задержки
     13          
     14          static void DelayCalibrate(void);
     15          static void HW_Init(void);  
     16          module_s UST_MODULE = {ALIAS(HW_Init)};
     17          
     18          
     19          void HW_Init(void){
     20            // Запускаем таймер, LATCH MODE = 1
     21            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     22            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     23            T2CTRL = (1<<0) | (1<<3); 
     24            // Калибровка функции задержки
     25            DelayCalibrate();
     26          }
     27          
     28          ustime_t UST_now(void){
     29            ustime_t now;
     30            ((char*)&now)[0] = T2M0;
     31            ((char*)&now)[1] = T2M1;
     32            ((char*)&now)[2] = T2MOVF0;
     33            ((char*)&now)[3] = T2MOVF1;
     34            return now;
     35          }
     36          
     37          bool UST_time_over(stamp_t beg, ustime_t wait){
     38            stamp_t now = UST_now(); 
     39            ustime_t delta = UST_interval(beg, now);
     40            return (delta > wait) ?  true:false;
     41          }
     42          
     43          ustime_t UST_interval(stamp_t beg, stamp_t end){
     44            return (end >= beg) ? 
     45              TICKS_TO_US(end - beg) :
     46              TICKS_TO_US(MAC_TIMER_MAX - beg + end);
     47          };
     48          
     49          void UST_delay(ustime_t time){
     50            stamp_t now = UST_now();
     51            stamp_t len = US_TO_TICKS(time);
     52            stamp_t offset = (time > DELAY_CALIBRATE_TICS) ?
     53                              DELAY_CALIBRATE_TICS : 0;
     54            while (UST_now() < (now + len - offset));
     55          }
     56          
     57          
     58          stamp_t _interval(stamp_t beg, stamp_t end){
     59            return (end >= beg) ? 
     60              (end - beg) :
     61              (MAC_TIMER_MAX - beg + end);
     62          };
     63          
     64          /**
     65          @brief Калибровка функции задержки TIM_delay
     66          */
     67          static void DelayCalibrate(void){
     68            DELAY_CALIBRATE_TICS = 0;  
     69            stamp_t start = UST_now();
     70            UST_delay(ACCURATE_VAL_US);
     71            stamp_t end = UST_now();
     72            DELAY_CALIBRATE_TICS = _interval(start, end) -
     73                                    US_TO_TICKS(ACCURATE_VAL_US);
     74          };

Errors: 13
Warnings: 22
