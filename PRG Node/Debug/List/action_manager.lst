###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               10/May/2020  22:05:00
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  code
#    Dptr setup         =  1,16
#                          
#    Source file        =  E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EWA7DB.tmp
#        (E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c -lc
#        "E:\Neocore\Hardware\PRG Node\Debug\List" -o "E:\Neocore\Hardware\PRG
#        Node\Debug\Obj" -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=code --nr_virtual_regs 8 --no_path_in_file_macros -I
#        E:\Neocore\Hardware\Stack_core_src\ -Ol --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_cross_call --mfc
#        E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c
#        "E:\Neocore\Hardware\PRG Node\auth.c" "E:\Neocore\Hardware\PRG
#        Node\auth_eth.c" "E:\Neocore\Hardware\PRG Node\auth_ip.c"
#        "E:\Neocore\Hardware\PRG Node\balancer.c"
#        E:\Neocore\Hardware\STACK_CORE_SRC\coder.c
#        E:\Neocore\Hardware\Stack_core_src\config.c "E:\Neocore\Hardware\PRG
#        Node\controller.c" E:\Neocore\Hardware\Stack_core_src\cpu.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\debug.c
#        E:\Neocore\Hardware\Stack_core_src\dma.c "E:\Neocore\Hardware\PRG
#        Node\ethernet.c" E:\Neocore\Hardware\STACK_CORE_SRC\frame.c
#        "E:\Neocore\Hardware\PRG Node\ip.c"
#        E:\Neocore\Hardware\Stack_core_src\led.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\llc.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\mac.c "E:\Neocore\Hardware\PRG
#        Node\main.c" E:\Neocore\Hardware\STACK_CORE_SRC\mem_slots.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\mem_utils.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\model.c "E:\Neocore\Hardware\PRG
#        Node\neigh.c" E:\Neocore\Hardware\STACK_CORE_SRC\radio.c
#        "E:\Neocore\Hardware\PRG Node\route.c"
#        E:\Neocore\Hardware\Stack_core_src\rtc.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\sync.c "E:\Neocore\Hardware\PRG
#        Node\tcp.c" E:\Neocore\Hardware\STACK_CORE_SRC\time_manager.c
#        "E:\Neocore\Hardware\PRG Node\udp.c"
#        E:\Neocore\Hardware\STACK_CORE_SRC\ustimer.c "E:\Neocore\Hardware\PRG
#        Node\vtimer.c")
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        E:\Neocore\Hardware\PRG Node\Debug\List\action_manager.lst
#    Object file        =  
#        E:\Neocore\Hardware\PRG Node\Debug\Obj\action_manager.r51
#
###############################################################################

E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c
      1          #include "action_manager.h"
      2          #include "modules_list.h"
      3          #include "model.h"
      4          #include "debug.h"
      5          
      6          /**
      7          @file
      8          */
      9          
     10          /* Определения */
     11          #define ITEMS_COUNT(name) (sizeof(name)/sizeof(module_s*))
     12          #define RUNNER(array, fun) {\
     13          for (char i = 0; i < ITEMS_COUNT(array); i++){\
     14              ASSERT(array[i]->fun != NULL);\
     15              array[i]->fun();\
     16              }\
     17          };
     18          
     19          /* Локальные переменные */
     20          static module_s* COLD_MOD[] = COLD_MOD_DEF;
     21          static module_s* HOT_MOD[] = HOT_MOD_DEF;
     22          static module_s* HW_MOD[] = HW_MOD_DEF;
     23          static module_s* SW_MOD[] = SW_MOD_DEF;
     24          static module_s* IRQ_MOD[] = IRQ_MOD_DEF;
     25          
     26          static void (*CALLBACK)(void);
     27          
     28          void AM_set_callback(void (*fn)(void)){
     29            ASSERT(fn);
     30            CALLBACK = fn;
     31          }
     32          
     33          void AM_Callback(void){
     34            ASSERT(CALLBACK);
     35            CALLBACK();
     36          }
     37          
     38          void AM_Cold_start(void){
     39            RUNNER(COLD_MOD, Cold_Start);
     40          }
     41          
     42          void AM_Hot_start(void){
     43            RUNNER(HOT_MOD, Hot_Start);  
     44          }
     45          
     46          void AM_HW_Init(void){
     47            RUNNER(HW_MOD, HW_Init);      
     48          }
     49          
     50          void AM_SW_Init(void){
     51            RUNNER(SW_MOD, SW_Init);
     52          }
     53          
     54          void AM_IRQ_Init(void){
     55            RUNNER(IRQ_MOD, IRQ_Init);
     56          }
     57          
     58          
E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c
      1          #include "alarm_timer.h"
      2          #include "time_manager.h"
      3          #include "action_manager.h"
      4          #include "ioCC2530.h"
      5          #include "stdbool.h"
      6          #include "stdint.h"
      7          #include "debug.h"
      8          #include "cpu.h"
      9          
     10          /**
     11          @file
     12          */
     13          
     14          #define MAX_NWTIME (nwtime_t)32767
     15          
     16          static void HW_Init(void);  
     17          static inline void IRQEnable(bool state);
     18          static uint32_t ReadTimer(void);
     19          static inline bool isIRQEnable(void);
     20          static inline uint32_t calcCompareTime(nwtime_t time);
     21          static void loadTimerCompare(uint32_t ticks);
     22          
     23          module_s AT_MODULE = {ALIAS(HW_Init)};
     24          static nwtime_t TOFFSET; 
     25          static uint32_t COMPARE_TIME; //!< Значение в регистре compare
     26          
     27          
     28          static void HW_Init(void){
     29            TOFFSET = 0;
     30            COMPARE_TIME = 0;
     31            IRQEnable(false);
     32          };
     33          
     34          static void SW_Init(void){
     35            TOFFSET = 0;
     36            COMPARE_TIME = 0;
     37            IRQEnable(false);
     38          }; 
     39          
     40          void AT_enable(bool state){
     41            ATOMIC_BLOCK_RESTORE{
     42              IRQEnable(state);
     43            }
     44          };
     45          
     46          nwtime_t AT_interval(nwtime_t beg, nwtime_t end){
     47            return (beg > end) ? (beg - end) : (MAX_NWTIME - beg + end);
     48          }
     49          
     50          void AT_set_time(nwtime_t time){
     51            ASSERT(time <= MAX_NWTIME);
     52            nwtime_t timer = ReadTimer();
     53            TOFFSET = time - timer;
     54            TOFFSET &= 0x7FFF;
     55            // После установки времени нужно изменить compare time в таймере
     56            // Но только в случаи если прерывание активно
     57            if (isIRQEnable())
     58              AT_set_alarm(COMPARE_TIME);
     59          }
     60          
     61          nwtime_t AT_time(void){
     62            uint32_t val = ReadTimer();
     63            // TOFFSET = NETWORK TIME - TIMER
     64            // NETWORK TIME = TIMER + TOFFSET
     65            val +=TOFFSET;
     66            val &= 0x7FFF; // Приводим значения таймера к 0-32767
     67            return val;
     68          }
     69          
     70          /**
     71          @brief Ждем наступления определенного момента времени
     72          */
     73          void AT_wait(nwtime_t time){
     74            ASSERT(time <= MAX_NWTIME);  
     75            static union 
     76            {
     77              uint32_t val;
     78              uint8_t fild[4];
     79            } val;
     80            val.val = 0;
     81            // TOFFSET = NETWORK TIME - TIMER
     82            // NETWORK TIME = TIMER + TOFFSET
     83            // Ждем синхронизацию таймера после пробуждения
     84            while (!(SLEEPSTA & 0x01));
     85            do{
     86              // Соблюдаем порядок чтения регисторов ST  
     87              val.fild[0] = ST0;
     88              val.fild[1] = ST1;
     89              val.fild[2] = ST2;
     90              val.val +=TOFFSET;
     91              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
     92            } while (val.val < time);
     93          }
     94          
     95          /**
     96          @brief Разрешение прерываний таймера сна
     97          @params[in] state = true - разрешить обработку прерываний
     98          */
     99          static inline void IRQEnable(bool state){
    100            if (state)
    101              STIE = 1;
    102            else
    103              STIE = 0;
    104          }
    105          
    106          /**
    107          @brief Устанавливает время прерывания
    108          @details Время прерывания устанавливается относительно времени сети
    109          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    110          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    111          @params[in] ticks время сети в тиках когда нужно проснуться
    112          */
    113          void AT_set_alarm(nwtime_t alarm){
    114            ASSERT(alarm <= MAX_NWTIME);
    115            COMPARE_TIME = alarm; // Сохраняем установленное значение
    116            uint32_t compare_time = calcCompareTime(alarm);
    117            loadTimerCompare(compare_time);
    118            IRQEnable(true);
    119          }
    120          
    121          /**
    122          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    123          @params[in] time время сети в тикак
    124          */
    125          static inline uint32_t calcCompareTime(nwtime_t time){   
    126              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    127              //NETWORK TIME = TIMER + TOFFSET  
    128              // Приводим такты к тактам таймера
    129              uint16_t ticks_offset = (time - TOFFSET) & 0x7FFF;
    130              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    131              cmp_time |= ticks_offset; // Вычисляем новое время
    132              if (cmp_time <= timer){
    133                cmp_time += 0x8000;
    134                cmp_time &=0xFFFFFF;
    135              }
    136               LOG_OFF("Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    137                    timer, ticks, cmp_time );
    138              return cmp_time;
    139          }
    140          
    141          /**
    142          @brief Возвращает текущее значение таймера
    143          @return Текущие ticks
    144          */
    145          static uint32_t ReadTimer(void){
    146            static union 
    147            {
    148              uint32_t val;
    149              uint8_t fild[4];
    150            } ret_val;
    151            ret_val.val = 0;
    152            // Ждем синхронизацию таймера после пробуждения
    153            while (!(SLEEPSTA & 0x01));
    154            // Соблюдаем порядок чтения регисторов ST  
    155            ret_val.fild[0] = ST0;
    156            ret_val.fild[1] = ST1;
    157            ret_val.fild[2] = ST2;
    158            return ret_val.val;
    159          }
    160          
    161          /**
    162          @brief Устанавливает время пробуждения микроконтролера
    163          @params[in] ticks 24 битное значение времени пробуждения в ticks
    164          */
    165          static void loadTimerCompare(uint32_t ticks){
    166            union 
    167            {
    168              uint32_t val;
    169              uint8_t fild[4];
    170            } value;
    171            value.val = ticks;
    172            // Ждем разрешения на запись нового значения
    173            while (!(STLOAD & 0x01));
    174            // Регистр ST0 должен быть записан в последнию очередь
    175            ST2 = value.fild[2];
    176            ST1 = value.fild[1];
    177            ST0 = value.fild[0];
    178          }
    179          
    180          /**
    181          @brief Проверка активности прерывания таймера
    182          @return true если прерывание установленно
    183          */
    184          static inline bool isIRQEnable(void){
    185            return STIE;
    186          }
    187          
    188          /**
    189          @brief Обработчик прерывания таймера сна
    190          */
    191          #pragma vector=ST_VECTOR
    192          __interrupt void TimerCompareInterrupt(void){ 
    193            nwtime_t time = AT_time();
    194            // Отключаем прерывание таймера. Забота пользователя его включить
    195            IRQEnable(false); 
    196            TM_IRQ(time); // Передаем управление менеджеру времени
    197            STIF = 0; // Очищаем флаг прерывания
    198          }
E:\Neocore\Hardware\PRG Node\auth_eth.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "frame.h"
      4          #include "ethernet.h"
      5          #include "protocol_defs.h"
      6          #include "stdlib.h"
      7          #include "llc.h"
      8          #include "route.h"
      9          #include "mem_utils.h"
     10          
     11          #define REQUEST_INTERVAL 30
     12          #define AUTH_RESP_GW_INTERVAL 5
     13          
     14          static unsigned long last_request = 0;
     15          
     16          static void AUTH_request();
     17          static void receiveCMD_Request(struct frame* frame);
     18          static void receiveCMD_Response(struct frame* frame);
     19          
     20          enum AUTH_ETH_TYPES {AUTH_CMD_REQ = 0, AUTH_CMD_RESP = 1};
     21          
     22          struct AUTH_ETH_REQ{
     23            char mac[8]; // Кто делает запрос
     24            char node_type;
     25            char node_ver;
     26            char sensor_types[7];
     27            char sensor_channels[7];
     28          } __attribute__((packed));
     29          
     30          struct AUTH_ETH_RESP{
     31            char mac[8]; // Для кого предназначен ответ
     32            bool access;
     33            unsigned int ipaddr;
     34            char param[16];
     35          } __attribute__((packed));
     36          
     37          struct auth_req{
     38            bool RA;
     39            struct AUTH_ETH_REQ req;
     40          };
     41          
     42          struct auth_res{
     43            bool RA;
     44            struct AUTH_ETH_RESP res;
     45          };
     46          
     47          // Таблица хранит запросы от других узлов на подключение
     48          #define AUTH_NODE_REQ_SIZE 5
     49          static struct auth_req AUTH_NODE_REQ[5];
     50          
     51          // Таблица хранит ответы шлюза на подключения для других узлов
     52          #define AUTH_NODE_RESP_SIZE 5
     53          static struct auth_res AUTH_NODE_RESP[5];
     54          
     55          void AUTH_ETH_Init(){
     56            MEMSET((char*)AUTH_NODE_RESP, 0, sizeof(AUTH_NODE_RESP));
     57            MEMSET((char*)AUTH_NODE_REQ, 0, sizeof(AUTH_NODE_REQ));
     58          };
     59          
     60          void AUTH_ETH_Receive(struct frame *frame){
     61            LOG_ON("AUTH_ETH receive frame");
     62            
     63            // Всеравно откого получили пакет. в пакет вклчен мак адрес
     64            bool filter_rule = frame->len > 0;  
     65            if (!filter_rule){
     66              LOG_ON("AUTH_ETH frame filltered");
     67              return;
     68            }
     69            
     70            char cmd = frame->payload[0];
     71            bool res = FR_del_header(frame, 1);
     72            ASSERT(res);
     73            
     74            switch(cmd){
     75              case AUTH_CMD_REQ :
     76                // TODO обработка приема
     77                receiveCMD_Request(frame);
     78                break;
     79            case AUTH_CMD_RESP:
     80                // TODO обработка приема 
     81                receiveCMD_Response(frame);
     82                break;
     83            default:
     84              LOG_ON("Unrecognized cmd");
     85              break;
     86            };
     87          };
     88          
     89          /** brief Выбирает и устанавлиет канал коммуникации для узла
     90          *
     91          * Частотный канал  [CH11..CH27] выбор из 17 каналов
     92          * Временой канал [2..39] выбор из 38 временых слотов
     93          */
     94          static void setNodeCHTS(){
     95            char ch = 11 + rand()%17;
     96            char ts = 2 + rand()%38;
     97            MODEL.node_TS = ts;
     98            MODEL.node_CH = ch;
     99            LLC_open_slot(ts, ch);
    100            LOG_ON("Node choose TS=%d, CH=%d", ts, ch);
    101          };
    102          
    103          /** brief Обработка ответа об авторизации
    104          * Ответ принимается если узел еще не авторизован и пакет
    105          * предназначени этому узлу
    106          */
    107          static void receiveCMD_Response(struct frame* frame){
    108            LOG_ON("AUTH_ETH Response");
    109            if (MODEL.AUTH.auth_ok == true)
    110              return;  
    111            
    112            if (frame-> len != sizeof(struct AUTH_ETH_RESP)){
    113              LOG_ON("Frame AUTH_ETH_RESP wrong size");
    114              return;
    115            };
    116            LOG_ON("Extract response");
    117            struct AUTH_ETH_RESP *resp = (struct AUTH_ETH_RESP*)frame->payload;
    118            
    119            // Проверим что пакет для нас. Должны совпадать мак адресса
    120            bool mac_eq = true;
    121            for (char i = 0; i < 8; i++)
    122              if (resp->mac[i] != MODEL.node_mac[i]){
    123                mac_eq = false;
    124                break;
    125              };
    126            
    127            if (!mac_eq){
    128              LOG_ON("AUTH_ETH request filtered by mac");
    129              return;
    130            }
    131            
    132            MODEL.AUTH.auth_ok = true;
    133            // Пакет для нас. Проверим доступ
    134            if (!resp->access){
    135              LOG_ON("Access depricated");
    136              MODEL.AUTH.access_ok = false;
    137              return;
    138            };
    139            
    140            MODEL.AUTH.access_ok = true;
    141            
    142            for (char i = 0; i < 16 ; i++)
    143              MODEL.node_param[i] = resp->param[i];
    144            
    145            MODEL.node_adr = resp->ipaddr;
    146            setNodeCHTS();
    147            LOG_ON("Node auth ok! ipaddr=%d", MODEL.node_adr);
    148          };
    149          
    150          
    151          static bool mac_cmp(char *mac1, char *mac2){
    152            for (char i = 0; i < 8; i++)
    153              if (mac1[i] != mac2[i])
    154                return false;
    155            return true;
    156          };
    157          
    158          /** brief Добавляем в таблицу ответ от шлюза об авторизации узла
    159          * Данные заносятся в таблицу и будут ретранслированы как 
    160          * AUTH_NODE_RESP. 
    161          */
    162          void set_AUTH_NODE_RESP(struct frame* frame){
    163            // Протокол AUTH_IP ничего не знает о структурах запросов,
    164            // он выполняет функцию транспортного уровня. payload
    165            // содержит ответ шлюза
    166            ASSERT(frame);
    167            struct AUTH_ETH_RESP *res = (struct AUTH_ETH_RESP*)frame->payload;
    168            
    169            if (frame->len != sizeof(struct AUTH_ETH_RESP)){
    170              LOG_ON("AUTH_IP resp from gw have wrong size= %d. struct size=%d", frame->len,
    171                     sizeof(struct AUTH_ETH_RESP));
    172              return;
    173            };
    174          
    175            // Проверим что такого ответа еще нет по мак адресу
    176            int idx = -1;
    177            for (int i = 0; i < AUTH_NODE_RESP_SIZE; i++){
    178              // Пропускаем пустые записи
    179              if (!AUTH_NODE_RESP[i].RA)
    180                continue;
    181              
    182              // Если нашли запись с таким же мак адрессом
    183              if (mac_cmp(AUTH_NODE_RESP[i].res.mac, res->mac)){
    184                idx = i;
    185                break;
    186              };
    187            };
    188          
    189            // Не нашли запись. Ищем свободное место
    190            // Записи с таким же мак адресом нету. Найдем свободное место
    191            if (idx < 0){
    192              for (int i = 0; i < AUTH_NODE_RESP_SIZE; i++)
    193                if (!AUTH_NODE_RESP[i].RA){
    194                  idx = i;
    195                  break;
    196                };
    197            };
    198            
    199            if (idx < 0){
    200              LOG_ON("No free space in AUTH_NODE_RESP_SIZE");
    201              return;
    202            };
    203            
    204            // Добавляем запись
    205            MEMCPY((char*)&AUTH_NODE_RESP[idx].res, (char*)res, 
    206                   sizeof(struct AUTH_ETH_RESP));
    207            AUTH_NODE_RESP[idx].RA = true;
    208            
    209            LOG_ON("AUTH RESP from GW add AUTH_NODE_RESP");
    210          };
    211          
    212          /** brief Подготавливает и возвращает кадр с данными запроса
    213          */
    214          struct frame* get_AUTH_NODE_REQ(){
    215            int idx = -1;
    216            // Ищем первую активную запись в таблице
    217            for (int i = 0; i < AUTH_NODE_REQ_SIZE; i++)
    218              if (AUTH_NODE_REQ[i].RA){
    219                idx = i;
    220                break;
    221              };
    222            
    223            // Ничего не нашли
    224            if (idx < 0)
    225              return NULL;
    226          
    227            struct frame *fr = FR_create();
    228            ASSERT(fr);
    229            
    230            //Добавим данные запроса
    231            bool res = FR_add_header(fr, 
    232                       (char*)(&AUTH_NODE_REQ[idx].req),
    233                        sizeof(struct AUTH_ETH_REQ));
    234            ASSERT(res);
    235            
    236            // Освобождаем запись
    237            AUTH_NODE_REQ[idx].RA = false;
    238            return fr;
    239          };
    240          
    241          /** brief Обработка запроса авторизации от соседних узлов
    242          * Запрос обрабатывается если данный узел авторизован  
    243          */
    244          static void receiveCMD_Request(struct frame* frame){
    245            bool condition = MODEL.AUTH.auth_ok && MODEL.AUTH.access_ok &&
    246              MODEL.SYNC.synced && MODEL.NEIGH.comm_node_found;
    247            if (!condition){
    248              LOG_ON("Cant handel auth req");
    249              return;
    250            };
    251            
    252            // Сначала убедимся что этот узел уже не в списке запросов
    253            // проверим mac. Если узел существует то обновим запись о нем
    254            // вдруг что то изменилось
    255            struct AUTH_ETH_REQ *req = (struct AUTH_ETH_REQ*)frame->payload;
    256            
    257            int idx = -1;
    258            for (int i = 0; i < AUTH_NODE_REQ_SIZE; i++){
    259              // Пропускаем пустые записи
    260              if (!AUTH_NODE_REQ[i].RA)
    261                continue;
    262              
    263              // Если нашли запись с таким же мак адрессом
    264              if (mac_cmp(AUTH_NODE_REQ[i].req.mac, req->mac)){
    265                idx = i;
    266                break;
    267              };
    268            };
    269            
    270            // Записи с таким же мак адресом нету. Найдем свободное место
    271            if (idx < 0){
    272              for (int i = 0; i < AUTH_NODE_REQ_SIZE; i++)
    273                if (!AUTH_NODE_REQ[i].RA){
    274                  idx = i;
    275                  break;
    276                };
    277            };
    278            
    279            if (idx < 0){
    280              LOG_ON("No free space in AUTH_NODE_REQ");
    281              return;
    282            };
    283            
    284            // Добавляем запись
    285            AUTH_NODE_REQ[idx].RA = true;
    286            MEMCPY((char*)&AUTH_NODE_REQ[idx].req, (char*)req, 
    287                   sizeof(struct AUTH_ETH_REQ));
    288            char *mac_ptr = AUTH_NODE_REQ[idx].req.mac;
    289            
    290            LOG_ON("AUTH REQ from mac: 0x%2x%2x%2x%2x%2x%2x%2x%2x add AUTH_NODE_REQ",
    291                   mac_ptr[0],mac_ptr[1],mac_ptr[2],mac_ptr[4],mac_ptr[5],mac_ptr[6],
    292                   mac_ptr[7]);
    293          };
    294          
    295          /** brief Передача ответа на авторизацию, полученую от шлюза
    296          * запросившему узлу.
    297          */
    298          static void AUTH_resend_RESP_from_gw(){
    299            static unsigned long int last = 0;
    300            if ((MODEL.RTC.uptime - last) < AUTH_RESP_GW_INTERVAL)
    301              return;
    302            // Обновляем время
    303            last = MODEL.RTC.uptime;
    304            
    305            // Ищем ответ шлюза
    306            int idx = -1;
    307            for (int i = 0; i < AUTH_NODE_RESP_SIZE; i++){
    308              if (AUTH_NODE_RESP[i].RA){
    309                idx = i;
    310                break;
    311              };
    312            };
    313            
    314            // Таблица пуста
    315            if (idx < 0) 
    316              return;
    317            
    318            // Нашли пакет для передачи
    319            // Создаем ответ
    320            struct frame* frame = FR_create();
    321            ASSERT(frame);
    322            
    323            // Добавляем в пакет данные
    324            bool res;
    325            res = FR_add_header(frame, (char*)&AUTH_NODE_RESP[idx].res,
    326                                sizeof(struct AUTH_ETH_RESP));
    327            ASSERT(res);
    328            
    329            // Добавляем в загловок тип ответа
    330            char cmd = AUTH_CMD_RESP;
    331            res = FR_add_header(frame, &cmd, sizeof(cmd));
    332            ASSERT(res);
    333            
    334            // Добавляем параметры передачи
    335            frame->meta.TS = 1;
    336            frame->meta.CH = MODEL.SYNC.sys_channel;
    337            frame->meta.PID = PID_AUTH;  
    338            frame->meta.NSRC = MODEL.node_adr;
    339            frame->meta.NDST = 0xffff;
    340            LOG_ON("Auth ip response from gw sended")
    341            RP_Send(frame);
    342            AUTH_NODE_RESP[idx].RA = false;;
    343          };
    344          
    345          void AUTH_ETH_TimeAlloc(){
    346              // Если узел еще не авторизован, но синхронизирован и 
    347            // найден ближайший сосед для передачи, то отправляем запрос
    348            // авторизации
    349            if (!MODEL.AUTH.auth_ok && MODEL.SYNC.synced &&
    350                MODEL.NEIGH.comm_node_found)   
    351                  AUTH_request();
    352            
    353            // Если мы авторизированы, синхронизированы, есть сосед для
    354            // передачи данных и доступ нам разрешен, то будем ретранслировать
    355            // ответы от шлюза на запросы подключения.
    356            if (MODEL.AUTH.auth_ok && MODEL.SYNC.synced &&
    357                MODEL.NEIGH.comm_node_found && MODEL.AUTH.access_ok)    
    358             AUTH_resend_RESP_from_gw();
    359          };
    360          
    361          static void AUTH_request(){
    362            // Еще не наступло время передачи запроса
    363            if ((MODEL.RTC.uptime - last_request) < REQUEST_INTERVAL)
    364              return;
    365            // Обновляем время
    366            last_request = MODEL.RTC.uptime;
    367            
    368            // Создаем запрос
    369            struct frame* frame = FR_create();
    370            struct AUTH_ETH_REQ req;
    371            for (int i = 0; i < 8; i++)
    372              req.mac[i] = MODEL.node_mac[i];
    373            
    374            req.node_type = NODE_TYPE;
    375            req.node_ver = NODE_VER;
    376          
    377            bool res;
    378            res = FR_add_header(frame, &req, sizeof(struct AUTH_ETH_REQ));
    379            ASSERT(res);
    380            char cmd = AUTH_CMD_REQ;
    381            res = FR_add_header(frame, &cmd, sizeof(cmd));
    382            ASSERT(res);
    383            
    384            frame->meta.PID = PID_AUTH;
    385            LOG_ON("Node authorisation requested");
    386            RP_Send_COMM(frame);
    387          };
E:\Neocore\Hardware\PRG Node\auth_ip.c
      1          #include "tcp.h"
      2          #include "debug.h"
      3          #include "model.h"
      4          #include "auth_eth.h"
      5          #include "frame.h"
      6          #include "ip.h"
      7          #include "protocol_defs.h"
      8          
      9          // Инетрвал отправки запросов авторизации шлюзу в секундах
     10          #define PERIOD_SEND_IP_REQ 5
     11          enum AUTH_IP_TYPES {AUTH_CMD_REQ = 0, AUTH_CMD_RESP = 1};
     12          
     13          void AUTH_IP_Init(){
     14              // Возможно инициализировать нужно таймеры
     15          };
     16          
     17          void AUTH_IP_Recive(struct frame *frame){
     18            // Проверим размер
     19            if (frame->len == 0){
     20              LOG_ON("Wrong size");
     21              return;
     22            };
     23            
     24            // Отрежим команду
     25            bool res = FR_del_header(frame,1);
     26            
     27            // Передадим ответ нижнему уровню. пусть разбирается что к чему
     28            set_AUTH_NODE_RESP(frame);
     29            LOG_ON("AUTH_IP gw resp add to auth_eth");
     30          };
     31          
     32          void AUTH_IP_TimeAlloc(){
     33            // Для работы протокола требуется что бы мы были зарегестрированы в 
     34            // сети
     35            bool flt = MODEL.AUTH.auth_ok && MODEL.SYNC.synced &&
     36                MODEL.NEIGH.comm_node_found && MODEL.AUTH.access_ok;
     37            
     38            if (!flt)
     39              return;
     40            
     41            // Мы должны из протокола AUTH_ETH выбирать принятые запросы
     42            // и переправлять ответы шлюзу. Запросы отправляю с неким периодом
     43            
     44            static unsigned long time = 0;
     45            unsigned long now = MODEL.RTC.uptime;
     46            if (now - time < PERIOD_SEND_IP_REQ)
     47              return;
     48            time = now;
     49            
     50            struct frame* fr = get_AUTH_NODE_REQ();
     51            // Нечего отправлять
     52            if (!fr)
     53              return;
     54            
     55            // Добавим тип запроса
     56            char cmd = AUTH_CMD_REQ;
     57            bool res = FR_add_header(fr, &cmd, sizeof (char));
     58            ASSERT(res);
     59            
     60            fr->meta.IPP = IPP_AUTH;
     61            IP_Send(fr);
     62            LOG_ON("AUTH_IP req send to GW");
     63          };
E:\Neocore\Hardware\PRG Node\balancer.c
      1          #include "model.h"
      2          #include "debug.h"
      3          
      4          void TB_Receive(struct frame *frame){
      5          }
E:\Neocore\Hardware\STACK_CORE_SRC\coder.c
      1          #include "coder.h"
      2          #include "ioCC2530.h"
      3          #include "string.h"
      4          #include "ustimer.h" // Для профилирования, Отладка
      5          #include "dma.h"
      6          #include "action_manager.h"
      7          #include "model.h"
      8          #include "mem_utils.h"
      9          
     10          static void HW_Init(void);
     11          module_s CODER_MODULE = {ALIAS(HW_Init)};
     12          
     13          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     14          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     15          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     16          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     17          
     18          #define BV(n)                   (1 << (n))
     19          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     20          
     21          // Режимы шифрования
     22          #define AES_MODE_CBC            0x00
     23          #define AES_MODE_CFB            0x10
     24          #define AES_MODE_OFB            0x20
     25          #define AES_MODE_CTR            0x30
     26          #define AES_MODE_ECB            0x40
     27          #define AES_MODE_CBCMAC         0x50
     28          
     29          // Операции 
     30          #define AES_ENCRYPT             0x00
     31          #define AES_DECRYPT             0x02
     32          #define AES_LOAD_KEY            0x04
     33          #define AES_LOAD_IV             0x06
     34          
     35          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     36          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     37          
     38          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     39          
     40          
     41          // Приватные функции
     42          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     43                                                 uint8_t f, uint8_t lm);
     44          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     45          
     46          /**
     47          @brief Локальный буфер для работы режима CCM
     48          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     49           16 длина дополнения нулями
     50          */
     51          static uint8_t buf[128+18+16]; 
     52          
     53          
     54          typedef struct //!< Структура блока B0 для режима CCM
     55          {
     56            struct 
     57            {
     58              uint8_t L:3;
     59              uint8_t M:3;
     60              uint8_t A_Data:1;
     61            } flag;
     62            uint16_t nonce[9];
     63            uint8_t L_M[6];
     64          } __attribute__((packed)) B0_s;
     65          
     66          typedef struct //!< Структура блока A0 для режима CCM
     67          {
     68            struct 
     69            {
     70              uint8_t L:3;
     71            } flag;
     72            uint8_t nonce[11];
     73            uint8_t ctr;
     74          } __attribute__((packed)) A0_s;
     75          
     76          
     77          
     78          /**
     79          @brief Иницилизация модуля
     80          @detail Модуль использует DMA каналы 0 и 1
     81          */
     82          void HW_Init(void)
     83          {
     84            char STREAM_KEY[16] = DEFAULT_STREAM_KEY;
     85            char STREAM_IV[16] = DEFAULT_STREAM_IV;
     86            char CCM_KEY[16] = DEFAULT_CCM_KEY;
     87            char CCM_IV[16] = DEFAULT_CCM_IV;
     88            MEMCPY(MODEL.AES.STREAM_KEY, STREAM_KEY, 16);
     89            MEMCPY(MODEL.AES.STREAM_IV, STREAM_IV, 16);
     90            MEMCPY(MODEL.AES.CCM_KEY, CCM_KEY, 16);
     91            MEMCPY(MODEL.AES.CCM_IV, CCM_IV, 16);
     92            
     93            //DMA_AES_s DMA_CH[0]; //!< DMA на запись будет DMA[0]
     94            //DMA_AES_s DMA_CH[1]; //!< DMA на чтение DMA_CH[1]
     95            
     96            ST_DEF(DMA_CH[0], DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
     97            ST_DEF(DMA_CH[0], DSTADDRL, 0xB1); //  
     98            ST_DEF(DMA_CH[0], PRIORITY, 0x00); // Низкий приоритет
     99            ST_DEF(DMA_CH[0], M8, 0x00); // Используем 8 бит для счетика длинны
    100            ST_DEF(DMA_CH[0], IRQMASK, 0x00); // Запрещаем генерировать перывания
    101            ST_DEF(DMA_CH[0], DESTINC, 0x00); // Не увеличиваем адресс назначения
    102            ST_DEF(DMA_CH[0], SRCINC, 0x01); // Увеличиваем адресс источника
    103            ST_DEF(DMA_CH[0], TRIG, ENC_DW); // Тригер по загрузке
    104            ST_DEF(DMA_CH[0], WORDSIZE, 0x00); // Копируем по 1 байту
    105            ST_DEF(DMA_CH[0], TMODE, 0x01); //  Блочное копирование по тригеру
    106            ST_DEF(DMA_CH[0], VLEN, 0x00); //  Количество байт определяет поле LEN  
    107            ST_DEF(DMA_CH[0], LENH, 0x00); 
    108            
    109            ST_DEF(DMA_CH[1], SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    110            ST_DEF(DMA_CH[1], SRCADDRL, 0xB2);  
    111            ST_DEF(DMA_CH[1], PRIORITY, 0x00); // Низкий приоритет
    112            ST_DEF(DMA_CH[1], M8, 0x00); // Используем 8 бит для счетика длинны
    113            ST_DEF(DMA_CH[1], IRQMASK, 0x00); // Запрещаем генерировать перывания
    114            ST_DEF(DMA_CH[1], DESTINC, 0x01); // Увеличиваем адресс назначения
    115            ST_DEF(DMA_CH[1], SRCINC, 0x00); // Не увеличиваем адресс источника
    116            ST_DEF(DMA_CH[1], TRIG, ENC_UP); // Тригер по выгрузке
    117            ST_DEF(DMA_CH[1], WORDSIZE, 0x00); // Копируем по 1 байту
    118            ST_DEF(DMA_CH[1], TMODE, 0x01); //  Блочное копирование по тригеру
    119            ST_DEF(DMA_CH[1], VLEN, 0x00); //  Количество байт определяет поле LEN  
    120            ST_DEF(DMA_CH[1], LENH, 0x00); 
    121          }
    122          
    123          /**
    124          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    125          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    126          @param[in] src Указатель на данные подлежащии шифрованию
    127          @param[in] dst Указтель куда будут помещены зашифрованные данные
    128          @param[in] key Указатье на ключ. 16 байт
    129          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    130          @param[in] len Длинна данных
    131          */
    132          void AES_StreamCoder(bool enc_mode, char *src, char *dst, uint8_t len)
    133          {
    134            // Установим метод кодироваения
    135            AES_SET_MODE(STREAM_ENC_MODE);
    136            uint8_t *key = (uint8_t*)MODEL.AES.STREAM_KEY;  
    137            uint8_t *iv = (uint8_t*)MODEL.AES.STREAM_IV; 
    138            // Загружаем ключ
    139            AES_SET_OPERATION(AES_LOAD_KEY);
    140            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    141            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    142            ST_DEF(DMA_CH[0], LENL, 16);
    143            DMAARM |= 0x01;
    144            while(!AES_RDY());
    145            AES_START();
    146            while (DMAARM&0x01);
    147          
    148            // Загружаем IV
    149            AES_SET_OPERATION(AES_LOAD_IV);
    150            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    151            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    152            ST_DEF(DMA_CH[0], LENL, 16);
    153            DMAARM |= 0x01;
    154            while(!AES_RDY());
    155            AES_START();
    156            while (DMAARM&0x01);
    157          
    158            // Установим необходимую операцию AES
    159            if (enc_mode) 
    160              AES_SET_OPERATION(AES_ENCRYPT)
    161            else 
    162              AES_SET_OPERATION(AES_DECRYPT)
    163            
    164            switch(STREAM_ENC_MODE) 
    165            {
    166            case AES_MODE_ECB: // ECB, CBC не реализованы
    167            case AES_MODE_CBC:
    168              break;
    169            case AES_MODE_CFB:
    170            case AES_MODE_OFB:
    171            case AES_MODE_CTR:
    172              {
    173                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    174                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    175                uint8_t ptr, sub_ptr; // Смещение
    176                char *download, *upload;
    177                
    178                // Для этих типов шифрования длина блоков по 4 байта
    179                ST_DEF(DMA_CH[0], LENL, 4);
    180                ST_DEF(DMA_CH[1], LENL, 4);
    181                
    182                // Шифруем все целые блоки
    183                for (uint8_t block = 0; block < nbrBlocks; block ++)
    184                {
    185                  ptr = 16 * block;
    186                  while(!AES_RDY());
    187                  AES_START();
    188                  for (uint8_t j = 0; j < 4; j++)
    189                  {
    190                    sub_ptr = ptr + 4*j;
    191                    download = &src[sub_ptr];
    192                    upload = &dst[sub_ptr];
    193                    // Указываем адресс DMA откуда читать данные
    194                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    195                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    196                    // Указываем адрес DMA куда записывать данные          
    197                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    198                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    199                    // Активируем DMA
    200                    DMAARM |= 0x03;  
    201                    DMAREQ |= 0x01;
    202                    while (DMAARM&0x03);          
    203                  }
    204                }     
    205                // Шифруем последний блок
    206                uint8_t block_len = len % 16; // Размер последнего блока
    207                
    208                // Завершаем работу если блок пустой
    209                if (!block_len)
    210                  return;
    211                
    212                char padding_block[16]; // Блок заполненый нулями
    213                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    214                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    215                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    216                
    217                while(!AES_RDY());
    218                AES_START();
    219                for (uint8_t j = 0; j < 4; j++)
    220                  {
    221                    sub_ptr = 4*j;
    222                    download = &padding_block[sub_ptr];
    223                    // Указываем адресс DMA откуда читать данные
    224                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    225                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    226                    // Указываем аддрес DMA куда записывать данные          
    227                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    228                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    229                    // Активируем DMA
    230                    DMAARM |= 0x03;  
    231                    DMAREQ |= 0x01;
    232                    while (DMAARM&0x03);
    233                  }
    234                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    235                
    236              } //CASE
    237              
    238              break;
    239            } 
    240          }
    241          
    242          /**
    243          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    244          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    245          @param[in] src Указатель на данные подлежащии шифрованию
    246          @param[in] dst Указтель куда будут помещены зашифрованные данные
    247          @param[in] key Указатье на ключ. 16 байт
    248          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    249          @param[in] len Длинна данных
    250          */
    251          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    252                                   uint8_t *iv, uint8_t len)
    253          {
    254            // Установим метод кодироваения
    255            AES_SET_MODE(AES_MODE_CTR);
    256            
    257            // Загружаем ключ
    258            AES_SET_OPERATION(AES_LOAD_KEY);
    259            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    260            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    261            ST_DEF(DMA_CH[0], LENL, 16);
    262            DMAARM |= 0x01;
    263            while(!AES_RDY());
    264            AES_START();
    265            while (DMAARM&0x01);
    266          
    267            // Загружаем IV
    268            AES_SET_OPERATION(AES_LOAD_IV);
    269            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    270            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    271            ST_DEF(DMA_CH[0], LENL, 16);
    272            DMAARM |= 0x01;
    273            while(!AES_RDY());
    274            AES_START();
    275            while (DMAARM&0x01);
    276          
    277            // Установим необходимую операцию AES
    278            if (enc_mode) 
    279              AES_SET_OPERATION(AES_ENCRYPT)
    280            else 
    281              AES_SET_OPERATION(AES_DECRYPT)
    282            
    283            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    284            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    285            uint8_t ptr, sub_ptr; // Смещение
    286            uint8_t *download, *upload;
    287                
    288            // Для этих типов шифрования длина блоков по 4 байта
    289            ST_DEF(DMA_CH[0], LENL, 4);
    290            ST_DEF(DMA_CH[1], LENL, 4);
    291                
    292            // Шифруем все целые блоки
    293            for (uint8_t block = 0; block < nbrBlocks; block ++)
    294              {
    295                ptr = 16 * block;
    296                while(!AES_RDY());
    297                AES_START();
    298                for (uint8_t j = 0; j < 4; j++)
    299                  {
    300                    sub_ptr = ptr + 4*j;
    301                    download = &src[sub_ptr];
    302                    upload = &dst[sub_ptr];
    303                    // Указываем адресс DMA откуда читать данные
    304                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    305                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    306                    // Указываем адрес DMA куда записывать данные          
    307                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    308                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    309                    // Активируем DMA
    310                    DMAARM |= 0x03;  
    311                    DMAREQ |= 0x01;
    312                    while (DMAARM&0x03);          
    313                  }
    314              }     
    315              // Шифруем последний блок
    316              uint8_t block_len = len % 16; // Размер последнего блока
    317                
    318              // Завершаем работу если блок пустой
    319              if (!block_len)
    320                return;
    321                
    322              uint8_t padding_block[16]; // Блок заполненый нулями
    323              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    324              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    325              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    326              
    327              while(!AES_RDY());
    328              AES_START();
    329              for (uint8_t j = 0; j < 4; j++)
    330                {
    331                  sub_ptr = 4*j;
    332                  download = &padding_block[sub_ptr];
    333                  // Указываем адресс DMA откуда читать данные
    334                  ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    335                  ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    336                  // Указываем аддрес DMA куда записывать данные          
    337                  ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    338                  ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    339                  // Активируем DMA
    340                  DMAARM |= 0x03;  
    341                  DMAREQ |= 0x01;
    342                  while (DMAARM&0x03);
    343                }
    344              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    345          }
    346          
    347          /**
    348          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    349          @param[in] len улинна последовательности для вычисления MAC
    350          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    351          */
    352          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    353          {
    354            uint8_t IV[16];
    355            
    356            // Заполняем вектор нулями
    357            memset(IV, 0x00, sizeof(IV));
    358            
    359            // Установим метод кодироваения
    360            AES_SET_MODE(AES_MODE_CBCMAC);  
    361            
    362            { // Сворачиваем код для улучшения чтения
    363            // Загружаем ключ
    364            AES_SET_OPERATION(AES_LOAD_KEY);
    365            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    366            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    367            ST_DEF(DMA_CH[0], LENL, 16);
    368            DMAARM |= 0x01;
    369            while(!AES_RDY());
    370            AES_START();
    371            while (DMAARM&0x01);
    372          
    373            // Загружаем IV
    374            AES_SET_OPERATION(AES_LOAD_IV);
    375            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(IV));
    376            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(IV));
    377            ST_DEF(DMA_CH[0], LENL, 16);
    378            DMAARM |= 0x01;
    379            while(!AES_RDY());
    380            AES_START();
    381            while (DMAARM&0x01);
    382            };
    383            
    384            // Устанавливаем операцию шифрования
    385            AES_SET_OPERATION(AES_ENCRYPT);
    386            
    387            // Загрузка блоками по 128 бит
    388            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    389            uint8_t block_len = len % 16; // Размер последнего блока
    390            uint8_t ptr; // Смещение
    391                
    392            // Для этого типа шифрования длина блоков по 16 байт
    393            ST_DEF(DMA_CH[0], LENL, 16);
    394            // Устанавливаем куда будем выгружать вычисленный MAC
    395            ST_DEF(DMA_CH[1], DSTADDRL, LADDR(mac));
    396            ST_DEF(DMA_CH[1], DSTADDRH, HADDR(mac));
    397            ST_DEF(DMA_CH[1], LENL, 16);
    398            
    399            // Шифруем все целые блоки
    400            for (uint8_t block = 0; block < nbrBlocks; block ++)
    401              {
    402                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    403                // кратного 16 байтам.
    404                if (!block_len && (block == nbrBlocks - 1))
    405                  AES_SET_MODE(AES_MODE_CBC);
    406                    
    407                ptr = 16 * block;
    408                while(!AES_RDY());
    409                AES_START();
    410                // Указываем адресс DMA откуда читать данные
    411                ST_DEF(DMA_CH[0], SRCADDRL, LADDR(buf[ptr]));
    412                ST_DEF(DMA_CH[0], SRCADDRH, HADDR(buf[ptr]));
    413                // Активируем DMA
    414                DMAARM |= 0x01;  
    415                // Активируем выгрузку только последнего блока
    416                if (!block_len && (block == nbrBlocks - 1))
    417                  DMAARM |= 0x03;
    418                
    419                DMAREQ |= 0x01;
    420                while (DMAARM&0x03);          
    421               }
    422                 
    423            // Шифруем последний блок в режиме CBC
    424            AES_SET_MODE(AES_MODE_CBC);
    425                    
    426            // Завершаем работу если блок пустой
    427            if (!block_len)
    428              return;
    429                
    430            uint8_t padding_block[16]; // Блок заполненый нулями
    431            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    432            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    433            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    434                
    435            while(!AES_RDY());
    436            AES_START();
    437            // Указываем адресс DMA откуда читать данные
    438            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(padding_block));
    439            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(padding_block));
    440            // Активируем DMA и выгрузку MAC
    441            DMAARM |= 0x03;  
    442            DMAREQ |= 0x01;
    443            while (DMAARM&0x03);
    444          }
    445          
    446          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    447                                                 uint8_t f, uint8_t lm)
    448          {
    449            memcpy(buf, nonce,16);
    450            
    451            // Буфер от 0 до 15 байта специальный блок B0
    452            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    453            buf[0]=  0x01;  
    454            // Если есть данные для авторизации установим A_Data 
    455            if (f > 0)
    456              buf[0] |= 0x40;
    457            
    458            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    459            
    460            // Устанавливаем длинну сообщения
    461            buf[14] = 0x00;
    462            buf[15] = c;
    463            
    464            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    465            buf[16]= 0;
    466            buf[17]= f;
    467            
    468            // Копируем данные авторизации в буфер
    469            memcpy(&buf[18], src, f);
    470            
    471            // Смещение на следующий байт после данных авторизации.
    472            // Данные авторизации занимают положение в буфере [18, 18+f]
    473            uint8_t ptr_end= 18 + f;
    474            // Заполняем нулями до границы 16 байт  
    475            while (ptr_end & 0x0f)
    476              buf[ptr_end++] = 0x00;
    477            
    478            // Копируем данные для шифрования в буфер после нулей
    479            memcpy(&buf[ptr_end], &src[f], c);
    480            
    481            // Возвращаем размер данных в буфере
    482            return ptr_end+c;
    483          };
    484          
    485          /**
    486          @brief Шифрует/дешифрует данные с проверкой MIC
    487          @param[in] src Указатель на данные подлежащии шифрованию
    488          @param[in] len Размер данных
    489          @param[in] с Количество байт для шифрования
    490          @param[in] f Количество байт для авторизации
    491          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    492          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    493          @param[in] len Длинна данных
    494          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    495          */
    496          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m, uint8_t *MIC)
    497          {
    498            uint8_t *key = (uint8_t*)MODEL.AES.CCM_KEY;  
    499            uint8_t *nonce = (uint8_t*)MODEL.AES.CCM_IV; 
    500            uint8_t lm = MIC_2_MICLEN(m);
    501            
    502            // Генерируем данные для авторизации
    503            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    504            
    505            uint8_t mac[16]; // Сюда пишем мак
    506            CBCMAC_buf_encrypt(dlen, key, mac);
    507            
    508            // Шифруем MAC
    509            uint8_t CTR_IV[16];
    510            memcpy(CTR_IV, nonce, 16);
    511            CTR_IV[0] = 0x01; // Флаг режима CTR
    512            CTR_IV[15] = 0;   // Значение счетчика
    513            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    514            
    515            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    516            // dlen-c, dlen
    517            uint8_t ds = dlen - c; // Начало данных для шифрования
    518            
    519            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    520            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    521            CTR_IV[15] = 1; // Счетчик CTR
    522            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    523            
    524            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    525            // src[f, f+c] это шифрованные данные.
    526            memcpy(&src[f], &buf[ds], c); 
    527            memcpy(MIC, mac, lm);
    528            
    529            //https://github.com/zhaohengyi/CC2530Example/blob/
    530            //master/source/components/radios/cc2530/hal_rf_security.c
    531          }
    532          
    533          /**
    534          @brief Дешифрует данные с проверкой MIC
    535          @param[in] src Указатель на данные подлежащии шифрованию
    536          @param[in] len Размер данных
    537          @param[in] с Количество байт для шифрования
    538          @param[in] f Количество байт для авторизации
    539          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    540          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    541          @param[in] len Длинна данных
    542          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    543          */
    544          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m, uint8_t *MIC)
    545          {
    546            uint8_t *key = (uint8_t*)MODEL.AES.CCM_KEY;  
    547            uint8_t *nonce = (uint8_t*)MODEL.AES.CCM_IV;  
    548            uint8_t lm = MIC_2_MICLEN(m);
    549            
    550            // Расшифровываем MAC
    551            uint8_t mac[16]; // Расшифрованый мак
    552            uint8_t CTR_IV[16];
    553            memcpy(CTR_IV, nonce, 16);
    554            CTR_IV[0] = 0x01; // Флаг режима CTR
    555            CTR_IV[15] = 0;   // Значение счетчика
    556            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    557            
    558            // Генерируем данные для авторизации
    559            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    560            
    561            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    562            // dlen-c, dlen
    563            uint8_t ds = dlen - c; // Начало данных для дешифрования
    564            
    565            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    566            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    567            CTR_IV[15] = 1; // Счетчик CTR
    568            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    569            
    570            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    571            CBCMAC_buf_encrypt(dlen, key, new_mac);
    572            
    573            // Проверяем что маки совпадают, значит дешифровано верно
    574            bool mac_equal = true;
    575            for (uint8_t i = 0 ; i < lm ; i++)
    576            {
    577              if (mac[i] != new_mac[i])
    578              mac_equal = false;
    579              break;
    580            }
    581            
    582            // Выходим если MACи не совпали  
    583            if (!mac_equal)
    584              return false;
    585            
    586            // Копируем  расшифрованные данные
    587            memcpy(&src[f], &buf[ds], c); 
    588            return true;
    589          }
E:\Neocore\Hardware\Stack_core_src\config.c
      1          #include "stdint.h"
      2          #include "string.h"
      3          #include "stdbool.h"
      4          #include "string.h"
      5          #include "basic.h"
      6          #include "config.h"
      7          
      8          static uint8_t default_key[16] = DEFAULT_KEY;
      9          static uint8_t default_iv[16] = DEFAULT_IV;
     10          database_s CONFIG;
     11          
     12          
     13          void CF_init()
     14          {
     15            // Загрузка данных из различных источников
     16            memcpy(CONFIG.stream_key, default_key, 16); 
     17            memcpy(CONFIG.stream_iv,  default_iv, 16);
     18            CONFIG.node_ver = NODE_VER;
     19            CONFIG.node_type = NODE_TYPE;
     20            CONFIG.sync_channel = DEFAULT_SYNC_CHANNEL;
     21            CONFIG.sys_channel = DEFAULT_SYS_CHANNEL;
     22            CONFIG.tx_power = DEFAULT_TX_POWER;
     23            CONFIG.panid = DEFAULT_PANID;
     24          }
E:\Neocore\Hardware\PRG Node\controller.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "action_manager.h"
      4          #include "ethernet.h"
      5          #include "auth_ip.h"
      6          #include "auth_eth.h"
      7          #include "neigh.h"
      8          #include "route.h"
      9          
     10          static void HP_callback(void);
     11          static void stack_init();
     12          
     13          static void (*userTimeAllocation)(void);
     14          
     15          //HP - high protocol
     16          
     17          void HP_Init(void){
     18            userTimeAllocation = NULL;
     19            AM_HW_Init();
     20            AM_SW_Init();
     21            LOG_ON("Hardware inited");
     22            MODEL.SYNC.mode = 1;
     23            MODEL.TM.MODE = 1;
     24            AM_set_callback(HP_callback);
     25            stack_init();
     26          }
     27          
     28          void setUserTimeAllocation(void (*fn)(void)){
     29            userTimeAllocation = fn;
     30          };
     31          
     32          bool NeocoreReady(){
     33            bool flt = MODEL.AUTH.auth_ok && MODEL.AUTH.access_ok && 
     34                       MODEL.SYNC.synced && MODEL.NEIGH.comm_node_found;
     35            return flt;
     36          };
     37          
     38          
     39          static void stack_init(){
     40            AUTH_IP_Init();
     41            AUTH_ETH_Init();
     42            NP_Init();
     43            RP_Init();
     44            LOG_ON("Neocore stack inited");
     45          };
     46          
     47          void HP_ReInit(){
     48            stack_init();
     49          };
     50          
     51          static void HP_callback(void){
     52            // Обрабатываем стек
     53            ethernet_process();
     54            
     55            // Выделяем пользователю время
     56            if (userTimeAllocation)
     57              userTimeAllocation();
     58          };
     59          
E:\Neocore\Hardware\Stack_core_src\cpu.c
      1          #include "action_manager.h"
      2          #include "ioCC2530.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          static void HW_Init(void);   
      9           
     10          module_s CPU_MODULE = {ALIAS(HW_Init)};
     11          
     12          static void HW_Init(void){
     13            /* Сбрасываем бит OSC32K, будет выбран 32.768 кварц */
     14            CLKCONCMD &= ~(1<<7); 
     15            /* Ждем пока бит не станет 0 */
     16            while (CLKCONSTA & (1<<7)); 
     17            /* Переходим на 32 Мгц */
     18            CLKCONCMD = 0;// (1<<3);
     19            while (CLKCONSTA&(1<<6));
     20            EA = 1;
     21          };  
E:\Neocore\Hardware\STACK_CORE_SRC\debug.c
      1          #include "debug.h"
      2          #include "action_manager.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          static void HW_Init(void);  
      9          static void uart_init(void);
     10           
     11          module_s DBG_MODULE = {ALIAS(HW_Init)};
     12          
     13          static void HW_Init(void){
     14          #ifndef DEBUG
     15            return;
     16          #endif
     17          #ifdef PRINT_TO_TERMINAL  
     18            uart_init();
     19          #endif
     20          #ifdef SIG_DEBUG
     21            P1DIR |=0x01;
     22            P1_0 |= 0x01;  
     23          #endif
     24          };  
     25          
     26          
     27          void DBG_CORE_HALT(void){
     28            while(1);
     29          }
     30          
     31          void DBG_CORE_FAULT(void){
     32            while(1);
     33          }
     34          
     35          // Настройка порта uart для отладки
     36          static void uart_init(void){
     37            // Выбор расположения UART на выводах
     38            char U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     39            PERCFG |= (U0CFG<<0); 
     40            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     41            U0CSR = (1<<7); // Выбираем режим uart  
     42            // Настройка скорости передачи данных на 2М  
     43            U0BAUD = 0;  // табличные значения из pdf
     44            U0GCR =  16;
     45            // Включаем альтернативные функции выводов
     46            P0SEL = (1<<2)|(1<<3);
     47            U0CSR |= (1<<6);
     48          }
     49          
     50          //#ifdef PRINT_TO_TERMINAL 
     51          //#include <yfuns.h>
     52          //_STD_BEGIN
     53          //#pragma module_name = "?__write"
     54          //
     55          __near_func int putchar(int x){
     56            while( U0CSR&(1<<0));
     57            U0DBUF = x;
     58            return x;
     59          }
     60          
E:\Neocore\Hardware\Stack_core_src\dma.c
      1          #include "dma.h"
      2          #include "ioCC2530.h"
      3          #include "action_manager.h"
      4          
      5          static void HW_Init(void);
      6          module_s DMA_MODULE = {ALIAS(HW_Init)};
      7          
      8            
      9          DMA_s DMA_CH[5];
     10          
     11          /**
     12          @brief Настройка DMA каналов.
     13          @detail Согласно документации каналы 1-4 идут последовательно
     14          */
     15          static void HW_Init(void){
     16              // Настроим канал 0 DMA для загрузки данных в AES
     17            uint16_t CONF_ADDR = (uint16_t)&DMA_CH[0];
     18            DMA0CFGH = CONF_ADDR >> 8;
     19            DMA0CFGL = CONF_ADDR & 0xFF;
     20            
     21            // Настроим канал 1 DMA для выгрузки данных из AES
     22            CONF_ADDR = (uint16_t)&DMA_CH[1];
     23            DMA1CFGH = CONF_ADDR >> 8;
     24            DMA1CFGL = CONF_ADDR & 0xFF;
     25          }
E:\Neocore\Hardware\PRG Node\ethernet.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "route.h"
      4          #include "auth_eth.h"
      5          #include "neigh.h"
      6          #include "llc.h"
      7          #include "auth_ip.h"
      8          
      9          #define ETH_LAY_SIZE sizeof(struct ETH_LAY)
     10          
     11          struct ETH_LAY{  
     12            union{
     13              uint8_t value;
     14              struct {
     15                char PID:4;
     16                char UNUSED:1;
     17                char ETH_VER:3;
     18              } bits;
     19            } ETH_T;
     20          
     21            char NETID;
     22            unsigned int NDST;
     23            unsigned int NSRC;
     24            char NSRC_TS;
     25            char NSRC_CH;
     26            char XOR;
     27          } __attribute__((packed));
     28          
     29          static char calc_xor(struct ETH_LAY *eth){
     30            char xor_val = 0x57;
     31            char *ptr = (char*)eth;
     32            
     33            // Ксорим все кроме последнего байта структуы. он XOR
     34            for (int i = 0; i < sizeof(struct ETH_LAY) - 1; i++)
     35              xor_val ^=ptr[i];
     36            
     37            return xor_val;
     38          };
     39          
     40          static bool frame_filter(struct frame *frame){
     41            struct ETH_LAY *eth_header = (struct ETH_LAY*)frame->payload;
     42            
     43            // Фильтр 0: по размеру кадра
     44            if (frame->len < ETH_LAY_SIZE){
     45              LOG_OFF("Filtered ETH_LAY_SIZE");
     46              return false;
     47            }
     48            
     49            // Фильтр 1: по XOR
     50            char xor_val = calc_xor(eth_header);
     51            if (xor_val != eth_header->XOR){
     52              LOG_OFF("Filtered XOR");
     53              return false;
     54            };
     55            
     56            // Фильтр 2: по версии протокола
     57            if (eth_header->ETH_T.bits.ETH_VER != HEADER_ETH_VER){
     58              LOG_OFF("Filtered ETH_VER. %d",eth_header->ETH_T.bits.ETH_VER );
     59              return false;
     60            }
     61          
     62            // Фильтр 3: по идентификатору сети
     63            if (eth_header->NETID!= MODEL.SYNC.panid){
     64              LOG_ON("Filtered panid");
     65              return false;
     66            }
     67            
     68            bool from_gw = (eth_header->NSRC_CH == 0xff) &&
     69                           (eth_header->NSRC_TS == 0xff);
     70            if (!from_gw){
     71              // Фильтр 4: по каналу отправителя
     72              if (eth_header->NSRC_CH  < CH11 || eth_header->NSRC_CH  > CH28){
     73                LOG_ON("Filtered NSRC_CH=%d",eth_header->NSRC_CH);
     74                return false;
     75              }
     76              // Фильтр 5: по таймслоту отправителя
     77              if (eth_header->NSRC_TS  < 1 || eth_header->NSRC_TS  > 49){
     78                LOG_ON("Filtered NSRC_TS=%d",eth_header->NSRC_TS);
     79                return false;
     80              }
     81            };
     82            
     83            // Фильтр 6: по адресу получателю
     84            if (eth_header->NDST != 0xffff )
     85              if (eth_header->NDST != MODEL.node_adr){
     86                LOG_OFF("Filtered node addr");
     87                return false;
     88              }
     89            return true;
     90          }
     91          
     92          static inline void fill_meta_data(struct frame *frame){
     93            // Заполняем метаданные
     94            struct ETH_LAY *eth_header = (struct ETH_LAY*)frame->payload;
     95            frame->meta.NDST = eth_header->NDST;
     96            frame->meta.NSRC = eth_header->NSRC;
     97            frame->meta.PID = eth_header->ETH_T.bits.PID;  
     98            frame->meta.NSRC_TS = eth_header->NSRC_TS;
     99            frame->meta.NSRC_CH = eth_header->NSRC_CH;
    100          }
    101          
    102          static void parse_frame(struct frame *frame){
    103            // Разбор пакета
    104            LOG_OFF("Frame Filter");
    105            if (!frame_filter(frame))
    106              return;
    107            
    108            LOG_OFF("Fill metadata");
    109            fill_meta_data(frame);
    110            LOG_OFF("Delete eth header");
    111            FR_del_header(frame, ETH_LAY_SIZE);
    112            LOG_OFF("Route protocol");
    113            RP_Receive(frame);  
    114          }
    115          
    116          /* brief Обработка принятых пакетов
    117          * Извлекает пакеты из входящего буфера, разбирает заголовок ETH, фильтрует 
    118          * пакет и передает их на обработку  протоколу маршрутизации. 
    119          * После обработки пакет удаляется.
    120          */
    121          void ethernet_process(void){
    122            struct frame* frame = NULL;
    123            frame = FR_find_rx(frame); 
    124            LOG_OFF("Start search rx");
    125            while (frame){
    126              LOG_OFF("Find rx!");
    127              LOG_OFF("ETH. LEN:%d, TS:%d, CH:%d, PID:%d", frame->len,
    128                     frame->meta.TS, frame->meta.CH, frame->meta.PID);
    129              parse_frame(frame);
    130              FR_delete(frame);
    131              frame = FR_find_rx(frame);
    132            };
    133            LOG_OFF("Stop search rx");
    134            
    135            // Выделение свободного времени
    136            AUTH_ETH_TimeAlloc();
    137            NP_TimeAlloc();
    138            RP_TimeAlloc();
    139            AUTH_IP_TimeAlloc();
    140          };
    141          
    142          void eth_send(struct frame *frame){
    143            ASSERT(frame);
    144            struct ETH_LAY eth_header;
    145            eth_header.ETH_T.bits.PID = frame->meta.PID ;
    146            eth_header.ETH_T.bits.ETH_VER =HEADER_ETH_VER;
    147            eth_header.NETID = MODEL.SYNC.panid;
    148            eth_header.NDST = frame->meta.NDST;
    149            eth_header.NSRC = frame->meta.NSRC;
    150            eth_header.NSRC_CH = MODEL.node_CH;
    151            eth_header.NSRC_TS = MODEL.node_TS;
    152            eth_header.XOR = calc_xor(&eth_header);
    153            
    154            bool res;
    155            res = FR_add_header(frame, &eth_header,
    156                                sizeof(struct ETH_LAY));
    157            ASSERT(res);
    158           
    159            frame->meta.tx_attempts = 5;
    160            res = LLC_add_tx_frame(frame); 
    161          };
E:\Neocore\Hardware\STACK_CORE_SRC\frame.c
      1          #include "action_manager.h"
      2          #include "frame.h"
      3          #include "debug.h"
      4          #include "global.h"
      5          #include "mem_utils.h"
      6          #include "mem_slots.h"
      7          
      8          /**
      9          @file Статическое хранение принятых пакетов
     10          */
     11          
     12          static void SW_Init(void); 
     13          
     14          module_s FR_MODULE = {ALIAS(SW_Init)};
     15          
     16          static void SW_Init(void){ 
     17          }; 
     18          
     19          void FR_restart(){
     20            SW_restart();
     21          }
     22          
     23          struct frame* FR_create(){
     24            struct frame *fr  = (struct frame*)SL_alloc();
     25            if (!fr)
     26              return NULL;
     27            MEMSET((char*)&fr->meta, 0, sizeof(struct meta));
     28            fr->len = 0;
     29            return fr;
     30          };
     31          
     32          struct frame* FR_copy(struct frame *frame){
     33            return (struct frame*)SL_copy((char*)frame);
     34          };
     35          
     36          bool FR_delete(struct frame *frame){
     37            return SL_free((char*)frame);
     38          }
     39          
     40          static void mem_move(char *dst, char *src, char len){
     41            for (int i = len - 1; i >= 0; i--)
     42              dst[i] = src[i];
     43          };
     44          
     45          bool FR_add_header(struct frame* frame ,void *head, char len){
     46            int new_len = frame->len + len;
     47            if (!(new_len < MAX_PAYLOAD_SIZE))
     48              return false;
     49            
     50            // Сдвинем данные на размер вставки при необходимости
     51            if (frame->len != 0)
     52              mem_move(&frame->payload[len], frame->payload, frame->len);
     53            
     54            // Скопируем новые данные
     55            MEMCPY(frame->payload, head, len);
     56            frame->len = new_len;
     57            return true;
     58          };
     59          
     60          
     61          bool FR_del_header(struct frame* frame, char len){
     62            if (len == 0 || len > frame->len )
     63              return false;
     64            frame->len = frame->len - len;
     65            MEMCPY(frame->payload, &frame->payload[len], frame->len);
     66            
     67            #ifdef FRAME_FOOTER_DEL
     68            MEMSET(&frame->payload[frame->len], 0, len);
     69            #endif
     70            return true;
     71          }
     72          
     73          void FR_set_rx(struct frame* frame){
     74            SL_set_rx((char*)frame);
     75          }
     76          
     77          void FR_set_tx(struct frame* frame){
     78            SL_set_tx((char*)frame);
     79          }
     80          
     81          bool FR_is_rx(struct frame* frame){
     82            return SL_is_rx((char*)frame);
     83          }
     84          
     85          bool FR_is_tx(struct frame* frame){
     86            return SL_is_tx((char*)frame);
     87          }
     88          
     89          int FR_rx_frames(){
     90            return SL_rx_slots();
     91          };
     92          
     93          int FR_tx_frames(){
     94            return SL_tx_slots();
     95          };
     96          
     97          int FR_busy(){
     98            return SL_busy();
     99          }
    100          
    101          struct frame* FR_find_tx(struct frame* frame){
    102            return (struct frame*)SL_find_tx((char*)frame);  
    103          }
    104          
    105          struct frame* FR_find_rx(struct frame* frame){
    106            return (struct frame*)SL_find_rx((char*)frame);  
    107          }
    108          
    109          int FR_available(){
    110            return SL_available();
    111          };
    112          
    113          int FR_tx_available(){
    114            return SL_tx_available();
    115          };
    116          
    117          int FR_rx_available(){
    118            return SL_rx_available();
    119          };
E:\Neocore\Hardware\PRG Node\ip.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "route.h"
      4          #include "udp.h"
      5          #include "tcp.h"
      6          #include "auth_ip.h"
      7          #include "protocol_defs.h"
      8          
      9          
     10          struct IP_H{
     11            char ETX;
     12            unsigned int FDST;
     13            unsigned int FSRC;
     14            char IPP;
     15          } __attribute__((packed));
     16          
     17          
     18          static bool frame_filter(struct frame *fr){  
     19            if (fr->len < sizeof(struct IP_H)){
     20              LOG_ON("Filtered by size");
     21              return false;
     22            };
     23            return true;
     24          };
     25          
     26          static void fill_meta(struct frame *fr){
     27            struct IP_H *iph = (struct IP_H*)fr->payload;
     28            fr->meta.ETX = iph->ETX;
     29            fr->meta.FDST = iph->FDST;
     30            fr->meta.FSRC = iph->FSRC;
     31            fr->meta.IPP = iph->IPP;
     32          };
     33          
     34          static void IPP_process(struct frame *fr){
     35            switch(fr->meta.IPP){
     36              case IPP_UDP:
     37                LOG_ON("IP is UDP");
     38                UDP_Recive(fr);
     39                break;
     40              case IPP_TCP:
     41                LOG_ON("IP is TCP");
     42                TCP_Recive(fr);
     43                break;    
     44              case IPP_AUTH:
     45                LOG_ON("IP is AUTH");
     46                AUTH_IP_Recive(fr);
     47                break;  
     48              default:
     49              LOG_ON("Unrecognized IPP");
     50            };
     51          };
     52          
     53          void IP_Receive(struct frame *frame){
     54            // Если некоректный пакет 
     55            if (!frame_filter(frame))
     56                return;
     57            
     58            // Заполняем метаданные
     59            fill_meta(frame);
     60            
     61          
     62                          
     63            // Пакет предназначен для шлюза. Его нужно маршрутизировать
     64            // Заголовок пока что отрезать не надо
     65            if(frame->meta.FDST == 0){ 
     66              LOG_ON("Route to GW");
     67              RP_SendRT_GW(frame);
     68              return;
     69            };
     70          
     71            // Пакет для маршрутизации от шлюза к какомуто узлу
     72            // Заголовок отрезать не надо
     73            if (frame->meta.FDST != MODEL.node_adr)
     74              if (frame->meta.FDST != 0xffff)
     75                RP_SendRT_RT(frame);
     76            
     77            // Отрезаем заголовок
     78            FR_del_header(frame, sizeof(struct IP_H));
     79            
     80            // Пакет для нас
     81            if (frame->meta.FDST == MODEL.node_adr || frame->meta.FDST == 0xffff){
     82              LOG_ON("IP frame for node. IPP_process");
     83              IPP_process(frame);
     84              return;
     85            };
     86            
     87          
     88          };
     89          
     90          void IP_Send(struct frame *frame){
     91            struct IP_H iph;
     92            iph.ETX = MODEL.node_ETX;
     93            iph.FDST = 0; // Отправляем шлюзу
     94            iph.FSRC = MODEL.node_adr;
     95            iph.IPP = frame->meta.IPP;
     96               
     97            bool res =FR_add_header(frame, (char*)&iph, sizeof(struct IP_H));
     98            ASSERT(res);
     99            frame->meta.FSRC = MODEL.node_adr;
    100            frame->meta.FDST = 0;
    101            frame->meta.PID = PID_IP;
    102            LOG_ON("IP sended to gw");    
    103            RP_Send_GW(frame);    
    104          };
E:\Neocore\Hardware\Stack_core_src\led.c
      1          #include "action_manager.h"
      2          
      3          static void HW_Init(void);
      4          static void SW_Init(void);
      5          static void Cold_Start(void);
      6          static void Hot_Start(void);
      7          
      8          module_s LED_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
      9            ALIAS(Hot_Start), ALIAS(HW_Init)};
     10          
     11          static void HW_Init(void){};
     12          static void SW_Init(void){};
     13          static void Cold_Start(void){};
     14          static void Hot_Start(void){};
E:\Neocore\Hardware\STACK_CORE_SRC\llc.c
      1          #include "action_manager.h"
      2          #include "stddef.h"
      3          #include "macros.h"
      4          #include "model.h"
      5          #include "debug.h"
      6          #include "radio.h"
      7          #include "mac.h"
      8          
      9          
     10          #define MAX_SLOTS 50
     11          
     12          #define RX_ALARM (1<<0)
     13          #define TX_ALARM (1<<1)
     14          
     15          static void SW_Init(void);
     16          static void Cold_Start(void);
     17          static void Hot_Start(void);
     18          static void IRQ_Init(void);
     19          
     20          module_s LLC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
     21            ALIAS(Hot_Start), ALIAS(IRQ_Init)};
     22          
     23          struct action{
     24            channel_t rx;
     25            struct frame *frame_tx;
     26          };
     27          
     28          static struct action ACTIONSLOTS[MAX_SLOTS];
     29          
     30          static void IRQ_Init(void){
     31            for_each_type(struct action, ACTIONSLOTS, slot){
     32              slot->rx = 0;
     33              slot->frame_tx = NULL;
     34            }
     35          };
     36          
     37          static void SW_Init(void){
     38            for_each_type(struct action, ACTIONSLOTS, slot){
     39              slot->rx = 0;
     40              slot->frame_tx = NULL;
     41            }
     42          };
     43          
     44          void LLC_restart(){
     45            SW_Init();
     46          }
     47          
     48          void LLC_open_slot(timeslot_t ts, channel_t ch){
     49            ASSERT(ts >= 1 && ts < MAX_SLOTS);
     50            ASSERT(ch >= MIN_CH && ch <= MAX_CH);
     51            ACTIONSLOTS[ts].rx = ch;
     52            LOG_ON("Slot open. TS=%d, CH=%d", ts, ch);
     53          }
     54          
     55          void LLC_close_slot(timeslot_t ts){
     56            ASSERT(ts >= 1 && ts < MAX_SLOTS);
     57            ACTIONSLOTS[ts].rx = 0;
     58          }
     59          
     60          bool LLC_add_tx_frame(struct frame *frame){
     61            ASSERT(frame); 
     62            if (FR_tx_available() == 0){
     63              LOG_ON("NO FREE TX FRAME");
     64              FR_delete(frame);
     65              return false;
     66            };  
     67             
     68            AES_StreamCoder(true, frame->payload, frame->payload, frame->len); 
     69            FR_set_tx(frame);
     70            return true;
     71          }
     72          
     73          static void scheduler_tx(void){
     74            struct frame* tx_frame = NULL; 
     75            tx_frame = FR_find_tx(tx_frame);
     76            
     77            if (!tx_frame)
     78              return;
     79            
     80            if (tx_frame->meta.TS==0)
     81              while(1);
     82            
     83            while(tx_frame){
     84              ASSERT(tx_frame->meta.TS != 0);
     85              // Если у нас есть что передавать, берем следующий кадр из буфера
     86              if (ACTIONSLOTS[tx_frame->meta.TS].frame_tx){
     87                tx_frame = FR_find_tx(tx_frame);
     88                continue;
     89              }
     90              ACTIONSLOTS[tx_frame->meta.TS].frame_tx = tx_frame;
     91              TM_SetAlarm(tx_frame->meta.TS, TX_ALARM); 
     92              tx_frame = FR_find_tx(tx_frame);
     93            }
     94          }
     95          
     96          static void scheduler_rx(void){
     97            ASSERT(ACTIONSLOTS[0].rx == 0);
     98            for (char i = 1; i < MAX_SLOTS; i++)
     99              if (ACTIONSLOTS[i].rx)
    100                TM_SetAlarm(i, RX_ALARM);
    101              else
    102                TM_ClrAlarm(i, RX_ALARM);
    103          }
    104          
    105          static void Cold_Start(void){
    106          // Планировщик планирует на один суперфрейм в начале ts0
    107            if (MODEL.TM.timeslot != 0)
    108              return;
    109            
    110            scheduler_tx();
    111            scheduler_rx();
    112          };
    113          
    114          static inline void receive(){
    115            timeslot_t ts = MODEL.TM.timeslot;
    116            MAC_Receive(ACTIONSLOTS[ts].rx);
    117          }
    118          
    119          static void transmite(void){
    120            timeslot_t ts = MODEL.TM.timeslot;
    121            struct frame *frame = ACTIONSLOTS[ts].frame_tx;
    122            
    123            if (!frame)
    124              HALT("Error")
    125            
    126            // Неудачные передачи учитывает MAC_Send()
    127            int send_res = MAC_Send(frame);
    128            switch (send_res) {
    129              case 1: { // удачная передача
    130                TM_ClrAlarm(ts, TX_ALARM);
    131                ACTIONSLOTS[ts].frame_tx = NULL;
    132                LOG_ON("Send success");
    133                break;
    134              }
    135              case 0: { // неудачная передача. ACK не получен или CCA
    136                LOG_ON("CCA/ACK err")
    137                break;
    138              }
    139              case -1: { // Исчерпаны попытки отправки
    140                TM_ClrAlarm(ts, TX_ALARM);
    141                ACTIONSLOTS[ts].frame_tx = NULL;
    142                LOG_ON("Attempts exired");
    143                break;
    144              }
    145              default:
    146                HALT("Error");
    147            };
    148          }
    149          
    150          static void Hot_Start(void){
    151            timeslot_t ts = MODEL.TM.timeslot;
    152            if (ts == 0)
    153              return;
    154            char alarm = MODEL.TM.alarm;
    155            
    156            if (alarm & TX_ALARM)
    157              transmite();
    158            else if (alarm & RX_ALARM)
    159              receive();
    160          };
E:\Neocore\Hardware\STACK_CORE_SRC\mac.c
      1          #include "action_manager.h"
      2          #include "frame.h"
      3          #include "coder.h"
      4          #include "radio.h"
      5          #include "ustimer.h"
      6          #include "debug.h"
      7          #include "model.h"
      8          #include "mem_utils.h"
      9          
     10          #define RECV_TIMEOUT 2500
     11          #define ACK_RECV_TIMEOUT 1500
     12          #define REPEATED_TIMEOUT 5
     13          
     14          //ДЛЯ ОЛАДКИ 
     15          nwtime_t FRAME_END ;
     16          nwtime_t ACK_START ;
     17          
     18          static void SW_Init(void);
     19          static void IRQ_Init(void);
     20          
     21          module_s MAC_MODULE = {ALIAS(SW_Init), ALIAS(IRQ_Init)};
     22          
     23          struct ack{ // Формат структуры пакета ACK
     24            char CRC8;
     25          } __attribute__((packed));
     26          
     27          static void SW_Init(void){};
     28          
     29          
     30          struct frame_repeated{
     31            bool RA;
     32            char NSRC;
     33            char CRC8;
     34            unsigned long update;
     35          } __attribute__((packed));
     36          
     37          #define REPEATED_ITEMS 10
     38          static struct frame_repeated REPEATED[REPEATED_ITEMS];          
     39             
     40          
     41          static void IRQ_Init(void){
     42            MEMSET((char*)&REPEATED, 0, sizeof (REPEATED));
     43          };
     44          
     45          static inline struct frame* _recv_frame(channel_t ch){
     46            if(!RI_SetChannel(ch))
     47              HALT("Wrong channel");
     48            
     49            //UST_delay(400);
     50           // nwtime_t NOW1 = AT_time();
     51            struct frame *frame = RI_Receive(RECV_TIMEOUT); //
     52           // FRAME_END = AT_time(); // ДЛЯ ОТЛАДКИ
     53           // nwtime_t NOW2 = AT_time();
     54            return frame;
     55          }
     56          
     57          static uint8_t xor_calc(struct frame *frame){
     58            uint8_t crc = 0x34; // Начальное значение
     59            uint8_t *val = (uint8_t*)frame->payload;
     60            for (uint8_t i = 0; i < frame->len; i++)
     61              crc ^= val[i];
     62            return crc;
     63          }
     64          
     65          static inline void _send_ack(struct frame *frame){
     66          //nwtime_t T1 = AT_time(); // ДЛЯ ОТЛАДКИ
     67            struct ack ack;
     68            struct frame *ack_frame;
     69            // Создаем подтверждение кадра
     70            ack.CRC8 = xor_calc(frame);
     71            // Создаем кадр для отправки
     72          
     73            ack_frame = FR_create();
     74          
     75            ASSERT(ack_frame);
     76            FR_add_header(ack_frame, &ack, sizeof(struct ack));
     77          //  nwtime_t T2 = AT_time(); // ДЛЯ ОТЛАДКИ
     78          //UST_delay(500);
     79          //ACK_START = AT_time(); // ДЛЯ ОТЛАДКИ
     80            
     81            // ВНИМАНИЕ!
     82            // ВЫЧИЛСЕНИЕ XOR+СОЗДАНИЕ ФРЕЙМА И ДОБАВЛЕНИЕ ACK ЗАНИМАЕТ 0.3мс!
     83            // Так что перед приемом нужно подождать
     84            RI_Send(ack_frame);
     85            LOG_ON("ACK=%d, frame_len=%d, TS_ACK=%d, TS_FRAME=%d", ack.CRC8, frame->len, 
     86                   ack_frame->meta.TIMESTAMP, frame->meta.TIMESTAMP);
     87           // LOG_ON("ACK_S=%d, ACK_P=%d, FR_END=%d, DEL=%d, DEL_CALC=%d",
     88             //      ACK_START, ack_frame->meta.TIMESTAMP,FRAME_END, ACK_START-FRAME_END,
     89               //    T2 - T1 );
     90            FR_delete(ack_frame);  
     91          }
     92          
     93          /**
     94          @brief Проверка является ли пакет повторным
     95          @detail Повторно переданым пакетом является пакет от того же отправителя 
     96          * NDST, с тем же значением xor_calc за время меньше 10 сек. Если xor другой
     97          * то запись обновляем. Можно использовать CRC16
     98          */
     99          static bool is_repeated_frame(struct frame *frame){
    100            char nsrc = frame->meta.NSRC;
    101            char crc8 = xor_calc(frame);
    102            unsigned long now = MODEL.RTC.uptime;
    103            
    104            // Удалим старые записи
    105            for (int i = 0; i < REPEATED_ITEMS; i++){
    106              if (REPEATED[i].RA)
    107                if ((now - REPEATED[i].update) > REPEATED_TIMEOUT)
    108                  REPEATED[i].RA = false;
    109            };
    110            
    111            int idx = -1;
    112            // Ищем запись по nsrc с совпадающим crc8
    113            for (int i = 0; i < REPEATED_ITEMS; i++)
    114              if (REPEATED[i].RA &&
    115                  REPEATED[i].NSRC == nsrc &&
    116                  REPEATED[i].CRC8 == crc8){
    117                      idx = i;
    118                      break;
    119                  };
    120            
    121            // Нашли запись. Значит пакет повторно пришел
    122            // Обновим отмету времени
    123            if (idx >=0){
    124              REPEATED[idx].update = now; 
    125              return true;
    126            }
    127            else{ // Такого пакета еще небыло. нужно добавить
    128              // Ищем пустое место
    129              idx = -1;
    130              for (int i = 0; i < REPEATED_ITEMS; i++)
    131                if (!REPEATED[i].RA){
    132                  idx = i;
    133                  break;
    134                };
    135              
    136              // Не нашли места для нового пакета. Будем считать что он не повторный
    137              if (idx < 0){
    138                LOG_ON("No free space. Not repeated.");
    139                return false;
    140              };
    141              
    142              // Нашли место для пакета
    143              REPEATED[idx].RA = true;
    144              REPEATED[idx].CRC8 = crc8;
    145              REPEATED[idx].update = now;  
    146              return false;
    147            };
    148            
    149          };
    150          
    151          void MAC_Receive(channel_t ch){
    152            // Проверим количество доступных пакетов для хранения принятых данных
    153            // Нельзя принимать данные до нуля свободных мест, так как узел не сможет 
    154            // принять ACK и отправлять sync.
    155           // if (FR_rx_available() == 0){
    156             // LOG_ON("NO FREE RX FRAME");
    157             // return;
    158            //};  
    159            
    160            struct frame *frame = _recv_frame(ch);
    161            if (!frame)
    162              return;
    163            
    164            frame->meta.TS = MODEL.TM.timeslot;
    165            if (MODEL.TM.timeslot > 1) // не системный таймслот требует подтверждения
    166              _send_ack(frame);
    167            
    168            AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
    169            
    170            // Прежде чем переместить пакет в буфер принятых, нужно убедиться что пакет
    171            // не является повторным. Эффект множественной передачи происходит из-за
    172            // плохой доставки ACK. Узел-отправитель не получив ACK будет пытаться еще
    173            // раз передать. 
    174            if (MODEL.TM.timeslot > 1)
    175              if (is_repeated_frame(frame)){
    176                LOG_ON("Repeated frame from NSRC=%d deleted", frame->meta.NSRC);
    177                FR_delete(frame);
    178                return;
    179              };
    180              
    181            FR_set_rx(frame);
    182            LOG_ON("RX frame. TS=%d, CH=%d, RSSI=%d, RX_CNT=%d", 
    183                   frame->meta.TS, frame->meta.CH, frame->meta.RSSI_SIG, FR_rx_frames());
    184            DATA_LOG_OFF((char*)&frame->payload, frame->len);
    185          }
    186          
    187          static inline bool _send_frame(struct frame *frame){
    188            if(!RI_SetChannel(frame->meta.CH)){
    189              int a=5; //DEBUG!!
    190              a++;
    191              if (frame->meta.CH == 0)
    192              HALT("Wrong channel");  
    193            };
    194            
    195            UST_delay(918);
    196            bool tx_success = RI_Send(frame);
    197            return tx_success;
    198          }
    199          
    200          
    201          static inline bool _recv_ack(struct frame *frame){
    202            // Принимаем пакет ACK на той же частоте что и передавали пакет
    203            // Передача ACK требует больше времени чем процедура приема.
    204            // Задержка была найдена эксперементально.
    205            // Я использую 900, но возможно 800 более оптимально будет с учетом
    206            // разбороса параметров узлов
    207            // OK[500-900] NOTGOOD[1000] BAD[1200] 
    208            UST_delay(900); 
    209            struct frame *fr_ack = RI_Receive(ACK_RECV_TIMEOUT);  
    210            if (!fr_ack){
    211              LOG_ON("Frame ack not received");
    212              return false;
    213            };
    214            
    215            // Размер ответа не верен
    216            if (fr_ack->len != sizeof(struct ack)){
    217              LOG_ON("ACK size %d incorrect. Expected %d",
    218                     fr_ack->len, sizeof(struct ack));
    219              FR_delete(fr_ack);
    220              return false;
    221            }
    222            
    223            // Извлекаем структур ответа
    224            struct ack *ack = (struct ack*)fr_ack->payload;
    225            
    226            // Расчитываем CRC8 отправленного пакета
    227            uint8_t CRC8 = xor_calc(frame);
    228            
    229            // Сравним значения
    230            if (ack->CRC8 == CRC8){
    231              LOG_ON("Frame acked");
    232              FR_delete(fr_ack);
    233              return true;
    234            }
    235            else{
    236              LOG_ON("Frame not acked. fr_ack=%d, send_ack=%d",
    237                     ack->CRC8, CRC8);
    238              FR_delete(fr_ack);
    239              return false;
    240            }
    241          }
    242          
    243          int MAC_Send(struct frame *frame){
    244            bool tx_success = _send_frame(frame);
    245            
    246            bool ack_success = false;
    247            if (MODEL.TM.timeslot > 1) // Ждем подтверждения ack для не системных слотов
    248              ack_success = _recv_ack(frame);
    249            else
    250              ack_success = true;
    251            
    252            LOG_ON("Send try: NDST=%d, NSRC=%d, FSRC=%d, FDST=%d",
    253                   frame->meta.NDST, frame->meta.NSRC, 
    254                   frame->meta.FSRC, frame->meta.FDST);
    255            DATA_LOG_OFF((char*)&frame->payload, frame->len);
    256            
    257            if (tx_success && ack_success){ // Удачная передача
    258              FR_delete(frame);
    259              return 1;
    260            }
    261            else{ // неудачная передача
    262              if (frame->meta.tx_attempts > 0)
    263                frame->meta.tx_attempts --;
    264              
    265              if (!frame->meta.tx_attempts){ // кончились попытки передачи
    266                FR_delete(frame);
    267                LOG_ON("TX attempts exied. Frame delete.");
    268                return -1;
    269              }
    270            }
    271            return 0;
    272          }
E:\Neocore\Hardware\PRG Node\main.c
      1          #include "controller.h"
      2          
      3          static void send_ip_frame(){
      4            bool flt = MODEL.AUTH.auth_ok && MODEL.AUTH.access_ok;
      5            if (!flt)
      6              return;
      7            
      8           static unsigned long last_send = 0;
      9           unsigned long now = MODEL.RTC.uptime;
     10           if ((now - last_send) < 30)
     11             return;
     12           last_send = now;
     13           
     14           char data[] = {1,2,3,4,5};
     15           UDP_Send(99, data, sizeof(data));
     16           LOG_ON("UDP SENDED1");
     17          };
     18          
     19          
     20          static void user_time_alloc(void){
     21            // measure_process()
     22            // Запуск измерений. им не нужена авторизация
     23            
     24            // Следующим задачам нужна авторизация и возможность передачи
     25            if (!NeocoreReady())
     26              return;
     27            // statisticAgregate()
     28            // measureAgregate()
     29            // nodeHeathControl() Контролируем стек и параметры.
     30            //
     31            send_ip_frame();
     32          };
     33          
     34          #define ONE_SEC 1000000U
     35          
     36          void main(void){
     37            HP_Init();
     38            setUserTimeAllocation(user_time_alloc);
     39            
     40            while (true){
     41              while (!network_sync(ONE_SEC));
     42              LOG_ON("Network synced");
     43              Neocore_start();
     44              LOG_ON("Network lost sync. Resync");
     45              AM_SW_Init();
     46              HP_Init();
     47            }
     48          };
E:\Neocore\Hardware\STACK_CORE_SRC\mem_slots.c
      1          #include "debug.h"
      2          #include "global.h"
      3          #include "macros.h"
      4          #include "stdbool.h"
      5          #include "action_manager.h"
      6          #include "mem_utils.h"  
      7          #include "cpu.h"
      8          #include "mem_slots.h"
      9          
     10          //!< Максимальный размер данных в одном слоте
     11          #define SLOT_BUFFER_SIZE 150
     12          #define RED_ZONE_CODE 0x73
     13          
     14          #ifndef SLOT_POOL_ITEMS
     15          #define SLOT_POOL_ITEMS 20
     16          #endif
     17          
     18          #ifndef SLOT_TX_ITEMS   
     19          #define SLOT_TX_ITEMS 7
     20          #endif
     21          
     22          #ifndef SLOT_RX_ITEMS   
     23          #define SLOT_RX_ITEMS 7
     24          #endif
     25          
     26          typedef char red_zone_t;
     27          
     28          static void SW_Init(void);
     29          module_s MS_MODULE = {ALIAS(SW_Init)};
     30          
     31          struct property{
     32            char taken: 1;
     33            char RX :1;
     34            char TX :1;
     35          };
     36          
     37          struct slot{
     38            struct property property;
     39            red_zone_t red_zone_1;
     40            char buffer[SLOT_BUFFER_SIZE];
     41            red_zone_t red_zone_2;
     42          };
     43          
     44          //!< Хранилище слотов
     45          static struct slot SLOT_POOL[SLOT_POOL_ITEMS];
     46          //!< Количество занятых слотов
     47          static int slot_busy;
     48          //!< Количество пакетов помеченных на прием
     49          static int slot_rx_cnt;
     50          //!< Количество пакетов помеченных на передачу
     51          static int slot_tx_cnt;
     52          
     53          void SW_Init(void){
     54            slot_busy = 0;
     55            slot_rx_cnt = 0;
     56            slot_tx_cnt = 0;
     57            for_each_type(struct slot, SLOT_POOL, slot){
     58              slot->property.taken = false;
     59              slot->property.RX = false;
     60              slot->property.TX = false;
     61              #ifdef FILL_SLOT_ZERO
     62                MEMSET(slot->buffer, 0, SLOT_BUFFER_SIZE);
     63              #endif    
     64              slot->red_zone_1 = RED_ZONE_CODE;
     65              slot->red_zone_2 = RED_ZONE_CODE;
     66            }
     67          };
     68          
     69          void SW_restart(){
     70            SW_Init();
     71          };
     72          
     73          int SL_rx_slots(){
     74              int cnt=0;
     75              for_each_type(struct slot, SLOT_POOL, slot){
     76                if (slot->property.taken && slot->property.RX)
     77                  cnt++;
     78              }
     79              return cnt;
     80          }
     81          
     82          int SL_tx_slots(){
     83              int cnt=0;
     84              for_each_type(struct slot, SLOT_POOL, slot){
     85                if (slot->property.taken && slot->property.TX)
     86                  cnt++;
     87              }
     88              return cnt;
     89          }
     90          
     91          /**
     92          @brief Возвращает указатель на следующий буфер tx
     93          @param buff. buff = NULL поиск от начала списка или от последнего найденого 
     94           буфера.
     95          */
     96          char* SL_find_tx(char* buff){  
     97            if (!buff){
     98              for_each_type(struct slot, SLOT_POOL, slot){
     99                if (slot->property.taken && slot->property.TX)
    100                  return slot->buffer;
    101              }
    102              return NULL;
    103            }
    104            struct slot *geven_slot = container_of(buff, struct slot, buffer);
    105            geven_slot++;
    106            
    107            while (geven_slot <= &SLOT_POOL[SLOT_POOL_ITEMS]){
    108              if (geven_slot->property.taken && geven_slot->property.TX)
    109                return geven_slot->buffer;
    110              geven_slot++;
    111            }
    112            return NULL;
    113          }
    114          
    115          /**
    116          @brief Возвращает указатель на следующий буфер rx
    117          @param buff. buff = NULL поиск от начала списка или от последнего найденого 
    118           буфера.
    119          */
    120          char* SL_find_rx(char* buff){  
    121            if (!buff){
    122              for_each_type(struct slot, SLOT_POOL, slot){
    123                if (slot->property.taken && slot->property.RX)
    124                  return slot->buffer;
    125              }
    126              return NULL;
    127            }
    128            struct slot *geven_slot = container_of(buff, struct slot, buffer);
    129            geven_slot++;
    130            
    131            while (geven_slot <= &SLOT_POOL[SLOT_POOL_ITEMS]){
    132              if (geven_slot->property.taken && geven_slot->property.RX)
    133                return geven_slot->buffer;
    134              geven_slot++;
    135            }
    136            return NULL;
    137          }
    138          
    139          /**
    140          @brief Возвращает указатель на буфер или NULL. Буфер заполнен 0
    141          @detail 
    142          */
    143          char* SL_alloc(void){  
    144            char *ret_ptr = NULL;
    145            ATOMIC_BLOCK_RESTORE{
    146              for_each_type(struct slot, SLOT_POOL, slot){
    147                if (!slot->property.taken){
    148                  slot->property.taken = true;
    149                  slot->property.RX = false;
    150                  slot->property.TX = false;
    151                  slot_busy++;
    152                  #ifdef FILL_SLOT_ZERO
    153                    MEMSET(slot->buffer, 0, SLOT_BUFFER_SIZE);
    154                  #endif
    155                  ret_ptr = slot->buffer;
    156                  break;
    157                };
    158              };  
    159            };
    160            return ret_ptr;
    161          };
    162          
    163          /**
    164          @brief Копируем слот. 
    165          @details При копировании сбрасываем принадлежность к буферам RX/TX
    166          @ return указатель на новый слот или NULL
    167          */
    168          char* SL_copy(char *buff){
    169            char *ret_ptr = SL_alloc();
    170            if (!ret_ptr)
    171              return NULL;
    172            
    173            ATOMIC_BLOCK_RESTORE{
    174              struct slot *src = container_of(buff, struct slot, buffer);
    175              struct slot *dst = container_of(ret_ptr, struct slot, buffer);
    176              MEMCPY((char*)dst, (char*)src, sizeof(struct slot));
    177              dst->property.RX = false;
    178              dst->property.TX = false;
    179            };
    180          
    181            return ret_ptr;
    182          };
    183          
    184          
    185          static bool _free(char *buff){
    186            struct slot *slot = container_of(buff, struct slot, buffer);
    187              
    188            slot->property.taken = false;
    189            slot->property.RX = false;
    190            slot->property.TX = false;
    191            slot_busy--;
    192            return true;
    193          }
    194          
    195          bool SL_is_tx(char *buff){
    196            struct slot *slot = container_of(buff, struct slot, buffer);
    197            return slot->property.TX;
    198          }
    199          
    200          bool SL_is_rx(char *buff){
    201            struct slot *slot = container_of(buff, struct slot, buffer);
    202            return slot->property.RX;
    203          }
    204          
    205          void SL_set_tx(char *buff){
    206            ATOMIC_BLOCK_RESTORE{
    207              slot_tx_cnt++;
    208              struct slot *slot = container_of(buff, struct slot, buffer);
    209              slot->property.TX = true;
    210            }
    211          }
    212          
    213          void SL_set_rx(char *buff){
    214            ATOMIC_BLOCK_RESTORE{
    215              slot_rx_cnt++;
    216              struct slot *slot = container_of(buff, struct slot, buffer);
    217              slot->property.RX = true;
    218            }
    219          }
    220          
    221          
    222          bool SL_free(char *buff){
    223            bool res;
    224            ATOMIC_BLOCK_RESTORE{
    225              if (SL_is_tx(buff))
    226                slot_tx_cnt--;
    227              else if (SL_is_rx(buff))
    228                slot_rx_cnt--;
    229              
    230              res = _free(buff);
    231            }
    232            return res;
    233          };
    234          
    235          
    236          int SL_busy(){
    237            ASSERT(slot_busy <= SLOT_POOL_ITEMS);
    238            return slot_busy;
    239          };
    240          
    241          int SL_available(){
    242            ASSERT(slot_busy <= SLOT_POOL_ITEMS);  
    243            return SLOT_POOL_ITEMS - slot_busy;
    244          };
    245          
    246          int SL_tx_available(){
    247            ASSERT(slot_tx_cnt <= SLOT_TX_ITEMS);  
    248            return SLOT_TX_ITEMS - slot_tx_cnt;
    249          };
    250          
    251          int SL_rx_available(){
    252            ASSERT(slot_rx_cnt <= SLOT_RX_ITEMS);  
    253            return SLOT_RX_ITEMS - slot_rx_cnt;
    254          };
    255          
    256          int SL_zone_check(){
    257            int index = 0;
    258            for_each_type(struct slot, SLOT_POOL, slot){
    259              if (!(slot->red_zone_1 == RED_ZONE_CODE &&
    260                    slot->red_zone_2 == RED_ZONE_CODE))
    261                return index;
    262              index++;
    263            }
    264            return -1;
    265          };
    266          
E:\Neocore\Hardware\STACK_CORE_SRC\mem_utils.c
      1          #include "mem_utils.h"
      2          #include "debug.h"
      3          
      4          /**
      5          @file Реентерабельное копирование
      6          */
      7          
      8          void MEM_memcpy(struct memcpy *memcpy){
      9            while (memcpy->len > 0){
     10              *memcpy->dst = *memcpy->src;
     11              memcpy->dst++;
     12              memcpy->src++;
     13              memcpy->len--;
     14            }
     15          };
     16          
     17          void MEM_memset(struct memset *memset){
     18            for (char i = 0; i < memset->len; i++)
     19              memset->dst[i] = memset->val;
     20          };
     21          
     22          //void MEM_memset(struct memset *memset){
     23          //  while (memset->len > 0){
     24          //    *memset->dst = memset->val;
     25          //    memset->dst++;
     26          //    memset->len--;
     27          //  }  
     28          //};
     29          
     30          
E:\Neocore\Hardware\STACK_CORE_SRC\model.c
      1          #include "model.h"
      2          #include "action_manager.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          MODEL_s MODEL;
      9          
     10            
     11          static void SW_Init(void); 
     12          
     13          module_s MD_MODULE = {ALIAS(SW_Init)};
     14          
     15           
     16          static void SW_Init(void){
     17            for (int i = 0; i < sizeof(MODEL.PWR_SCAN.energy); i++)
     18              MODEL.PWR_SCAN.energy[i] = -127;
     19            
     20            MODEL.node_adr = 0;
     21            MODEL.node_mac[0] = 0x16; // 11 - первый 12 - второй,13=85,14=86,15=87,16=88,17=89
     22            MODEL.node_mac[1] = 0x22;
     23            MODEL.node_mac[2] = 0x33;
     24            MODEL.node_mac[3] = 0x44;
     25            MODEL.node_mac[4] = 0x55;
     26            MODEL.node_mac[5] = 0xaa;
     27            MODEL.node_mac[6] = 0xee;
     28            MODEL.node_mac[7] = 0xff;
     29            
     30            MODEL.AUTH.auth_ok = false;
     31            MODEL.AUTH.access_ok = false;
     32            
     33            MODEL.NEIGH.comm_node_found = false;
     34            
     35            MODEL.node_TS = 3;
     36            MODEL.node_CH = 14;
     37          }; 
     38          
     39          
E:\Neocore\Hardware\PRG Node\neigh.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "protocol_defs.h"
      4          #include "ethernet.h"
      5          #include "stdlib.h"
      6          #include "mem_utils.h"
      7          
      8          #define NB_ITEMS 10
      9          #define TIME_TO_LIVE 10 // в минутах
     10          #define CARD_SEND_PERIOD 60 // в секундах
     11          #define COMM_NODE_UPDATE_PERIOD 60//в секундах
     12          #define CRIT_WEIGHT 10  // Критический вес узла для смены
     13          #define PERIOD_REQ_TIME 120 // Интервал запроса карточек
     14          
     15          struct gw_vec{
     16            char ts;
     17            char ch;
     18          };
     19          
     20          #define GW_VECTOR_SIZE 10
     21          static const struct gw_vec GW_VECTOR[GW_VECTOR_SIZE] = {
     22            {49, CH11}, {48, CH13}, {47, CH15}, {46, CH17}, {45, CH19},
     23            {44, CH20}, {43, CH21}, {42, CH22}, {41, CH23}, {40, CH25}
     24          };
     25          
     26          struct np_record {
     27            char LIVE_TIME; //Время в минутах
     28            bool RA;
     29            signed char RSSI_SIG;
     30            char LIQ;
     31            char TS_SLOT;
     32            char CH_SLOT;
     33            char ETX;
     34            unsigned int ADDR;
     35          };
     36          
     37          struct NP_CARD{
     38            char TS;
     39            char CH;
     40            char ETX;
     41          } __attribute__((packed));
     42          
     43          enum {NP_CMD_CARD = 0, NP_CMD_CARD_REQ = 1} NP_CMD_ENUM;
     44          
     45          static struct np_record NB_TABLE[NB_ITEMS];
     46          // Указатель на лучший узел для связи
     47          static struct np_record *COMM_NODE_PTR = NULL;
     48          // Время последнего обновления указателя
     49          static unsigned long LAST_UPDATE_TIME_COMM_NODE = 0;
     50          
     51          
     52          void NP_Init(){
     53            // Очистим таблицу соседей
     54            MEMSET((char*)NB_TABLE, 0, sizeof(NB_TABLE));
     55            COMM_NODE_PTR = NULL;
     56            LAST_UPDATE_TIME_COMM_NODE = 0;
     57            MODEL.NEIGH.comm_node_found = false;
     58          };
     59          
     60          /** brief Возращает информацио об узле связи с шлюзом
     61          */
     62          bool comm_node_info(unsigned int *addr, char *ts, char *ch){
     63            if (!COMM_NODE_PTR)
     64              return false;
     65            
     66            // Если узлом связи является шлюз, то у него другой алгоритм выбора TS и CH
     67            if (COMM_NODE_PTR->ADDR == 0){
     68              char idx = rand()%GW_VECTOR_SIZE;
     69              *addr = 0;
     70              *ts = GW_VECTOR[idx].ts;
     71              *ch = GW_VECTOR[idx].ch;
     72              return true;
     73            };
     74            
     75            *addr = COMM_NODE_PTR->ADDR;
     76            *ts = COMM_NODE_PTR->TS_SLOT;
     77            *ch = COMM_NODE_PTR->CH_SLOT;
     78            return true;
     79          };
     80          
     81          /** brief Отправим карточку узла
     82          */
     83          static void send_node_card(){
     84            // Мы не может послать карту так как не знаем свой ETX
     85            LOG_ON("Send node card");
     86            if (!COMM_NODE_PTR)
     87              return;
     88              
     89            struct NP_CARD card;
     90            card.TS = MODEL.node_TS;
     91            card.CH = MODEL.node_CH;
     92            card.ETX = MODEL.node_ETX;
     93            
     94            struct frame *fr = FR_create();
     95            bool res =FR_add_header(fr, (char*)&card, sizeof(struct NP_CARD));
     96            char cmd = NP_CMD_CARD;
     97            res = FR_add_header(fr, &cmd, sizeof(cmd));
     98            
     99            fr->meta.TS = 1;
    100            fr->meta.CH = MODEL.SYNC.sys_channel;
    101            fr->meta.NDST = 0xffff;
    102            fr->meta.NSRC = MODEL.node_adr;
    103            fr->meta.PID = PID_NP;
    104            eth_send(fr);
    105            LOG_ON("Card sended");
    106          };
    107          
    108          static int index_by_addr(unsigned int addr){
    109            int ret = -1;
    110            for (int  i = 0; i < NB_ITEMS; i++)
    111              if (NB_TABLE[i].RA && NB_TABLE[i].ADDR == addr){
    112                ret = i;
    113                break;
    114              };
    115            return ret;
    116          };
    117          
    118          static int free_index(){
    119            int ret = -1;
    120            for (int  i = 0; i < NB_ITEMS; i++)
    121              if (!NB_TABLE[i].RA){
    122                ret = i;
    123                break;
    124              };
    125            return ret;
    126          };
    127          
    128          /** brief Добавим или обновим карточку в таблице
    129          * Уничтожения худших карт не происходит
    130          * Добавляются соседи с RSSI >= -90
    131          */
    132          static void add_card(struct frame *frame){
    133            LOG_ON("Add card");
    134            if (frame->len != sizeof(struct NP_CARD))
    135              return;
    136            
    137            if (frame->meta.RSSI_SIG < -90){
    138              LOG_ON("Bad frame rssi=%d", frame->meta.RSSI_SIG);
    139                return;
    140            };
    141          
    142            
    143            struct NP_CARD *card = (struct NP_CARD*)frame->payload;
    144            // Проверим присланные параметры
    145            bool filter = true;
    146            filter &= card->TS >= 2 && card->TS <= 49;
    147            filter &= card->CH >=CH11 && card->CH <= CH27;
    148            filter &= card->ETX < 250;
    149            if (!filter){
    150              LOG_ON("Card filtered.exit");
    151              return;
    152            }
    153            
    154            int idx;
    155            
    156            // Ищем запись по адресу или свободный индекс
    157            idx = index_by_addr(frame->meta.NSRC);
    158            if (idx >= 0){
    159              LOG_ON("Card found by addr. idx = %d", idx);
    160            };
    161            
    162            if (idx < 0){
    163              idx = free_index();
    164              if (idx >=0 ){
    165                LOG_ON("Card found by free index %d",idx);
    166              };
    167            };
    168           
    169            // Не получиться вставить запись
    170            if (idx < 0){
    171              LOG_ON("Add card exit. no free index");
    172              return;
    173            }
    174            
    175            // Обнавляем таблицу
    176            NB_TABLE[idx].LIVE_TIME = TIME_TO_LIVE;
    177            NB_TABLE[idx].ADDR = frame->meta.NSRC;
    178            NB_TABLE[idx].RA = true;
    179            NB_TABLE[idx].RSSI_SIG = frame->meta.RSSI_SIG;
    180            NB_TABLE[idx].LIQ = frame->meta.LIQ;
    181            NB_TABLE[idx].TS_SLOT = card->TS;
    182            NB_TABLE[idx].CH_SLOT = card->CH;
    183            NB_TABLE[idx].ETX = card->ETX;
    184            
    185            LOG_ON("Card added! ADDR=%d, RSSI=%d, ETX=%d", 
    186                   NB_TABLE[idx].ADDR,NB_TABLE[idx].RSSI_SIG, NB_TABLE[idx].ETX);
    187          };
    188          
    189          void NP_Receive(struct frame *frame){
    190            LOG_ON("NP Receive");
    191            // Если ущел не синхронизирован выходим
    192            if (!MODEL.SYNC.synced){
    193              LOG_ON("Node unsinced exit");
    194              return;
    195            }
    196            
    197            // Если нам отказали в доступе
    198            if (MODEL.AUTH.auth_ok && !MODEL.AUTH.access_ok){
    199              LOG_ON("Access depricated");
    200              return;
    201            }
    202            
    203            if (frame->len == 0){
    204              LOG_ON("Wrong size");
    205              return;
    206            }
    207            
    208            // Извлечем номер команды
    209            char cmd = frame->payload[0];
    210            bool res = FR_del_header(frame, 1);
    211            ASSERT(res);
    212            
    213            bool all_ok = MODEL.AUTH.auth_ok && MODEL.AUTH.access_ok;
    214            switch (cmd){
    215              case NP_CMD_CARD:
    216                add_card(frame);
    217                return;
    218              case NP_CMD_CARD_REQ:
    219                if (!all_ok)
    220                  return;
    221                send_node_card();
    222                break;
    223              default:
    224              LOG_ON("Invalid NP_CMD");
    225            };
    226          }
    227          
    228          /** brief Периодическа рассылка карты узла
    229          */
    230          static void periodic_card_send(){
    231            static unsigned long last_card_send_time = 0;
    232            unsigned long now = MODEL.RTC.uptime;
    233            
    234            // Ждем что пройдем как завершения периода рассылки
    235            if ((now - last_card_send_time) < CARD_SEND_PERIOD)
    236              return;
    237            
    238            LOG_ON("Periodic send");
    239            last_card_send_time = now;
    240            send_node_card();
    241          };
    242          
    243          /** brief Анализ таблицы и уменьшении времени жизни записи
    244          * TODO выбрасывать плохих соседей с высоким ETX
    245          */
    246          static void analyse_table(){
    247            static unsigned long last_analyse_time = 0;
    248            unsigned long now = MODEL.RTC.uptime;
    249            
    250            // Ждем что пройдем как минимум 1 минута с последнего анализа
    251            if ((now - last_analyse_time) < 60)
    252              return;
    253            
    254            last_analyse_time = now;
    255            
    256            LOG_ON("Analyse NP table");
    257            
    258            // Теперь уменьшим время жизни записям и удалим при необходимости
    259            for (int  i = 0; i < NB_ITEMS; i++){
    260              // Пропускаем пустые записи
    261              if (!NB_TABLE[i].RA)
    262                continue;
    263              
    264              // Уменьшаем время жизни
    265              if (NB_TABLE[i].LIVE_TIME > 0)
    266                NB_TABLE[i].LIVE_TIME--;
    267              
    268              // Помечаем запись свободной по истечению времени жизни
    269              if (NB_TABLE[i].LIVE_TIME == 0){
    270                LOG_ON("Record NODE: %d deleted", NB_TABLE[i].ADDR);
    271                NB_TABLE[i].RA = false;    
    272              }
    273            };
    274          };
    275          
    276          /** brief Поиск узла с минимальным ETX(приоритет) и максимальным RSSI
    277          * 
    278          */
    279          static int find_node(){
    280            int idx = -1;
    281            signed char rssi = -90;
    282            char etx = 255;
    283            
    284            for (int  i = 0; i < NB_ITEMS; i++){
    285              // Пропускаем пустые записи
    286              if (!NB_TABLE[i].RA)
    287                continue;
    288            
    289              // Если ETX ниже то беззоговорочно выбираем этот узел
    290              if (NB_TABLE[i].ETX < etx){
    291                rssi = NB_TABLE[i].RSSI_SIG;
    292                etx = NB_TABLE[i].ETX;
    293                idx = i;
    294              };
    295              
    296              // Среди соседий с низким ETX выбираем того у кого лучше сигнал
    297              if (NB_TABLE[i].ETX == etx)
    298                if (NB_TABLE[i].RSSI_SIG > rssi){
    299                  rssi = NB_TABLE[i].RSSI_SIG;
    300                  etx = NB_TABLE[i].ETX;
    301                  idx = i;
    302                };
    303            };
    304            
    305            // Раскажем что мы нашли
    306            if (idx >= 0)
    307              LOG_ON("Find: idx=%d, addr=%d, rssi=%d, etx=%d",
    308                     idx, NB_TABLE[idx].ADDR, NB_TABLE[idx].RSSI_SIG,
    309                     NB_TABLE[idx].ETX);
    310              
    311            return idx;
    312          };
    313          
    314          /** brief Выбираем и следим за указателем на узел связи с шлюзом
    315          */
    316          static void comm_node_choise(){
    317            unsigned long now = MODEL.RTC.uptime;
    318            
    319            // Проверим активна запись на которую указывает
    320            if (COMM_NODE_PTR)
    321              if (!COMM_NODE_PTR->RA){
    322                LOG_ON("COMM_NODE_PTR no active. reset to null");
    323                COMM_NODE_PTR = NULL;
    324                MODEL.NEIGH.comm_node_found = false;
    325              }
    326            
    327            // Если узел уже выбран, то обнавляем с некоторым периодом
    328            if (COMM_NODE_PTR){ 
    329              if ((now - LAST_UPDATE_TIME_COMM_NODE) < COMM_NODE_UPDATE_PERIOD)
    330                return;
    331              LAST_UPDATE_TIME_COMM_NODE = now;
    332            };
    333            
    334            
    335            // Есть ли у нас хоть один сосед
    336            bool table_free = true;
    337            for (int  i = 0; i < NB_ITEMS; i++)
    338              if (NB_TABLE[i].RA){
    339                table_free = false;
    340                break;
    341              };
    342           
    343            // Заканчиваем работу если соседей нет
    344            if (table_free){
    345              LOG_OFF("Dont have neig. exit");
    346              return;
    347            }
    348            
    349            // Начинаем выбирать соседей для связи
    350            int idx = find_node();
    351            if (idx < 0){
    352              LOG_ON("Imposible");  
    353              return; // Этого быть не должно
    354            };
    355            
    356            // Нашли тот же самый узел
    357            // Нужно перерасчитать ETX так как найденый узел мог обновить свой маршут
    358            if (COMM_NODE_PTR == &NB_TABLE[idx]){
    359              LAST_UPDATE_TIME_COMM_NODE = now;
    360              MODEL.node_ETX = COMM_NODE_PTR->ETX + 1;  
    361              LOG_ON("Unchanged IDX=%d. PTR=%d, ADDR", idx, &NB_TABLE[idx], NB_TABLE[idx].ADDR);
    362              return;
    363            };
    364            
    365            // Меняем узел
    366            COMM_NODE_PTR = &NB_TABLE[idx];
    367            LAST_UPDATE_TIME_COMM_NODE = now;
    368            MODEL.node_ETX = COMM_NODE_PTR->ETX + 1;  
    369            MODEL.NEIGH.comm_node_found = true;
    370            LOG_ON("Change. Find IDX=%d. PTR=%d, ADDR", idx, &NB_TABLE[idx], NB_TABLE[idx].ADDR);    
    371          };
    372          
    373          static bool is_free(){
    374            for (int  i = 0; i < NB_ITEMS; i++)
    375              if (NB_TABLE[i].RA)
    376                return false;
    377              return true;
    378          };
    379          
    380          
    381          static void request_cards(){
    382            // Запрашиваем карты если их нет совсем
    383            // Мы не может послать карту так как не знаем свой ETX 
    384            if (!is_free()){
    385              LOG_OFF("Table not free.exit");
    386              return;
    387            }
    388          
    389            LOG_OFF("Start request card");
    390            
    391            static unsigned long last_card_req_time = 0;
    392            unsigned long now = MODEL.RTC.uptime;
    393            
    394            // Проверим что прошло достаточно времени
    395            if ((now - last_card_req_time) < PERIOD_REQ_TIME)
    396              return;
    397            
    398            last_card_req_time = now;
    399            
    400            LOG_ON("REQUEST NP CARD");
    401            
    402            struct frame *fr = FR_create();
    403            ASSERT(fr);
    404            char cmd = NP_CMD_CARD_REQ;
    405            bool res =FR_add_header(fr, &cmd, sizeof(cmd));
    406            ASSERT(res);
    407            
    408            fr->meta.NDST = 0xffff;
    409            fr->meta.NSRC = MODEL.node_adr;
    410            fr->meta.PID = PID_NP;
    411            eth_send(fr);
    412            LOG_ON("Card requested");
    413          };
    414          
    415          void NP_TimeAlloc(){
    416            // Если узел не синхронизирован выходим
    417            if (!MODEL.SYNC.synced)
    418              return;
    419            
    420            // Если мы прошли авторизацию и получили доступ
    421            if (MODEL.AUTH.auth_ok && MODEL.AUTH.access_ok){
    422              LOG_OFF("Auth passed access granted");
    423              periodic_card_send();
    424              analyse_table();
    425              request_cards();
    426              comm_node_choise();
    427              return;
    428            }
    429            
    430            // Если мы не прошли процедуру авторизации
    431            if (!MODEL.AUTH.auth_ok){
    432              LOG_OFF("Auth not passed");
    433              analyse_table();
    434              request_cards();
    435              comm_node_choise();
    436              return;
    437            };
    438            
    439            // Если нам отказали в доступе
    440            if (MODEL.AUTH.auth_ok && !MODEL.AUTH.access_ok){
    441              LOG_ON("Auth passed. Access depricated");
    442              return;
    443            }
    444          };
E:\Neocore\Hardware\STACK_CORE_SRC\radio.c
      1          #include "radio.h"
      2          #include "mem_utils.h"
      3          #include "debug.h"
      4          #include "radio_defs.h"
      5          #include "ustimer.h"
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "alarm_timer.h"
      9          #include "model.h"
     10          #include "action_manager.h"
     11          #include "frame.h"
     12          #include "macros.h"
     13          #include "stdlib.h"
     14          
     15          static void HW_Init(void);
     16          static void SW_Init(void);
     17          module_s RADIO_MODULE = {ALIAS(SW_Init), ALIAS(HW_Init)};
     18          
     19          static void random_core_init(void);
     20          static char RXBUFF[128];
     21          
     22          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     23          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     24          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     25          /*!
     26          \details 
     27           Расчет качества связи. Коэффициенты получаются эксперементально.
     28           Есть предположение, что количество ошибок будет пропорционально квадрату
     29           коеффициента корреляции сигнала.
     30           LIQ = 255 передача 1000 пакетов без ошибок CRC
     31           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     32           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     33          */ 
     34          
     35          #define CONST_A (int8_t)0 //!< Коэффициент A
     36          #define CONST_B (int8_t)1 //!< Коэффициент B
     37          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     38          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     39          
     40          #ifdef RADIO_DEBUG
     41            #define WRITE_TIME_DBG(where) (where) = AT_time()
     42            #define WRITE_PARA_DBG(where,val) (where) = (val) 
     43          #else
     44            #define WRITE_TIME_DBG(where) {}
     45            #define WRITE_PARA_DBG(where,val)
     46          #endif
     47          
     48          static void SW_Init(void){
     49            // Настройки поумолчанию
     50            MODEL.RADIO.CRCError = 0;
     51            MODEL.RADIO.CCAReject = 0;
     52            MODEL.RADIO.channel = CH11;
     53            MODEL.RADIO.power_tx = m0x5;
     54            // Пост действия с радио
     55            random_core_init();
     56          }
     57          
     58          static void HW_Init(void){
     59            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
     60            MDMTEST1_u MDM1; // Устанавливаем режим модуляции
     61            MDM1.value = MDMTEST1;
     62            MDM1.bits.MODULATION_MODE = IEEE_MODE;
     63            MDMTEST1 = MDM1.value;   
     64          }
     65          
     66          static inline void setFreq(channel_t ch)
     67          {
     68            ASSERT( (ch >= MIN_CH) && (ch <= MAX_CH));
     69            // Устанавливаем частоту радиопередатчика
     70            FREQCTRL_u FRQ;
     71            FRQ.value = FRQ_CALC(MODEL.RADIO.channel);
     72            FREQCTRL = FRQ.value;  
     73          }
     74          
     75          static inline void pre_config(void){
     76            setFreq(MODEL.RADIO.channel); 
     77            TXPOWER = MODEL.RADIO.power_tx;
     78          }
     79          
     80          bool RI_SetChannel(channel_t channel){
     81            if (!(channel >= MIN_CH) && (channel <= MAX_CH)){
     82              LOG_ON("Channel %d  [CH11..CH28]", channel);
     83              return false;
     84            };
     85            MODEL.RADIO.channel = channel;
     86            return true;
     87          }
     88          
     89          static void LoadTXData(char *src, size_t len){
     90            ISFLUSHTX(); // Очищаем буфер передатчика
     91            RFD = len + 2; // Поле LEN на два байта больше
     92            for (size_t i = 0 ; i < len; i++)
     93              RFD = src[i];
     94            RFD = 0x00; // Добавляем CRC1,2
     95            RFD = 0x00;
     96          };
     97          
     98          static bool SendData(struct frame *fr, nwtime_t time){
     99            LoadTXData(fr->payload, fr->len);
    100            
    101            // Прежде чем включать радио нужно подождать
    102            if (time != 0) 
    103                AT_wait(time - 29);
    104            
    105            ISRXON();
    106            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.isrxon);
    107            RFIRQF1 &= ~RFIRQF1_TXDONE;
    108            RFIRQF0 &= ~RFIRQF0_SFD; 
    109            bool result = true;
    110            while(!RSSISTAT);
    111            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.rssistat);
    112            TRY{
    113              if (time != 0) // Отправка в определеное время
    114                AT_wait(time - 13); 
    115              ISTXONCCA();
    116              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.istxoncca);
    117              if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    118                THROW(1);
    119              // Ждем отправки SFD
    120              while (!(RFIRQF0 & RFIRQF0_SFD));
    121              fr->meta.TIMESTAMP = AT_time();
    122              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.sfd);
    123              // Ждем завершения отправки сообщения
    124              while (!(RFIRQF1 & RFIRQF1_TXDONE));
    125              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.txdone);
    126              
    127            }
    128            CATCH(1){ //SAMPLED_CCA == 0
    129              result = false;
    130            }
    131            FINALLY{
    132              ISRFOFF();
    133            }
    134            ETRY;  
    135            return result;
    136          }
    137          
    138          /*!
    139          \brief Передает данные в эфир
    140          */
    141          bool RI_Send(struct frame *fr){
    142            ASSERT(fr != NULL);
    143            pre_config();
    144            stamp_t start = UST_now();
    145            bool send_res = SendData(fr, 0);
    146            stamp_t stop = UST_now();
    147            //TODO Неверно считает интервал так как при отправке
    148            // sync пакета мы ждем
    149            ustime_t tx_time = UST_interval(start, stop); 
    150            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.fulltime, tx_time);
    151            MODEL.RADIO.UptimeTX += tx_time;
    152            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.ccasampled, send_res);
    153            if (!send_res)
    154              MODEL.RADIO.CCAReject++;
    155            return send_res;
    156          }
    157          
    158          bool RI_Send_time(struct frame *fr, nwtime_t time){
    159            ASSERT(fr != NULL);
    160            pre_config();
    161            //TODO начало start отложено! неверно вычисляем интервал
    162            stamp_t start = UST_now();
    163            bool send_res = SendData(fr, time);
    164            stamp_t stop = UST_now();
    165            //TODO Неверно считает интервал так как при отправке
    166            // sync пакета мы ждем
    167            ustime_t tx_time = UST_interval(start, stop); 
    168            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.fulltime, tx_time);
    169            MODEL.RADIO.UptimeTX += tx_time;
    170            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.ccasampled, send_res);
    171            if (!send_res)
    172              MODEL.RADIO.CCAReject++;
    173            return send_res;
    174          }
    175          
    176          
    177          static void UnLoadRXData(char *src, size_t len){
    178            for (size_t i = 0 ; i < len; i++)
    179              src[i] = RFD;
    180          };
    181          
    182          
    183          static bool RecvData(ustime_t timeout, nwtime_t *sfd_stamp){   
    184            bool recv_result = true;
    185            
    186            ISFLUSHRX();
    187            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    188            RFIRQF0 &= ~RFIRQF0_SFD; 
    189            ISRXON();
    190            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.isrxon);
    191            stamp_t start = UST_now();
    192            TRY{
    193              while(true){
    194                if (UST_time_over(start, timeout))
    195                  THROW(1);
    196                
    197                if ((RFIRQF0 & RFIRQF0_SFD)){ // Принят сигнал SFD
    198                  *sfd_stamp = AT_time(); 
    199                  WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.sfd);
    200                  break;
    201                }
    202              }
    203              // Ждем окончания приема пакета
    204              while (!(RFIRQF0 & RFIRQF0_RXPKTDONE));
    205              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.rxdone);
    206            }
    207            CATCH(1){ // Вышло время ожидания
    208              recv_result = false;
    209            }
    210            FINALLY{
    211              ISRFOFF();
    212            }
    213            ETRY;
    214            return recv_result;
    215          }
    216          
    217          /*!
    218          \brief Принимает данные из эфира
    219          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    220          RI_CRC_ERROR. Отмечает время прихода SFD в тактах сетевого времени .
    221          \param[in] timeout Время ожидания данных в микросекундах
    222          \return Возвращает NULL если данных нет
    223          */
    224          struct frame* RI_Receive(ustime_t timeout){
    225            // Устанавливаем частоту передачи пакета
    226            pre_config();
    227            nwtime_t sfd_stamp;
    228               
    229            // Принимаем пакет 
    230            stamp_t start = UST_now();
    231            bool recv_res = RecvData(timeout, &sfd_stamp);
    232            stamp_t stop = UST_now();
    233            ustime_t rx_time = UST_interval(start, stop); 
    234            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_RX.fulltime, rx_time);
    235            MODEL.RADIO.UptimeRX += rx_time;
    236            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_RX.received, recv_res);
    237            if (!recv_res) // Нет пакета, возвращаем NULL
    238              return NULL;
    239            
    240            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    241            
    242            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    243            if (frame_size <= 2)
    244              return NULL;
    245            
    246            UnLoadRXData(RXBUFF, frame_size);
    247            
    248            int8_t  FCS1 = RXBUFF[frame_size - 2]; // RSSI
    249            uint8_t FCS2 = RXBUFF[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    250            uint8_t LEN_F = RXBUFF[0]; // Поле LEN
    251            
    252            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    253            // с фактической длинной принятых данных
    254            if (LEN_F != frame_size - 1){
    255              MODEL.RADIO.CRCError++;
    256              return NULL;
    257            }
    258            
    259            // Проверим поле CRCOK
    260            if (!(FCS2 & 1<<7)){
    261              MODEL.RADIO.CRCError++;
    262              LOG_ON("CRC ERR");
    263              return NULL;
    264            }
    265            
    266            // Проверим количество доступных пакетов для хранения принятых данных
    267          //  int fr_av = FR_available();
    268          //  if (fr_av == 0){
    269          //    LOG_ON("NOT ENOUGH FREE FRAME");
    270          //    return NULL;
    271          //  };
    272            
    273            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    274            struct frame *frame = FR_create();
    275            ASSERT(frame);
    276            bool add_h = FR_add_header(frame, &RXBUFF[1], frame_size - 3);
    277            ASSERT(add_h);
    278            
    279            frame->meta.TIMESTAMP = sfd_stamp;
    280            frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    281            uint8_t corr = FCS2 & 0x7F;
    282            frame->meta.LIQ = LIQ_CALC(corr);
    283            frame->meta.CH = MODEL.RADIO.channel;
    284            return frame;
    285          }
    286          
    287          
    288          /**
    289          @breif Подссчет количества бит в байте
    290          @return Возвращает количество бит
    291          */
    292          static uint8_t bits_count(uint8_t value) {
    293            int ret = 0;
    294            for ( ; value; value = value >> 1 )
    295              ret += value & 1;
    296            return ret;
    297          }
    298          
    299          /**
    300          @brief Возращает 1 байт случайного числа
    301          @details Радио выдает всего лишь дви бита, нам нужно 8 
    302          */
    303          static inline uint8_t getRNDByte(void)
    304          {
    305            uint8_t val = 0;
    306            val |= RFRND << 0;
    307            val |= RFRND << 2;
    308            val |= RFRND << 4;
    309            val |= RFRND << 6;
    310            return val;
    311          }
    312          
    313          /**
    314          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    315          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    316          возвращает гарантированно новое значение. 
    317          @return возвращает случайное число.
    318          */
    319          static inline uint8_t readRandom(void)
    320          {
    321            uint8_t rnd_val = 0;
    322            uint8_t bit_cnt = 0;
    323            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    324            {
    325              rnd_val = getRNDByte();
    326              while (rnd_val == getRNDByte());
    327              rnd_val = getRNDByte();
    328              bit_cnt = bits_count(rnd_val);
    329            }
    330            return rnd_val;
    331          }
    332          
    333          /*!
    334          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    335          */
    336          static void random_core_init(void)  
    337          {
    338            unsigned int rnd_core = 0;;
    339               
    340            pre_config();
    341            FREQCTRL = 0x00; // Выбираем не используемую частоту
    342          
    343            // TODO По какой то причине OP_EXE не выполняет команду.
    344            // регистра RFST читается как 0xD0. это его состояние при reset
    345            // Включаем демодулятор
    346            ISRXON();
    347            
    348            // Ждем пока статус RSSI_VALID станет true
    349            while(!RSSISTAT);
    350            
    351            // Ждем случайных чисел
    352            while (RFRND == 0);
    353            
    354            // Настраиваем ядро случайного генератора
    355            rnd_core = readRandom();
    356            rnd_core |= (unsigned int)readRandom()<<8;
    357            srand(rnd_core);
    358            
    359            // Выключаем демодулятор
    360            ISRFOFF();
    361            // Первая генерация случайного числа занимает много времени.
    362            // Влияло на работу радио, так как использовались случайные посылки
    363            rand(); 
    364          }
    365          
    366          /**
    367          @brief Измерение мощности сигнала
    368          @details Частота = 2394+fch. fch = [0..113]. 2394MHz to 2507MHz.
    369           Устройство поддерживает частоты до 2507 МГц
    370          @param[in] fch номер ЧАСТОТНОГО канала
    371          @param[in] timeout_ms время сканирования в мс
    372          @param[out] Максимальная мощность сигнала за время сканирования
    373          @return true если успешно
    374          */
    375          bool RI_Measure_POW(char fch, ustime_t timeout, 
    376                              int8_t *RSSI_SIG){
    377            if (fch > 113)
    378              return false;
    379            //(2394+FREQCTRL.FREQ[6:0])
    380            FREQCTRL = fch; // Выбираем не используемую частоту
    381            ISRXON();
    382            while(!RSSISTAT);
    383            FRMCTRL0 |= 1<<4; // включаем ENERGY_SCAN, детектор пикового сигнала
    384            UST_delay(timeout);
    385            int8_t rssi = RSSI + RSSI_OFFSET;
    386            *RSSI_SIG = rssi;
    387            ISRFOFF();
    388            return true;
    389          }
    390          
E:\Neocore\Hardware\PRG Node\route.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "protocol_defs.h"
      4          #include "ip.h"
      5          #include "neigh.h"
      6          #include "balancer.h"
      7          #include "auth_eth.h"
      8          #include "ethernet.h"
      9          #include "mem_utils.h"
     10          
     11          #define ROUTE_TABLE_ITEMS 20
     12          #define ROUTE_LIVE_TIME 15 // Время жизни маршрута в минутах
     13          
     14          struct route_record{
     15            unsigned int nsrc;
     16            unsigned int fsrc;
     17            char live_time;
     18            char NSRC_TS;
     19            char NSRC_CH;
     20            bool RA;
     21          } __attribute__((packed));
     22          
     23          static struct route_record ROUTE_TABLE[ROUTE_TABLE_ITEMS];
     24          
     25          void RP_Init(){
     26            // Очистим таблицу соседей
     27            MEMSET((char*)ROUTE_TABLE, 0, sizeof(ROUTE_TABLE));
     28          };
     29          
     30          static void analyse_route_table(){
     31            static unsigned long last_analyse_time = 0;
     32            unsigned long now = MODEL.RTC.uptime;
     33            
     34            // Ждем что пройдем как минимум 1 минута с последнего анализа
     35            if ((now - last_analyse_time) < 60)
     36              return;
     37            
     38            last_analyse_time = now;
     39            
     40            LOG_ON("Analyse ROUTE table");
     41            
     42            // Теперь уменьшим время жизни записям и удалим при необходимости
     43            for (int  i = 0; i < ROUTE_TABLE_ITEMS; i++){
     44              // Пропускаем пустые записи
     45              if (!ROUTE_TABLE[i].RA)
     46                continue;
     47              
     48              // Уменьшаем время жизни
     49              if (ROUTE_TABLE[i].live_time > 0)
     50                ROUTE_TABLE[i].live_time--;
     51              
     52              // Помечаем запись свободной по истечению времени жизни
     53              if (ROUTE_TABLE[i].live_time == 0){
     54                LOG_ON("Record ROUTE: nsrc %d, fdst %d deleted", 
     55                       ROUTE_TABLE[i].nsrc, ROUTE_TABLE[i].fsrc);
     56                ROUTE_TABLE[i].RA = false;    
     57              }
     58            };
     59          };
     60          
     61          void RP_TimeAlloc(){
     62            analyse_route_table();
     63          };
     64          
     65          void RP_Receive(struct frame *frame){
     66            #warning update route tables
                    ^
Warning[Pe1105]: #warning directive: update route tables
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\route.c"
     67            switch (frame->meta.PID){
     68            case PID_IP: // Пакет относится к протоколу IP
     69              IP_Receive(frame);
     70              break;
     71            case PID_NP: // Пакет относится к протоколу соседей
     72              NP_Receive(frame);
     73              break;
     74            case PID_AUTH: // Пакет относится к протоколу авторизации
     75              AUTH_ETH_Receive(frame);
     76              break;
     77            default:
     78              return; // Пакет удалит ethernet
     79            };
     80            
     81            TB_Receive(frame);  
     82          };
     83          
     84          /** brief Отправить пакет лучшему соседу
     85          */
     86          void RP_Send_COMM(struct frame *frame){
     87            bool condition = MODEL.SYNC.synced && MODEL.NEIGH.comm_node_found;
     88            if (!condition){
     89              FR_delete(frame);
     90              LOG_ON("Cant send.");
     91              return;
     92            };  
     93            
     94            char ts;
     95            char ch;
     96            unsigned int addr;
     97            bool res = comm_node_info(&addr, &ts, &ch);
     98            if (!res){
     99              FR_delete(frame);
    100              LOG_ON("Problem with comm_node_info");
    101            };
    102            
    103            frame->meta.TS = ts;
    104            frame->meta.CH = ch;
    105            frame->meta.NDST = addr;
    106            frame->meta.NSRC = MODEL.node_adr;
    107            eth_send(frame);
    108            LOG_ON("Sended to COMM node. NDST=%d, CH=%d, TS=%d", addr, ch, ts);  
    109          };
    110          
    111          void RP_Send_GW(struct frame *frame){
    112            bool condition = MODEL.AUTH.auth_ok && MODEL.AUTH.access_ok &&
    113              MODEL.SYNC.synced && MODEL.NEIGH.comm_node_found;
    114            if (!condition){
    115              FR_delete(frame);
    116              LOG_ON("Cant send.");
    117              return;
    118            };
    119            
    120            char ts;
    121            char ch;
    122            unsigned int addr;
    123            bool res = comm_node_info(&addr, &ts, &ch);
    124            if (!res){
    125              FR_delete(frame);
    126              LOG_ON("Problem with comm_node_info");
    127            };
    128            
    129            frame->meta.TS = ts;
    130            frame->meta.CH = ch;
    131            frame->meta.NDST = addr;
    132            frame->meta.NSRC = MODEL.node_adr;
    133            LOG_ON("Sended to GW. frame_ptr=0x%x, NDST=%d, NSRC=%d, FDST=%d, FSRC=%d, TS=%d, CH=%d",
    134                   (char*)frame,frame->meta.NDST,frame->meta.NSRC,
    135                   frame->meta.FDST,frame->meta.FSRC,ts,ch);
    136           
    137            // Тут все сложно. Иногда бывает, что узел отправляет пакет не впередед к шлюзу,
    138            // а назад. Это происходит если произошла ошибка с определением ETX.
    139            // У меня было так: шлюз передал NP card с ошибкой ETX. Там было etx=244.
    140            // Узел принял эту карту, и решил что его сосед с ETX=2 лучше чем 244. 
    141            // Переключился на работу с ним, и пакеты UDP отправлял ему. Второй узел
    142            // Считал, что первый является путем к шлюзу и пакет переадресовывал ему.
    143            // Вобщем получилась петля. 
    144            if (frame->meta.FSRC == frame->meta.NDST){
    145              LOG_ON("Frame loop found. FSRC=NDST=%d", frame->meta.NDST);
    146              FR_delete(frame);
    147              return;
    148            };
    149            
    150            eth_send(frame);
    151            
    152          };
    153          
    154          void RP_Send(struct frame *frame){
    155            eth_send(frame);
    156            LOG_ON("Sended raw");  
    157          };
    158          
    159          /** brief Ищем номер записи по паре значений
    160          */
    161          static int route_find(unsigned int nsrc, unsigned int fsrc){
    162            for (int i = 0; i < ROUTE_TABLE_ITEMS; i++)
    163              if (ROUTE_TABLE[i].nsrc == nsrc && ROUTE_TABLE[i].fsrc == fsrc
    164                  && ROUTE_TABLE[i].RA)
    165                return i;
    166            return -1;
    167          };
    168          
    169          static int find_free(){
    170            for (int i = 0; i < ROUTE_TABLE_ITEMS; i++)
    171              if (!ROUTE_TABLE[i].RA)
    172                return i;
    173            return -1;  
    174          };
    175          
    176          static bool route_update(unsigned int nsrc, unsigned int fsrc,
    177                                   char nsrc_ts, char nsrc_ch){
    178            // Ищем запись о маршруте
    179            int idx = route_find(nsrc, fsrc);
    180            
    181            // Если такого маршрут небыло, ищем свободную ячейку
    182            if (idx < 0)
    183              idx = find_free();
    184            
    185            // Если таблица пуста выходим
    186            if (idx < 0){
    187              LOG_ON("Route table full!");
    188              return false;
    189            };
    190            
    191            ROUTE_TABLE[idx].nsrc = nsrc;
    192            ROUTE_TABLE[idx].fsrc = fsrc;
    193            ROUTE_TABLE[idx].live_time= ROUTE_LIVE_TIME;
    194            ROUTE_TABLE[idx].NSRC_TS = nsrc_ts;
    195            ROUTE_TABLE[idx].NSRC_CH = nsrc_ch;
    196            ROUTE_TABLE[idx].RA = true;  
    197            return true;
    198          };
    199          
    200          /** Пересылка пакета к шлюзу с добавлением маршрута
    201          */
    202          void RP_SendRT_GW(struct frame *frame){
    203            // Информация как был получен пакет и от кого
    204            unsigned int nsrc = frame->meta.NSRC;
    205            unsigned int fsrc = frame->meta.FSRC;
    206            char nsrc_ts = frame->meta.NSRC_TS;
    207            char nsrc_ch = frame->meta.NSRC_CH;   
    208            
    209            // Обновим таблицу маршрутов
    210            bool res = route_update(nsrc, fsrc, nsrc_ts, nsrc_ch);
    211            if (res){
    212              LOG_ON("Route table updated. nsrc=%d, fsrc=%d, ts=%d, ch=%d",
    213                     nsrc, fsrc, nsrc_ts, nsrc_ch);
    214            } else
    215              LOG_ON("Route table update faild. nsrc=%d, fsrc=%d, ts=%d, ch=%d",
    216                   nsrc, fsrc, nsrc_ts, nsrc_ch);
    217            
    218            
    219            // frame будет удален после выхода из eth_receive и пакет не будет 
    220            // отправлен. Нужно его скопировать и только потом отправлять
    221            struct frame *new_frame = FR_create();
    222            ASSERT(new_frame);
    223            
    224            FR_add_header(new_frame, frame->payload, frame->len);
    225            new_frame->meta.FSRC = fsrc;
    226            new_frame->meta.PID = frame->meta.PID;
    227            new_frame->meta.IPP = frame->meta.IPP;
    228            
    229            RP_Send_GW(new_frame);
    230          };
    231          
    232          /** brief Ищем маршрут до fdst
    233          */
    234          static int route_find_by_fsrc(unsigned int fsrc){
    235            for (int i = 0; i < ROUTE_TABLE_ITEMS; i++)
    236              if (ROUTE_TABLE[i].fsrc == fsrc && ROUTE_TABLE[i].RA)
    237                return i;
    238            return -1;
    239          };
    240          
    241          /** brief Передача от шлюза к какому то узлу
    242          */
    243          void RP_SendRT_RT(struct frame *frame){
    244            unsigned int fsrc = frame->meta.FSRC;
    245            unsigned int fdst = frame->meta.FDST;
    246            
    247            if (fsrc != 0){
    248              LOG_ON("Frame must be sended GW. Drop. fsrc=%d", fsrc);
    249              return;
    250            };
    251            
    252            if (fdst == 0){
    253              LOG_ON("Frame fdst is 0. Drop.");
    254              return;
    255            };
    256            
    257            if (fdst == 0xffff){
    258              LOG_ON("Frame fdst is 0xffff. Drop.");
    259              return;
    260            };
    261            
    262            // Ищем через кого раньше был отправлен пакет
    263            int idx = route_find_by_fsrc(fdst);
    264            if (idx < 0){
    265              LOG_ON("Route to node %d not found. Drop.", fdst);
    266              return;
    267            };
    268            
    269            // frame будет удален после выхода из eth_receive и пакет не будет 
    270            // отправлен. Нужно его скопировать и только потом отправлять
    271            struct frame *new_frame = FR_create();
    272            ASSERT(new_frame);
    273            
    274            FR_add_header(new_frame, frame->payload, frame->len);
    275          
    276            new_frame->meta.PID = frame->meta.PID; 
    277            new_frame->meta.TS = ROUTE_TABLE[idx].NSRC_TS;
    278            new_frame->meta.CH = ROUTE_TABLE[idx].NSRC_CH;
    279            new_frame->meta.NDST = ROUTE_TABLE[idx].nsrc;
    280            new_frame->meta.NSRC = MODEL.node_adr;
    281            
    282            
    283            LOG_ON("Route frame(fdst=%d, fsrc=%d) to NODE %d by route table. ", 
    284              fdst, fsrc, ROUTE_TABLE[idx].nsrc); 
    285              
    286            eth_send(new_frame);
    287          
    288          };
E:\Neocore\Hardware\Stack_core_src\rtc.c
      1          #include "action_manager.h"
      2          #include "model.h"
      3           
      4          static void SW_Init(void); 
      5          static void Cold_Start(void);
      6          static void Hot_Start(void);
      7          
      8          module_s RTC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
      9            ALIAS(Hot_Start)};
     10           
     11          static void SW_Init(void){}; 
     12          static void Cold_Start(void){};
     13          
     14          
     15          static void Hot_Start(void){
     16            if (MODEL.TM.timeslot != 0)
     17              return;    
     18            MODEL.RTC.uptime++;
     19            MODEL.RTC.rtc++;
     20          };
E:\Neocore\Hardware\STACK_CORE_SRC\sync.c
      1          #include "sync.h"
      2          #include "action_manager.h"
      3          #include "radio.h"
      4          #include "model.h"
      5          #include "alarm_timer.h"
      6          #include "debug.h"
      7          #include "frame.h"
      8          #include "coder.h"
      9          #include "stdlib.h"
     10          #include "macros.h"
     11          #include "global.h"
     12          #include "llc.h"
     13          
     14          
     15          #define MODE_0 0 // Отклчена модуль синхронизации 
     16          #define MODE_1 1 // Прием, ретрансляция, синхронизация
     17          #define MODE_2 2 // Периодическое вещание
     18          #define SYNC_TS 0 // Слот для синхронизации
     19          #define MAGIC 0x19833891 // Проверка что пакет действительно sync
     20          #define SYNC_TIME 163 // Точное время отправки пакета.nwtime
     21          #define NEG_RECV_OFFSET 33 // nwtime
     22          #define POS_RECV_OFFSET 33 // nwtime
     23          #define SEND_PERIOD 10 // Периодичность отправки пакетов
     24          #define RETRANSMITE_TRY 5 // Кол-во попыток отправки sync
     25          #define PROBABILIT 50 // % вероятность одной попытки отправки 
     26          #define UNSYNC_TIME 60 // Время в секундах рассинхронизации сети
     27          
     28          static void SW_Init(void);
     29          static void Cold_Start(void);
     30          static void Hot_Start(void);
     31          static bool send_sync(void);
     32          static struct frame* recv_sync(void);
     33          static char retransmite;
     34          
     35          module_s SYNC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
     36            ALIAS(Hot_Start)};
     37          
     38          struct sync{
     39            char sys_ch;
     40            char tx_power;
     41            char panid;
     42            unsigned long rtc;
     43            unsigned long magic;
     44          } __attribute__((packed));
     45          
     46          static void SW_Init(void){ 
     47            MODEL.SYNC.next_sync_send = 0;
     48            MODEL.SYNC.next_time_recv = 0;
     49            MODEL.SYNC.last_time_recv = 0;
     50            MODEL.SYNC.sys_channel = DEFAULT_SYS_CH;
     51            MODEL.SYNC.sync_channel = DEFAULT_SYNC_CH;
     52            retransmite = 0;
     53          };
     54          
     55          void SY_restart(){
     56            MODEL.SYNC.next_sync_send = 0;
     57            MODEL.SYNC.next_time_recv = 0;
     58            MODEL.SYNC.last_time_recv = 0;
     59            retransmite = 0;
     60          }
     61          
     62          static void Cold_Start(void){
     63          };
     64          
     65          static inline bool validate_sync(struct sync *sync){
     66            bool valid = 
     67              (sync->magic == MAGIC) &&
     68              (sync->panid == MODEL.SYNC.panid);
     69            return valid;
     70          }
     71          
     72          static inline void accept_sync_data(struct sync *sync){
     73            MODEL.RTC.rtc = sync->rtc;
     74          };
     75          
     76          static inline void syncronize_timer(struct frame *frame){
     77            nwtime_t now = AT_time();
     78            // Время прошедшее с момента получения пакета
     79            // RI_Send корректриует время, чтобы SFD был передан в SEND_TIME
     80            // Поэтому нам корректировать ненужно
     81            nwtime_t passed = AT_interval(now, frame->meta.TIMESTAMP);  
     82            AT_set_time(SYNC_TIME + passed);
     83            MODEL.SYNC.sync_err = SYNC_TIME - frame->meta.TIMESTAMP;
     84            LOG_OFF("Sync err %d", MODEL.SYNC.sync_err);
     85          };
     86          
     87          static inline void mode_1_receive_process(void){
     88            LOW(PIN1);
     89            struct frame *fr = recv_sync();
     90            if (!fr)
     91              return;
     92            
     93            struct sync *sync = (struct sync*)(fr->payload);
     94            if (!validate_sync(sync)){
     95              FR_delete(fr);
     96              return;
     97            }
     98            syncronize_timer(fr);
     99            accept_sync_data(sync);
    100            FR_delete(fr);
    101            LOG_OFF("Sichronize sync RSSI = %d", fr->meta.RSSI_SIG);
    102            retransmite = RETRANSMITE_TRY;
    103            MODEL.SYNC.next_time_recv = MODEL.RTC.uptime + SEND_PERIOD;
    104            MODEL.SYNC.last_time_recv = MODEL.RTC.uptime;   
    105            HIGH(PIN1);
    106          }
    107          
    108          static inline bool _throw_dice(void){
    109            return  ((rand() % 100) <= PROBABILIT) ? true : false;
    110          };
    111          
    112          static inline void mode_1_retransmition_process(void){
    113            retransmite--;
    114            // Если наступила последняя передача синхропакета, то передаем принудительно
    115            // без подбрасывания костей
    116            if (retransmite == 0){
    117              send_sync();
    118              return;
    119            };
    120            
    121            // Если количество попыток не исчерпано, кидаем кости. Событие равноверятное
    122            // 50%
    123            if (!_throw_dice())
    124              return;
    125            send_sync();
    126            retransmite = 0;
    127          }
    128          
    129          static void mode_1_process(){
    130           // Прием, ретрансляция, синхронизация   
    131            if ( MODEL.RTC.uptime >= MODEL.SYNC.next_time_recv)
    132              mode_1_receive_process();
    133            else if(retransmite)
    134              mode_1_retransmition_process();
    135            
    136            if (MODEL.RTC.uptime - MODEL.SYNC.last_time_recv > UNSYNC_TIME){
    137              MODEL.SYNC.synced = false;
    138              MODEL.SYNC.mode = 0;
    139              MODEL.TM.MODE = 0;
    140              LOG_ON("unsynced");
    141            }
    142          }
    143          
    144          /**
    145          * brief Сканирование энергии в канале
    146          *
    147          * Работает только в режиме шлюза.
    148          */
    149          static void energy_scan(){
    150            static channel_t scan_channel = CH11;
    151            int8_t rssi_sig;
    152            
    153            RI_Measure_POW(scan_channel, 8000, &rssi_sig);
    154            // Сохраняем пиковые значения
    155            if (rssi_sig > MODEL.PWR_SCAN.energy[scan_channel - 11])
    156              MODEL.PWR_SCAN.energy[scan_channel - 11] = rssi_sig;
    157            
    158            scan_channel++;
    159            if (scan_channel > CH28)
    160              scan_channel = CH11;
    161          };
    162          
    163          static void mode_2_process(){
    164            // Периодическое вещание
    165            if ( MODEL.RTC.uptime < MODEL.SYNC.next_sync_send){
    166              energy_scan();
    167              return;
    168            }
    169            MODEL.SYNC.next_sync_send = MODEL.RTC.uptime + SEND_PERIOD;
    170            LOW(PIN1);
    171            send_sync();
    172            HIGH(PIN1);
    173          }
    174          
    175          static void Hot_Start(void){
    176            if (MODEL.TM.timeslot != SYNC_TS)
    177              return;
    178            switch(MODEL.SYNC.mode){
    179              case MODE_0: break;
    180              case MODE_1: mode_1_process(); break;
    181              case MODE_2: mode_2_process(); break;
    182              default:
    183              HALT("Wrong mode");
    184            }
    185          };
    186          
    187          static struct frame* recv_sync(void){
    188            if(!RI_SetChannel(MODEL.SYNC.sync_channel))
    189              HALT("Wrong channel");
    190            struct frame *frame;
    191            
    192            AT_wait(SYNC_TIME - NEG_RECV_OFFSET);
    193            ustime_t recv_time = NWTIME_TO_US(NEG_RECV_OFFSET + POS_RECV_OFFSET);
    194            TRY{
    195              frame = RI_Receive(recv_time);
    196              if (!frame)
    197                THROW(1);
    198              if (frame->len != sizeof(struct sync))
    199                THROW(2);
    200              AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
    201              return frame;
    202            }
    203            CATCH(1){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    204              return NULL;
    205            }
    206            CATCH(2){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    207              FR_delete(frame);
    208              return NULL;
    209            }
    210            ETRY;
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    211            return frame;
    212          }
    213          
    214          static bool send_sync(void){
    215            struct sync sync;
    216            sync.sys_ch = MODEL.SYNC.sys_channel;
    217            sync.tx_power = MODEL.RADIO.power_tx;
    218            sync.panid = MODEL.SYNC.panid;
    219            sync.rtc = MODEL.RTC.rtc;
    220            sync.magic = MAGIC;
    221            
    222            // Проверим количество доступных пакетов
    223            int fr_av = FR_available();
    224            if (fr_av == 0){
    225              LOG_ON("NOT ENOUGH FREE FRAME");
    226              return false;
    227            };
    228            
    229            struct frame *fr = FR_create();
    230            ASSERT(fr);
    231            FR_add_header(fr, &sync, sizeof(struct sync));
    232            
    233            AES_StreamCoder(true, fr->payload, fr->payload, fr->len);
    234            
    235            bool set_ch_res = RI_SetChannel(MODEL.SYNC.sync_channel);
    236            ASSERT(set_ch_res);
    237            bool res = RI_Send_time(fr, (nwtime_t)SYNC_TIME);
    238            FR_delete(fr);
    239            LOG_OFF("SYNC sended, res = %d", res);
    240            return res;
    241          }
    242          
    243          static struct frame* network_recv_sync(ustime_t timeout){
    244            if(!RI_SetChannel(MODEL.SYNC.sync_channel))
    245              HALT("Wrong channel");
    246            
    247            struct frame *frame = NULL;
    248            TRY{
    249              frame = RI_Receive(timeout);
    250              if (!frame)
    251                THROW(1);
    252              if (frame->len != sizeof(struct sync))
    253                THROW(2);
    254              AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
    255              return frame;
    256            }
    257            CATCH(1){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    258              return NULL;
    259            }
    260            CATCH(2){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    261              FR_delete(frame);
    262              return NULL;
    263            }
    264            ETRY;
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    265            return frame;
    266          }
    267          
    268          bool network_sync(ustime_t timeout){  
    269            stamp_t now = UST_now();
    270            struct frame *frame;
    271            struct sync *sync;
    272            
    273            TRY{
    274              while(true){
    275                if(UST_time_over(now, timeout))
    276                   THROW(1);
    277                
    278                frame = network_recv_sync(timeout);
    279                if (!frame)
    280                   continue;
    281                
    282                sync = (struct sync*)frame->payload;
    283                if (sync->magic != MAGIC){
    284                  FR_delete(frame);
    285                  continue;
    286                }
    287               
    288                syncronize_timer(frame);
    289                
    290                MODEL.SYNC.synced = true;
    291                MODEL.SYNC.sys_channel = sync->sys_ch;
    292                MODEL.SYNC.panid = sync->panid;
    293                MODEL.RADIO.power_tx = sync->tx_power;
    294                MODEL.RTC.rtc = sync->rtc;
    295                
    296                retransmite = RETRANSMITE_TRY;
    297                MODEL.SYNC.next_time_recv = MODEL.RTC.uptime +  SEND_PERIOD ;
    298                MODEL.SYNC.last_time_recv = MODEL.RTC.uptime;     
    299                break;
    300              }
    301            }
    302            CATCH(1){
    303              FR_delete(frame);
    304              return false; // timeout
    305            }
    306            FINALLY{
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"

  static void SW_Init(void){
              ^
"E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c",34  Warning[Pe177]: function
          "SW_Init" was declared but never referenced
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c"
    307              FR_delete(frame);
    308            }
    309            ETRY;
    310            return true;  
    311          }
E:\Neocore\Hardware\PRG Node\tcp.c
      1          #include "tcp.h"
      2          #include "debug.h"
      3          
      4          void TCP_Recive(struct frame *frame){
      5            LOG_ON("TCP RECEIVE");
      6          };
E:\Neocore\Hardware\STACK_CORE_SRC\time_manager.c
      1          #include "time_manager.h"
      2          #include "model.h"
      3          #include "action_manager.h"
      4          #include "debug.h"
      5          #include "cpu.h"
      6          #include "macros.h"
      7          #include "LLC.h"
      8          
      9          /**
     10          @file
     11          */
     12          
     13          #define MAX_TIME_SLOTS 50
     14          
     15          #define ACTIVE_INTERVAL (nwtime_t)327 // 9.979 мс
     16          #define SLEEP_INTERVAL (nwtime_t)327  // 9.979 мс
     17          #define UNACCOUNTED 68 // Остаток времени после 50ого интервала.
     18          #define FULL_INTERVAL (ACTIVE_INTERVAL + SLEEP_INTERVAL)
     19          #define SLOT_TO_NWTIME(slot) ((nwtime_t)((slot) * FULL_INTERVAL)) 
     20          #define NWTIME_TO_SLOT(nwtime) ((timeslot_t)((time)/FULL_INTERVAL))
     21           
     22          //!< Список задач менеджера. Индекс - номер слота, значение-действие
     23          static char ALARMS[MAX_TIME_SLOTS];
     24          
     25          
     26          void TM_SetAlarm(timeslot_t slot, char alarm){
     27            ASSERT(slot < MAX_TIME_SLOTS);
     28            ALARMS[slot] |= alarm;
     29          }
     30          
     31          void TM_ClrAlarm(timeslot_t slot, char alarm){
     32            ASSERT(slot < MAX_TIME_SLOTS);
     33            ALARMS[slot] &= ~alarm;
     34          }
     35          
     36          static inline timeslot_t _inc_timeslot(timeslot_t slot){
     37            slot++;
     38            return (slot >= MAX_TIME_SLOTS) ? 0 : slot;
     39          }
     40          
     41          static inline timeslot_t _find_next_active(timeslot_t slot){
     42            slot = _inc_timeslot(slot);
     43            while (slot && !ALARMS[slot])
     44              slot = _inc_timeslot(slot);
     45            return slot;
     46          }
     47          
     48          static void scheulder_next_alarm(nwtime_t time){
     49            timeslot_t slot = NWTIME_TO_SLOT(time);
     50            slot = _find_next_active(slot);
     51            AT_set_alarm(SLOT_TO_NWTIME(slot));
     52          }
     53          
     54          void TM_IRQ(nwtime_t time){
     55            if (MODEL.TM.MODE == 0){
     56              AT_enable(false);
     57              return;
     58            }
     59            
     60            ATOMIC_BLOCK_RESTORE{     
     61              MODEL.TM.timeslot = NWTIME_TO_SLOT(time);
     62              MODEL.TM.time = time;
     63              MODEL.TM.alarm = ALARMS[ MODEL.TM.timeslot];
     64              scheulder_next_alarm(time);
     65              AM_Hot_start();
     66              AM_Cold_start();
     67            };
     68          }
     69          
     70          static inline void mcu_sleep(void){
     71            SLEEPCMD = 2; // Режим PM2
     72            PCON = 1;
     73          }
     74          
     75          static inline void _clr_all(void){
     76            for_each_type(char, ALARMS, i)
     77              *i = 0;
     78          }
     79          
     80          static void init(void){
     81            _clr_all();
     82            scheulder_next_alarm(0);
     83            AT_enable(true);
     84          }
     85          
     86          static void start_mode_1(void){
     87            AM_IRQ_Init();
     88            init();
     89            LLC_open_slot(1, MODEL.SYNC.sys_channel);
     90            while (true){
     91              mcu_sleep();
     92              if (MODEL.TM.MODE == 0){
     93                AT_enable(false);
     94                break;
     95              }
     96            AM_Callback();       
     97            }  
     98          }
     99          
    100          static void start_mode_2(void){
    101            AM_IRQ_Init();
    102            init();
    103          }
    104          
    105          void Neocore_start(void){
    106            FR_restart(); // Уничтожает все пакеты и mem_slot.
    107            LLC_restart(); // Убираем все пакеты на передачу
    108            switch (MODEL.TM.MODE){
    109            case 0:
    110              return;
    111            case 1:
    112              start_mode_1();
    113              break;
    114            case 2:
    115              start_mode_2();
    116              break;
    117            default: 
    118              HALT("Incorrect MODEL.TM.MODE");
    119            }
    120          }
E:\Neocore\Hardware\PRG Node\udp.c
      1          #include "udp.h"
      2          #include "debug.h"
      3          #include "frame.h"
      4          #include "protocol_defs.h"
      5          #include "ip.h"
      6          
      7          struct udp_bind{
      8            bool RA;
      9            char port;
     10            void (*fn)(struct frame *frame);
     11          };
     12          
     13          // Таблица для вызова обработчиков
     14          #define BIND_SIZE 5
     15          static struct udp_bind BIND[BIND_SIZE];
     16          
     17          
     18          void UDP_Send(char port, char *ptr, char size){
     19            if (size > 64){
     20              LOG_ON("UDP data too big");
     21              return;
     22            }
     23            
     24            struct frame *frame = FR_create(); 
     25            ASSERT(frame);
     26            bool res = FR_add_header(frame, ptr, size);
     27            ASSERT(res);
     28            
     29            res = FR_add_header(frame, &port, sizeof(char));
     30            ASSERT(res);
     31            
     32            frame->meta.IPP = IPP_UDP;
     33            IP_Send(frame);
     34            
     35            LOG_ON("UDP frame send to gw. port=%d", port);
     36          };
     37          
     38          bool UDP_bind_port(char port, void (*fn)(struct frame *frame)){
     39            for (int i = 0 ; i < BIND_SIZE; i++)
     40              if (!BIND[i].RA){
     41                BIND[i].port = port;
     42                BIND[i].fn = fn;
     43                return true;
     44              };
     45            return false;
     46          };
     47          
     48          void UDP_Recive(struct frame *frame){
     49            if (frame->len == 0){
     50              LOG_ON("UDP wrong size");
     51            };
     52            
     53            char port = frame->payload[0];
     54            bool res = FR_del_header(frame, 1);
     55            ASSERT(res);
     56            
     57            for (int i = 0; i < BIND_SIZE; i++)
     58              if (BIND[i].port == port && BIND[i].RA){
     59                  BIND[i].fn(frame);
     60                  return;
     61              };
     62          };
E:\Neocore\Hardware\STACK_CORE_SRC\ustimer.c
      1          #include "ioCC2530.h"
      2          #include "ustimer.h"
      3          #include "stdint.h"
      4          #include "action_manager.h"
      5          #include "stdbool.h"
      6          
      7          
      8          #define ACCURATE_VAL_US 500 
      9          
     10          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     11          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     12          static uint32_t DELAY_CALIBRATE_TICS; // Калибровка функции задержки
     13          
     14          static void DelayCalibrate(void);
     15          static void HW_Init(void);  
     16          module_s UST_MODULE = {ALIAS(HW_Init)};
     17          
     18          
     19          void HW_Init(void){
     20            // Запускаем таймер, LATCH MODE = 1
     21            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     22            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     23            T2CTRL = (1<<0) | (1<<3); 
     24            // Калибровка функции задержки
     25            DelayCalibrate();
     26          }
     27          
     28          ustime_t UST_now(void){
     29            ustime_t now;
     30            ((char*)&now)[0] = T2M0;
     31            ((char*)&now)[1] = T2M1;
     32            ((char*)&now)[2] = T2MOVF0;
     33            ((char*)&now)[3] = T2MOVF1;
     34            return now;
     35          }
     36          
     37          bool UST_time_over(stamp_t beg, ustime_t wait){
     38            stamp_t now = UST_now(); 
     39            ustime_t delta = UST_interval(beg, now);
     40            return (delta > wait) ?  true:false;
     41          }
     42          
     43          ustime_t UST_interval(stamp_t beg, stamp_t end){
     44            return (end >= beg) ? 
     45              TICKS_TO_US(end - beg) :
     46              TICKS_TO_US(MAC_TIMER_MAX - beg + end);
     47          };
     48          
     49          void UST_delay(ustime_t time){
     50            stamp_t now = UST_now();
     51            stamp_t len = US_TO_TICKS(time);
     52            stamp_t offset = (time > DELAY_CALIBRATE_TICS) ?
     53                              DELAY_CALIBRATE_TICS : 0;
     54            while (UST_now() < (now + len - offset));
     55          }
     56          
     57          
     58          stamp_t _interval(stamp_t beg, stamp_t end){
     59            return (end >= beg) ? 
     60              (end - beg) :
     61              (MAC_TIMER_MAX - beg + end);
     62          };
     63          
     64          /**
     65          @brief Калибровка функции задержки TIM_delay
     66          */
     67          static void DelayCalibrate(void){
     68            DELAY_CALIBRATE_TICS = 0;  
     69            stamp_t start = UST_now();
     70            UST_delay(ACCURATE_VAL_US);
     71            stamp_t end = UST_now();
     72            DELAY_CALIBRATE_TICS = _interval(start, end) -
     73                                    US_TO_TICKS(ACCURATE_VAL_US);
     74          };
E:\Neocore\Hardware\PRG Node\vtimer.c
      1          #include "model.h"
      2          #include "vtimer.h"
      3          
      4          void vtimer_set(struct vtimer *vt, unsigned int sec){
      5            vt->exp_time = sec;
      6            vt->last = MODEL.RTC.uptime;
      7          };
      8          
      9          void vtimer_start(struct vtimer *vt){
     10            vt->last = MODEL.RTC.uptime;
     11          };
     12          
     13          bool vtimer_expired(struct vtimer *vt){
     14            unsigned long now = MODEL.RTC.uptime;
     15            if ((now - vt->last) < vt->exp_time)
     16              return false;
     17            return true;
     18          };

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     73   AES_CCMDecrypt
        0     67   -> CBCMAC_buf_encrypt
        0     71   -> CTR_enc_decrypt
        0     69   -> generateAuthData
        0     69   -> memcpy
        0     69   -> memset
      1     58   AES_CCMEncrypt
        0     52   -> CBCMAC_buf_encrypt
        0     56   -> CTR_enc_decrypt
        0     54   -> generateAuthData
        0     54   -> memcpy
        0     54   -> memset
      0     97   AES_StreamCoder
        0     34   -> memcpy
        0     34   -> memset
      0     12   AM_Callback
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     21   AM_Cold_start
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     22   AM_HW_Init
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     21   AM_Hot_start
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     12   AM_IRQ_Init
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     22   AM_SW_Init
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     22   AM_set_callback
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     18   AT_enable
        0      9   -> IRQEnable
        0      9   -> __cli
      0     10   AT_interval
      0     26   AT_set_alarm
        0     12   -> DBG_CORE_HALT
        0     12   -> IRQEnable
        0     12   -> calcCompareTime
        0     12   -> loadTimerCompare
        0     12   -> printf_P
        0     14   -> printf_P
      0     24   AT_set_time
        0     12   -> AT_set_alarm
        0     12   -> DBG_CORE_HALT
        0     12   -> ReadTimer
        0     12   -> isIRQEnable
        0     12   -> printf_P
        0     14   -> printf_P
      0     83   AT_time
        0     16   -> ReadTimer
      0     77   AT_wait
        0     12   -> DBG_CORE_HALT
        0     12   -> printf_P
        0     14   -> printf_P
      2     18   AUTH_ETH_Init
        2      8   -> MEM_memset
      0     23   AUTH_ETH_Receive
        0     12   -> DBG_CORE_HALT
        0     12   -> FR_del_header
        0     12   -> printf_P
        0     14   -> printf_P
        0     12   -> receiveCMD_Request
        0     12   -> receiveCMD_Response
      2     10   AUTH_ETH_TimeAlloc
        2      0   -> AUTH_request
        2      0   -> AUTH_resend_RESP_from_gw
      0     10   AUTH_IP_Init
      0     22   AUTH_IP_Recive
        0     10   -> FR_del_header
        0     10   -> printf_P
        0     12   -> printf_P
        0     10   -> set_AUTH_NODE_RESP
      2     29   AUTH_IP_TimeAlloc
        0     17   -> DBG_CORE_HALT
        0     17   -> FR_add_header
        0     17   -> IP_Send
        0     17   -> get_AUTH_NODE_REQ
        0     17   -> printf_P
        0     19   -> printf_P
      2     39   AUTH_request
        0     37   -> DBG_CORE_HALT
        0     37   -> FR_add_header
        0     37   -> FR_create
        0     37   -> RP_Send_COMM
        0     37   -> printf_P
        0     39   -> printf_P
      2     15   AUTH_resend_RESP_from_gw
        0     13   -> DBG_CORE_HALT
        0     13   -> FR_add_header
        0     13   -> FR_create
        0     13   -> RP_Send
        0     13   -> printf_P
        0     15   -> printf_P
      0    115   CBCMAC_buf_encrypt
        0     48   -> memcpy
        0     48   -> memset
      0     12   CF_init
        0     12   -> memcpy
      0    105   CTR_enc_decrypt
        0     34   -> memcpy
        0     34   -> memset
      0      0   Cold_Start
      0      0   Cold_Start
      2      0   Cold_Start
        2      0   -> scheduler_rx
        2      0   -> scheduler_tx
      0      0   Cold_Start
      0      0   DBG_CORE_FAULT
      0     63   DBG_CORE_HALT
      0     20   DelayCalibrate
        0     16   -> UST_delay
        0     16   -> UST_now
        0     20   -> _interval
      1     56   FR_add_header
        0     19   -> MEM_memcpy
        0     19   -> mem_move
      2     21   FR_available
        2      0   -> SL_available
      2      0   FR_busy
        2      0   -> SL_busy
      2      0   FR_copy
        2      0   -> SL_copy
      0     51   FR_create
        0     14   -> MEM_memset
        0     14   -> SL_alloc
      1     30   FR_del_header
        0     18   -> MEM_memcpy
        0     18   -> MEM_memset
      2     71   FR_delete
        2      0   -> SL_free
      2     10   FR_find_rx
        2      0   -> SL_find_rx
      2     10   FR_find_tx
        2      0   -> SL_find_tx
      2      0   FR_is_rx
        2      0   -> SL_is_rx
      2      0   FR_is_tx
        2      0   -> SL_is_tx
      2     10   FR_restart
        2      0   -> SW_restart
      2      0   FR_rx_available
        2      0   -> SL_rx_available
      2     14   FR_rx_frames
        2      0   -> SL_rx_slots
      2     14   FR_set_rx
        2      0   -> SL_set_rx
      2     10   FR_set_tx
        2      0   -> SL_set_tx
      2     10   FR_tx_available
        2      0   -> SL_tx_available
      2      0   FR_tx_frames
        2      0   -> SL_tx_slots
      0     12   HP_Init
        0     10   -> AM_HW_Init
        0     10   -> AM_SW_Init
        0     10   -> AM_set_callback
        0     10   -> printf_P
        0     12   -> printf_P
        0     10   -> stack_init
      2      0   HP_ReInit
        2      0   -> stack_init
      2      0   HP_callback
        2      0   -> ethernet_process
      0      0   HW_Init
      3      1   HW_Init
      2      0   HW_Init
        2      0   -> DelayCalibrate
      0      0   HW_Init
      2      0   HW_Init
        2      0   -> IRQEnable
      2     84   HW_Init
        2     84   -> MEM_memcpy
      2      0   HW_Init
        2      0   -> uart_init
      0      0   HW_Init
      0      0   Hot_Start
      2      0   Hot_Start
        2      0   -> receive
        2      0   -> transmite
      0     12   Hot_Start
      0     12   Hot_Start
        0     10   -> DBG_CORE_HALT
        0     10   -> mode_1_process
        0     10   -> mode_2_process
        0     10   -> printf_P
        0     12   -> printf_P
      0     22   IPP_process
        0     10   -> AUTH_IP_Recive
        0     10   -> TCP_Recive
        0     10   -> UDP_Recive
        0     10   -> printf_P
        0     12   -> printf_P
      0     21   IP_Receive
        0     10   -> FR_del_header
        0     10   -> IPP_process
        0     10   -> RP_SendRT_GW
        0     10   -> RP_SendRT_RT
        0     10   -> fill_meta
        0     10   -> frame_filter
        0     10   -> printf_P
        0     12   -> printf_P
      1     35   IP_Send
        0     16   -> DBG_CORE_HALT
        0     16   -> FR_add_header
        0     16   -> RP_Send_GW
        0     16   -> printf_P
        0     18   -> printf_P
      0     15   IRQEnable
      2      4   IRQ_Init
        2      4   -> MEM_memset
      2      0   IRQ_Init
      0     31   LLC_add_tx_frame
        0     10   -> AES_StreamCoder
        0     10   -> DBG_CORE_HALT
        0     10   -> FR_delete
        0     10   -> FR_set_tx
        0     10   -> FR_tx_available
        0     10   -> printf_P
        0     12   -> printf_P
      0     12   LLC_close_slot
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      1     24   LLC_open_slot
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
        0     14   -> printf_P
      2     10   LLC_restart
        2      0   -> SW_Init
      2     61   LoadTXData
      1     22   MAC_Receive
        0     14   -> AES_StreamCoder
        0     14   -> FR_delete
        0     14   -> FR_rx_frames
        0     14   -> FR_set_rx
        0     14   -> _recv_frame
        0     14   -> _send_ack
        0     14   -> is_repeated_frame
        0     14   -> printf_P
        0     16   -> printf_P
        0     22   -> printf_P
      0     32   MAC_Send
        0     10   -> FR_delete
        0     10   -> _recv_ack
        0     10   -> _send_frame
        0     10   -> printf_P
        0     12   -> printf_P
        0     18   -> printf_P
      3     84   MEM_memcpy
      3     18   MEM_memset
      2     14   NP_Init
        2      4   -> MEM_memset
      0     23   NP_Receive
        0     12   -> DBG_CORE_HALT
        0     12   -> FR_del_header
        0     12   -> add_card
        0     12   -> printf_P
        0     14   -> printf_P
        0     12   -> send_node_card
      0     22   NP_TimeAlloc
        0     10   -> analyse_table
        0     10   -> comm_node_choise
        0     10   -> periodic_card_send
        0     10   -> printf_P
        0     12   -> printf_P
        0     10   -> request_cards
      2      0   NeocoreReady
      0     12   Neocore_start
        0     10   -> DBG_CORE_HALT
        0     10   -> FR_restart
        0     10   -> LLC_restart
        0     10   -> printf_P
        0     12   -> printf_P
        0     10   -> start_mode_1
        0     10   -> start_mode_2
      1     27   RI_Measure_POW
        0     12   -> UST_delay
      1     89   RI_Receive
        0     22   -> DBG_CORE_HALT
        0     22   -> FR_add_header
        0     22   -> FR_create
        0     24   -> RecvData
        0     26   -> UST_interval
        0     22   -> UST_now
        0     22   -> UnLoadRXData
        0     22   -> pre_config
        0     22   -> printf_P
        0     24   -> printf_P
      0     33   RI_Send
        0     16   -> DBG_CORE_HALT
        0     16   -> SendData
        0     20   -> UST_interval
        0     16   -> UST_now
        0     16   -> pre_config
        0     16   -> printf_P
        0     18   -> printf_P
      0     41   RI_Send_time
        0     16   -> DBG_CORE_HALT
        0     16   -> SendData
        0     20   -> UST_interval
        0     16   -> UST_now
        0     16   -> pre_config
        0     16   -> printf_P
        0     18   -> printf_P
      0     75   RI_SetChannel
        0     10   -> printf_P
        0     12   -> printf_P
      2     14   RP_Init
        2      4   -> MEM_memset
      0     18   RP_Receive
        0      9   -> AUTH_ETH_Receive
        0      9   -> IP_Receive
        0      9   -> NP_Receive
        0      9   -> TB_Receive
      0     25   RP_Send
        0     10   -> eth_send
        0     10   -> printf_P
        0     12   -> printf_P
      1     34   RP_SendRT_GW
        0     16   -> DBG_CORE_HALT
        0     16   -> FR_add_header
        0     16   -> FR_create
        0     16   -> RP_Send_GW
        0     16   -> printf_P
        0     18   -> printf_P
        0     24   -> printf_P
        0     17   -> route_update
      1     34   RP_SendRT_RT
        0     18   -> DBG_CORE_HALT
        0     18   -> FR_add_header
        0     18   -> FR_create
        0     18   -> eth_send
        0     18   -> printf_P
        0     20   -> printf_P
        0     24   -> printf_P
        0     18   -> route_find_by_fsrc
      1     57   RP_Send_COMM
        0     14   -> FR_delete
        0     16   -> comm_node_info
        0     14   -> eth_send
        0     14   -> printf_P
        0     16   -> printf_P
        0     20   -> printf_P
      1     46   RP_Send_GW
        0     16   -> FR_delete
        0     18   -> comm_node_info
        0     16   -> eth_send
        0     16   -> printf_P
        0     18   -> printf_P
        0     30   -> printf_P
      2     10   RP_TimeAlloc
        2      0   -> analyse_route_table
      2     20   ReadTimer
      0     95   RecvData
        0     67   -> AT_time
        0     67   -> UST_now
        0     71   -> UST_time_over
      0     28   SL_alloc
        0      9   -> __cli
      0     12   SL_available
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     12   SL_busy
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     19   SL_copy
        0     19   -> MEM_memcpy
        0     19   -> SL_alloc
        0     19   -> __cli
      2      0   SL_find_rx
      2      0   SL_find_tx
      0      9   SL_free
        0      9   -> SL_is_rx
        0      9   -> SL_is_tx
        0      9   -> __cli
        0      9   -> _free
      2      9   SL_is_rx
      2      9   SL_is_tx
      0     12   SL_rx_available
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      2      0   SL_rx_slots
      0      9   SL_set_rx
        0      9   -> __cli
      0      9   SL_set_tx
        0      9   -> __cli
      0     12   SL_tx_available
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      2      0   SL_tx_slots
      2      0   SL_zone_check
      0      0   SW_Init
      0      0   SW_Init
      2      0   SW_Init
      0      0   SW_Init
      2      0   SW_Init
      2      0   SW_Init
      2      0   SW_Init
        2      0   -> random_core_init
      0      0   SW_Init
      2      0   SW_Init
      2      0   SW_restart
        2      0   -> SW_Init
      2      0   SY_restart
      0     77   SendData
        0     61   -> AT_time
        0     61   -> AT_wait
        0     61   -> LoadTXData
      0      9   TB_Receive
      0     22   TCP_Recive
        0     10   -> printf_P
        0     12   -> printf_P
      0     26   TM_ClrAlarm
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     24   TM_IRQ
        0      9   -> AM_Cold_start
        0      9   -> AM_Hot_start
        0      9   -> AT_enable
        0      9   -> __cli
        0      9   -> scheulder_next_alarm
      0     22   TM_SetAlarm
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     15   TimerCompareInterrupt
        0     15   -> AT_time
        0     15   -> IRQEnable
        0     15   -> TM_IRQ
      0     24   UDP_Recive
        0     12   -> DBG_CORE_HALT
        0     12   -> FR_del_header
        0     12   -> printf_P
        0     14   -> printf_P
      1     38   UDP_Send
        0     15   -> DBG_CORE_HALT
        0     15   -> FR_add_header
        0     15   -> FR_create
        0     15   -> IP_Send
        0     15   -> printf_P
        0     17   -> printf_P
      1      9   UDP_bind_port
      0     44   UST_delay
        0     28   -> UST_now
      0     50   UST_interval
      3     75   UST_now
      0     95   UST_time_over
        0     20   -> UST_interval
        0     16   -> UST_now
      3     22   UnLoadRXData
      0      9   __cli
      0     19   __cli
      0      9   __cli
      2      0   _clr_all
      0      9   _find_next_active
        0      9   -> _inc_timeslot
      2      9   _free
      0      9   _inc_timeslot
      0     44   _interval
      0     30   _recv_ack
        0     16   -> FR_delete
        0     16   -> RI_Receive
        0     16   -> UST_delay
        0     16   -> printf_P
        0     18   -> printf_P
        0     20   -> printf_P
        0     16   -> xor_calc
      0     28   _recv_frame
        0     12   -> DBG_CORE_HALT
        0     12   -> RI_Receive
        0     12   -> RI_SetChannel
        0     12   -> printf_P
        0     14   -> printf_P
      1     35   _send_ack
        0     13   -> DBG_CORE_HALT
        0     13   -> FR_add_header
        0     13   -> FR_create
        0     13   -> FR_delete
        0     13   -> RI_Send
        0     13   -> printf_P
        0     15   -> printf_P
        0     21   -> printf_P
        0     13   -> xor_calc
      0     24   _send_frame
        0     12   -> DBG_CORE_HALT
        0     12   -> RI_Send
        0     12   -> RI_SetChannel
        0     12   -> UST_delay
        0     12   -> printf_P
        0     14   -> printf_P
      0     10   _throw_dice
        0     10   -> rand
      2     12   accept_sync_data
      1     32   add_card
        0     14   -> free_index
        0     14   -> index_by_addr
        0     14   -> printf_P
        0     16   -> printf_P
        0     20   -> printf_P
      2     20   analyse_route_table
        0     16   -> printf_P
        0     18   -> printf_P
        0     20   -> printf_P
      2     28   analyse_table
        0     16   -> printf_P
        0     18   -> printf_P
      0      9   bits_count
      0     32   calcCompareTime
        0     20   -> ReadTimer
      2     19   calc_xor
      2     32   comm_node_choise
        0     16   -> find_node
        0     16   -> printf_P
        0     18   -> printf_P
        0     22   -> printf_P
      1     30   comm_node_info
        0     12   -> rand
      1     27   energy_scan
        0     15   -> RI_Measure_POW
      1     39   eth_send
        0     19   -> DBG_CORE_HALT
        0     19   -> FR_add_header
        0     19   -> LLC_add_tx_frame
        0     19   -> calc_xor
        0     19   -> printf_P
        0     21   -> printf_P
      0     10   ethernet_process
        0     10   -> AUTH_ETH_TimeAlloc
        0     10   -> AUTH_IP_TimeAlloc
        0     10   -> FR_delete
        0     10   -> FR_find_rx
        0     10   -> NP_TimeAlloc
        0     10   -> RP_TimeAlloc
        0     10   -> parse_frame
      3     10   fill_meta
      1     18   fill_meta_data
      2     14   find_free
      0     36   find_node
        0     12   -> printf_P
        0     14   -> printf_P
        0     20   -> printf_P
      0     21   frame_filter
        0     10   -> calc_xor
        0     10   -> printf_P
        0     12   -> printf_P
      0     22   frame_filter
        0     10   -> printf_P
        0     12   -> printf_P
      0     23   free_index
      0     85   generateAuthData
        0     16   -> memcpy
      2      9   getRNDByte
      1     31   get_AUTH_NODE_REQ
        0     12   -> DBG_CORE_HALT
        0     12   -> FR_add_header
        0     12   -> FR_create
        0     12   -> printf_P
        0     14   -> printf_P
      0     23   index_by_addr
      2      0   init
        2      0   -> AT_enable
        2      0   -> _clr_all
        2      0   -> scheulder_next_alarm
      0     12   isIRQEnable
      2     17   is_free
      2     32   is_repeated_frame
        0     16   -> printf_P
        0     18   -> printf_P
        0     16   -> xor_calc
      0     28   loadTimerCompare
      0     26   mac_cmp
      0      2   main
        0      0   -> AM_SW_Init
        0      0   -> HP_Init
        0      0   -> Neocore_start
        0      0   -> network_sync
        0      0   -> printf_P
        0      2   -> printf_P
        0      0   -> setUserTimeAllocation
      0      0   mcu_sleep
      1     28   mem_move
      2     24   mode_1_process
        0     12   -> mode_1_receive_process
        0     12   -> mode_1_retransmition_process
        0     12   -> printf_P
        0     14   -> printf_P
      0     24   mode_1_receive_process
        0     12   -> FR_delete
        0     12   -> accept_sync_data
        0     12   -> recv_sync
        0     12   -> syncronize_timer
        0     12   -> validate_sync
      2     12   mode_1_retransmition_process
        2      0   -> _throw_dice
        2      0   -> send_sync
      0     22   mode_2_process
        0     12   -> energy_scan
        0     12   -> send_sync
      0    136   network_recv_sync
        0     63   -> AES_StreamCoder
        0     63   -> DBG_CORE_HALT
        0     63   -> FR_delete
        0     63   -> RI_Receive
        0     63   -> RI_SetChannel
        0     63   -> printf_P
        0     65   -> printf_P
      0     75   network_sync
        0     71   -> FR_delete
        0     71   -> UST_now
        0     75   -> UST_time_over
        0     71   -> network_recv_sync
        0     71   -> syncronize_timer
      0     19   parse_frame
        0      9   -> FR_del_header
        0      9   -> RP_Receive
        0      9   -> fill_meta_data
        0      9   -> frame_filter
      2     28   periodic_card_send
        0     16   -> printf_P
        0     18   -> printf_P
        0     16   -> send_node_card
      2     22   pre_config
        2      0   -> setFreq
      0      0   putchar
      0      9   random_core_init
        0      9   -> pre_config
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      0     18   readRandom
        0      9   -> bits_count
        0      9   -> getRNDByte
      2      0   receive
        2      0   -> MAC_Receive
      1     43   receiveCMD_Request
        0     17   -> MEM_memcpy
        0     17   -> mac_cmp
        0     17   -> printf_P
        0     19   -> printf_P
        0     31   -> printf_P
      1     24   receiveCMD_Response
        0     10   -> printf_P
        0     12   -> printf_P
        0     10   -> setNodeCHTS
      0     77   recv_sync
        0     63   -> AES_StreamCoder
        0     63   -> AT_wait
        0     63   -> DBG_CORE_HALT
        0     63   -> FR_delete
        0     63   -> RI_Receive
        0     63   -> RI_SetChannel
        0     63   -> printf_P
        0     65   -> printf_P
      2     29   request_cards
        0     17   -> DBG_CORE_HALT
        0     17   -> FR_add_header
        0     17   -> FR_create
        0     17   -> eth_send
        0     17   -> is_free
        0     17   -> printf_P
        0     19   -> printf_P
      0     23   route_find
      0     27   route_find_by_fsrc
      1     33   route_update
        0     14   -> find_free
        0     14   -> printf_P
        0     16   -> printf_P
        0     14   -> route_find
      0     12   scheduler_rx
        0     10   -> DBG_CORE_HALT
        0     10   -> TM_ClrAlarm
        0     10   -> TM_SetAlarm
        0     10   -> printf_P
        0     12   -> printf_P
      0     12   scheduler_tx
        0     10   -> DBG_CORE_HALT
        0     10   -> FR_find_tx
        0     10   -> TM_SetAlarm
        0     10   -> printf_P
        0     12   -> printf_P
      2      9   scheulder_next_alarm
        2      0   -> AT_set_alarm
        2      0   -> _find_next_active
      2     23   send_ip_frame
        0     21   -> UDP_Send
        0     21   -> printf_P
        0     23   -> printf_P
      1     32   send_node_card
        0     14   -> FR_add_header
        0     14   -> FR_create
        0     14   -> eth_send
        0     14   -> printf_P
        0     16   -> printf_P
      1     35   send_sync
        0     21   -> AES_StreamCoder
        0     21   -> DBG_CORE_HALT
        0     21   -> FR_add_header
        0     21   -> FR_available
        0     21   -> FR_create
        0     21   -> FR_delete
        0     21   -> RI_Send_time
        0     21   -> RI_SetChannel
        0     21   -> printf_P
        0     23   -> printf_P
      1     13   setFreq
        0     11   -> DBG_CORE_HALT
        0     11   -> printf_P
        0     13   -> printf_P
      0     24   setNodeCHTS
        0     10   -> LLC_open_slot
        0     10   -> printf_P
        0     12   -> printf_P
        0     14   -> printf_P
        0     10   -> rand
      2      0   setUserTimeAllocation
      1     31   set_AUTH_NODE_RESP
        0     17   -> DBG_CORE_HALT
        0     17   -> MEM_memcpy
        0     17   -> mac_cmp
        0     17   -> printf_P
        0     19   -> printf_P
        0     21   -> printf_P
      0     22   stack_init
        0     10   -> AUTH_ETH_Init
        0     10   -> AUTH_IP_Init
        0     10   -> NP_Init
        0     10   -> RP_Init
        0     10   -> printf_P
        0     12   -> printf_P
      2     10   start_mode_1
        2      0   -> AM_Callback
        2      0   -> AM_IRQ_Init
        2      0   -> AT_enable
        2      0   -> LLC_open_slot
        2      0   -> init
        2      0   -> mcu_sleep
      2     10   start_mode_2
        2      0   -> AM_IRQ_Init
        2      0   -> init
      0     81   syncronize_timer
        0     10   -> AT_interval
        0     10   -> AT_set_time
        0     10   -> AT_time
      0     16   transmite
        0     14   -> DBG_CORE_HALT
        0     14   -> MAC_Send
        0     14   -> TM_ClrAlarm
        0     14   -> printf_P
        0     16   -> printf_P
      0      0   uart_init
      2      0   user_time_alloc
        2      0   -> NeocoreReady
        2      0   -> send_ip_frame
      0     24   validate_sync
      0     16   vtimer_expired
      0      9   vtimer_set
      0      9   vtimer_start
      0     25   xor_calc


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      33  ?<Constant "(ch >= MIN_CH) && (ch...">
       3  ?<Constant "->">
       3  ?<Constant "->">_1
       3  ?<Constant "->">_10
       3  ?<Constant "->">_11
       3  ?<Constant "->">_12
       3  ?<Constant "->">_13
       3  ?<Constant "->">_14
       3  ?<Constant "->">_15
       3  ?<Constant "->">_16
       3  ?<Constant "->">_17
       3  ?<Constant "->">_2
       3  ?<Constant "->">_3
       3  ?<Constant "->">_4
       3  ?<Constant "->">_5
       3  ?<Constant "->">_6
       3  ?<Constant "->">_7
       3  ?<Constant "->">_8
       3  ?<Constant "->">_9
       5  ?<Constant ":%d:">
       5  ?<Constant ":%d:">_1
       5  ?<Constant ":%d:">_10
       5  ?<Constant ":%d:">_11
       5  ?<Constant ":%d:">_12
       5  ?<Constant ":%d:">_13
       5  ?<Constant ":%d:">_14
       5  ?<Constant ":%d:">_15
       5  ?<Constant ":%d:">_16
       5  ?<Constant ":%d:">_17
       5  ?<Constant ":%d:">_2
       5  ?<Constant ":%d:">_3
       5  ?<Constant ":%d:">_4
       5  ?<Constant ":%d:">_5
       5  ?<Constant ":%d:">_6
       5  ?<Constant ":%d:">_7
       5  ?<Constant ":%d:">_8
       5  ?<Constant ":%d:">_9
      35  ?<Constant "ACK size %d incorrect...">
      45  ?<Constant "ACK=%d, frame_len=%d,...">
      23  ?<Constant "ACTIONSLOTS[0].rx == 0">
      64  ?<Constant "AUTH REQ from mac: 0x...">
      37  ?<Constant "AUTH RESP from GW add...">
      18  ?<Constant "AUTH_ETH Response">
      25  ?<Constant "AUTH_ETH frame filltered">
      23  ?<Constant "AUTH_ETH receive frame">
      33  ?<Constant "AUTH_ETH request filt...">
      32  ?<Constant "AUTH_IP gw resp add t...">
      23  ?<Constant "AUTH_IP req send to GW">
      57  ?<Constant "AUTH_IP resp from gw ...">
      18  ?<Constant "Access depricated">
      18  ?<Constant "Access depricated">_1
      29  ?<Constant "Add card exit. no fre...">
       9  ?<Constant "Add card">
      17  ?<Constant "Analyse NP table">
      20  ?<Constant "Analyse ROUTE table">
      16  ?<Constant "Attempts exired">
      32  ?<Constant "Auth ip response from...">
      31  ?<Constant "Auth passed. Access d...">
      18  ?<Constant "Bad frame rssi=%d">
       9  ?<Constant "CALLBACK">
      12  ?<Constant "CCA/ACK err">
      32  ?<Constant "COLD_MOD[i]->Cold_Sta...">
      39  ?<Constant "COMM_NODE_PTR no acti...">
       8  ?<Constant "CRC ERR">
      21  ?<Constant "Cant handel auth req">
      11  ?<Constant "Cant send.">
      37  ?<Constant "Card added! ADDR=%d, ...">
      19  ?<Constant "Card filtered.exit">
      29  ?<Constant "Card found by addr. i...">
      28  ?<Constant "Card found by free in...">
      15  ?<Constant "Card requested">
      12  ?<Constant "Card sended">
      34  ?<Constant "Change. Find IDX=%d. ...">
      25  ?<Constant "Channel %d  [CH11..CH28]">
       6  ?<Constant "Error">
      17  ?<Constant "Extract response">
      20  ?<Constant "Filtered NSRC_CH=%d">
      20  ?<Constant "Filtered NSRC_TS=%d">
      17  ?<Constant "Filtered by size">
      15  ?<Constant "Filtered panid">
      39  ?<Constant "Find: idx=%d, addr=%d...">
      31  ?<Constant "Frame AUTH_ETH_RESP w...">
      23  ?<Constant "Frame ack not received">
      12  ?<Constant "Frame acked">
      23  ?<Constant "Frame fdst is 0. Drop.">
      28  ?<Constant "Frame fdst is 0xffff....">
      31  ?<Constant "Frame loop found. FSR...">
      39  ?<Constant "Frame must be sended ...">
      40  ?<Constant "Frame not acked. fr_a...">
      30  ?<Constant "HOT_MOD[i]->Hot_Start...">
      27  ?<Constant "HW_MOD[i]->HW_Init !=...">
      16  ?<Constant "Hardware inited">
      31  ?<Constant "IP frame for node. IP...">
      11  ?<Constant "IP is AUTH">
      10  ?<Constant "IP is TCP">
      10  ?<Constant "IP is UDP">
      16  ?<Constant "IP sended to gw">
      29  ?<Constant "IRQ_MOD[i]->IRQ_Init ...">
      10  ?<Constant "Imposible">
      24  ?<Constant "Incorrect MODEL.TM.MODE">
      15  ?<Constant "Invalid NP_CMD">
      17  ?<Constant "NO FREE TX FRAME">
      22  ?<Constant "NOT ENOUGH FREE FRAME">
      11  ?<Constant "NP Receive">
      21  ?<Constant "Neocore stack inited">
      26  ?<Constant "Network lost sync. Re...">
      15  ?<Constant "Network synced">
      37  ?<Constant "No free space in AUTH...">
      31  ?<Constant "No free space in AUTH...">_1
      29  ?<Constant "No free space. Not re...">
      24  ?<Constant "Node auth ok! ipaddr=%d">
      29  ?<Constant "Node authorisation re...">
      25  ?<Constant "Node choose TS=%d, CH=%d">
      19  ?<Constant "Node unsinced exit">
      14  ?<Constant "Periodic send">
      28  ?<Constant "Problem with comm_nod...">
      16  ?<Constant "REQUEST NP CARD">
      43  ?<Constant "RX frame. TS=%d, CH=%...">
      24  ?<Constant "Record NODE: %d deleted">
      39  ?<Constant "Record ROUTE: nsrc %d...">
      36  ?<Constant "Repeated frame from N...">
      58  ?<Constant "Route frame(fdst=%d, ...">
      18  ?<Constant "Route table full!">
      57  ?<Constant "Route table update fa...">
      52  ?<Constant "Route table updated. ...">
      12  ?<Constant "Route to GW">
      34  ?<Constant "Route to node %d not ...">
      27  ?<Constant "SW_MOD[i]->SW_Init !=...">
      15  ?<Constant "Send node card">
      13  ?<Constant "Send success">
      45  ?<Constant "Send try: NDST=%d, NS...">
      11  ?<Constant "Sended raw">
      43  ?<Constant "Sended to COMM node. ...">
      79  ?<Constant "Sended to GW. frame_p...">
      24  ?<Constant "Slot open. TS=%d, CH=%d">
      12  ?<Constant "TCP RECEIVE">
      33  ?<Constant "TX attempts exied. Fr...">
      12  ?<Constant "UDP SENDED1">
      17  ?<Constant "UDP data too big">
      30  ?<Constant "UDP frame send to gw....">
      15  ?<Constant "UDP wrong size">
      31  ?<Constant "Unchanged IDX=%d. PTR...">
      17  ?<Constant "Unrecognized IPP">
      17  ?<Constant "Unrecognized cmd">
      14  ?<Constant "Wrong channel">
      14  ?<Constant "Wrong channel">_1
      11  ?<Constant "Wrong mode">
      11  ?<Constant "Wrong size">
      11  ?<Constant "Wrong size">_1
       3  ?<Constant "\r\n">
       3  ?<Constant "\r\n">_1
       3  ?<Constant "\r\n">_10
       3  ?<Constant "\r\n">_11
       3  ?<Constant "\r\n">_12
       3  ?<Constant "\r\n">_13
       3  ?<Constant "\r\n">_2
       3  ?<Constant "\r\n">_3
       3  ?<Constant "\r\n">_4
       3  ?<Constant "\r\n">_5
       3  ?<Constant "\r\n">_6
       3  ?<Constant "\r\n">_7
       3  ?<Constant "\r\n">_8
       3  ?<Constant "\r\n">_9
      10  ?<Constant "ack_frame">
      17  ?<Constant "action_manager.c">
       6  ?<Constant "add_h">
      20  ?<Constant "alarm <= MAX_NWTIME">
      14  ?<Constant "alarm_timer.c">
      11  ?<Constant "auth_eth.c">
      10  ?<Constant "auth_ip.c">
      29  ?<Constant "ch >= MIN_CH && ch <=...">
      13  ?<Constant "controller.c">
      11  ?<Constant "ethernet.c">
       3  ?<Constant "fn">
      11  ?<Constant "fr != NULL">
       3  ?<Constant "fr">
       3  ?<Constant "fr">_1
       3  ?<Constant "fr">_2
       6  ?<Constant "frame">
       6  ?<Constant "frame">_1
       6  ?<Constant "frame">_2
       6  ?<Constant "frame">_3
       6  ?<Constant "frame">_4
       5  ?<Constant "ip.c">
       6  ?<Constant "llc.c">
       6  ?<Constant "mac.c">
       7  ?<Constant "main.c">
      12  ?<Constant "mem_slots.c">
       8  ?<Constant "neigh.c">
      10  ?<Constant "new_frame">
       8  ?<Constant "radio.c">
       4  ?<Constant "res">
       4  ?<Constant "res">_1
       4  ?<Constant "res">_2
       4  ?<Constant "res">_3
       4  ?<Constant "res">_4
       4  ?<Constant "res">_5
       8  ?<Constant "route.c">
      11  ?<Constant "set_ch_res">
      22  ?<Constant "slot < MAX_TIME_SLOTS">
      29  ?<Constant "slot_busy <= SLOT_POO...">
      29  ?<Constant "slot_rx_cnt <= SLOT_R...">
      29  ?<Constant "slot_tx_cnt <= SLOT_T...">
       7  ?<Constant "sync.c">
       6  ?<Constant "tcp.c">
      19  ?<Constant "time <= MAX_NWTIME">
      15  ?<Constant "time_manager.c">
      26  ?<Constant "ts >= 1 && ts < MAX_S...">
      23  ?<Constant "tx_frame->meta.TS != 0">
       6  ?<Constant "udp.c">
       9  ?<Constant "unsynced">
       4  ?<Constant {(char *)(&AUTH_NODE_REQ), 125, 0}>
       4  ?<Constant {(char *)(&AUTH_NODE_RESP), 140, 0}
       4  ?<Constant {(char *)(&NB_TABLE[0].LIVE_TIME),
       4  ?<Constant {(char *)(&REPEATED), 70, 0}>
       4  ?<Constant {(char *)(&ROUTE_TABLE), 160, 0}>
       5  ?<Constant {(char *)0, (char *)0, 153}>
       5  ?<Constant {(char *)0, (char *)0, 24}>
       5  ?<Constant {(char *)0, (char *)0, 27}>
       4  ?<Constant {(char *)0, 0, 0}>
       4  ?<Constant {(char *)0, 20, 0}>
       5  ?<Constant {(char *)MODEL.AES.CCM_IV, (char *)
       5  ?<Constant {(char *)MODEL.AES.CCM_KEY, (char *
       5  ?<Constant {(char *)MODEL.AES.STREAM_IV, (char
       5  ?<Constant {(char *)MODEL.AES.STREAM_KEY, (cha
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_1
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_2
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_3
       5  ?<Constant {1, 2, 3, 4, 5}>
      10  ?<Initializer for AT_MODULE>
      10  ?<Initializer for CODER_MODULE>
       6  ?<Initializer for COLD_MOD>
      10  ?<Initializer for CPU_MODULE>
      10  ?<Initializer for DBG_MODULE>
      10  ?<Initializer for DMA_MODULE>
      10  ?<Initializer for FR_MODULE>
       8  ?<Initializer for HOT_MOD>
      16  ?<Initializer for HW_MOD>
       4  ?<Initializer for IRQ_MOD>
      10  ?<Initializer for LED_MODULE>
      10  ?<Initializer for LLC_MODULE>
      10  ?<Initializer for MAC_MODULE>
      10  ?<Initializer for MD_MODULE>
      10  ?<Initializer for MS_MODULE>
      10  ?<Initializer for RADIO_MODULE>
      10  ?<Initializer for RTC_MODULE>
      14  ?<Initializer for SW_MOD>
      10  ?<Initializer for SYNC_MODULE>
      10  ?<Initializer for UST_MODULE>
      16  ?<Initializer for default_iv>
      16  ?<Initializer for default_key>
       1  ?<Initializer for scan_channel>
       2  ACK_START
     150  ACTIONSLOTS
     484  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     452  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     493  AES_StreamCoder
       6  AES_StreamCoder::?relay
      50  ALARMS
      90  AM_Callback
       6  AM_Callback::?relay
     197  AM_Cold_start
       6  AM_Cold_start::?relay
     185  AM_HW_Init
       6  AM_HW_Init::?relay
     197  AM_Hot_start
       6  AM_Hot_start::?relay
     193  AM_IRQ_Init
       6  AM_IRQ_Init::?relay
     189  AM_SW_Init
       6  AM_SW_Init::?relay
      80  AM_set_callback
       6  AM_set_callback::?relay
      10  AT_MODULE
      43  AT_enable
       6  AT_enable::?relay
      34  AT_interval
       6  AT_interval::?relay
     129  AT_set_alarm
       6  AT_set_alarm::?relay
     139  AT_set_time
       6  AT_set_time::?relay
      55  AT_time
       6  AT_time::?relay
     177  AT_wait
       6  AT_wait::?relay
      61  AUTH_ETH_Init
       6  AUTH_ETH_Init::?relay
     316  AUTH_ETH_Receive
       6  AUTH_ETH_Receive::?relay
      59  AUTH_ETH_TimeAlloc
       6  AUTH_ETH_TimeAlloc::?relay
       3  AUTH_IP_Init
       6  AUTH_IP_Init::?relay
     157  AUTH_IP_Recive
       6  AUTH_IP_Recive::?relay
     291  AUTH_IP_TimeAlloc
       6  AUTH_IP_TimeAlloc::?relay
     125  AUTH_NODE_REQ
     140  AUTH_NODE_RESP
     387  AUTH_request
       6  AUTH_request::?relay
     618  AUTH_resend_RESP_from_gw
       6  AUTH_resend_RESP_from_gw::?relay
      20  BIND
       2  CALLBACK
     463  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
     100  CF_init
       6  CF_init::?relay
       1  CLKCONCMD
       1  CLKCONSTA
      10  CODER_MODULE
       6  COLD_MOD
       2  COMM_NODE_PTR
       4  COMPARE_TIME
      41  CONFIG
      10  CPU_MODULE
     501  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
       3  Cold_Start
       3  Cold_Start
       3  Cold_Start
      23  Cold_Start
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       2  DBG_CORE_FAULT
       6  DBG_CORE_FAULT::?relay
       2  DBG_CORE_HALT
       6  DBG_CORE_HALT::?relay
      10  DBG_MODULE
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
      40  DMA_CH
      10  DMA_MODULE
     114  DelayCalibrate
       6  DelayCalibrate::?relay
       1  ENCCS
       2  FRAME_END
      10  FR_MODULE
     181  FR_add_header
       6  FR_add_header::?relay
      14  FR_available
       6  FR_available::?relay
      14  FR_busy
       6  FR_busy::?relay
      14  FR_copy
       6  FR_copy::?relay
      91  FR_create
       6  FR_create::?relay
     185  FR_del_header
       6  FR_del_header::?relay
      14  FR_delete
       6  FR_delete::?relay
      14  FR_find_rx
       6  FR_find_rx::?relay
      14  FR_find_tx
       6  FR_find_tx::?relay
      14  FR_is_rx
       6  FR_is_rx::?relay
      14  FR_is_tx
       6  FR_is_tx::?relay
      14  FR_restart
       6  FR_restart::?relay
      14  FR_rx_available
       6  FR_rx_available::?relay
      14  FR_rx_frames
       6  FR_rx_frames::?relay
      14  FR_set_rx
       6  FR_set_rx::?relay
      14  FR_set_tx
       6  FR_set_tx::?relay
      14  FR_tx_available
       6  FR_tx_available::?relay
      14  FR_tx_frames
       6  FR_tx_frames::?relay
      20  GW_VECTOR
       8  HOT_MOD
     106  HP_Init
       6  HP_Init::?relay
      14  HP_ReInit
       6  HP_ReInit::?relay
      40  HP_callback
       6  HP_callback::?relay
       3  HW_Init
      17  HW_Init
      19  HW_Init
      23  HW_Init
      37  HW_Init
      44  HW_Init
      63  HW_Init
     409  HW_Init
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
      16  HW_MOD
       3  Hot_Start
      40  Hot_Start
      48  Hot_Start
      87  Hot_Start
       6  Hot_Start::?relay
       6  Hot_Start::?relay
       6  Hot_Start::?relay
       6  Hot_Start::?relay
     298  IPP_process
       6  IPP_process::?relay
     292  IP_Receive
       6  IP_Receive::?relay
     279  IP_Send
       6  IP_Send::?relay
      17  IRQEnable
       6  IRQEnable::?relay
      40  IRQ_Init
      52  IRQ_Init
       6  IRQ_Init::?relay
       6  IRQ_Init::?relay
       4  IRQ_MOD
       4  LAST_UPDATE_TIME_COMM_NODE
      10  LED_MODULE
      10  LLC_MODULE
     186  LLC_add_tx_frame
       6  LLC_add_tx_frame::?relay
     113  LLC_close_slot
       6  LLC_close_slot::?relay
     266  LLC_open_slot
       6  LLC_open_slot::?relay
      14  LLC_restart
       6  LLC_restart::?relay
      54  LoadTXData
       6  LoadTXData::?relay
      10  MAC_MODULE
     348  MAC_Receive
       6  MAC_Receive::?relay
     297  MAC_Send
       6  MAC_Send::?relay
       4  MAC_TIMER_MAX
      10  MD_MODULE
     116  MEM_memcpy
       6  MEM_memcpy::?relay
      60  MEM_memset
       6  MEM_memset::?relay
     200  MODEL
      10  MS_MODULE
      90  NB_TABLE
       1  NP_CMD_ENUM
      74  NP_Init
       6  NP_Init::?relay
     464  NP_Receive
       6  NP_Receive::?relay
     129  NP_TimeAlloc
       6  NP_TimeAlloc::?relay
      43  NeocoreReady
       6  NeocoreReady::?relay
      87  Neocore_start
       6  Neocore_start::?relay
       1  P0SEL
       1  P1DIR
       1  PCON
       1  PERCFG
      10  RADIO_MODULE
      70  REPEATED
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
      89  RI_Measure_POW
       6  RI_Measure_POW::?relay
     606  RI_Receive
       6  RI_Receive::?relay
     205  RI_Send
       6  RI_Send::?relay
     209  RI_Send_time
       6  RI_Send_time::?relay
     107  RI_SetChannel
       6  RI_SetChannel::?relay
     160  ROUTE_TABLE
      40  RP_Init
       6  RP_Init::?relay
      69  RP_Receive
       6  RP_Receive::?relay
      71  RP_Send
       6  RP_Send::?relay
     498  RP_SendRT_GW
       6  RP_SendRT_GW::?relay
     859  RP_SendRT_RT
       6  RP_SendRT_RT::?relay
     422  RP_Send_COMM
       6  RP_Send_COMM::?relay
     632  RP_Send_GW
       6  RP_Send_GW::?relay
      14  RP_TimeAlloc
       6  RP_TimeAlloc::?relay
      10  RTC_MODULE
     128  RXBUFF
      59  ReadTimer
       6  ReadTimer::?relay
     206  RecvData
       6  RecvData::?relay
       1  SLEEPCMD
       1  SLEEPSTA
    3060  SLOT_POOL
     116  SL_alloc
       6  SL_alloc::?relay
      99  SL_available
       6  SL_available::?relay
      90  SL_busy
       6  SL_busy::?relay
     153  SL_copy
       6  SL_copy::?relay
     133  SL_find_rx
       6  SL_find_rx::?relay
     133  SL_find_tx
       6  SL_find_tx::?relay
      93  SL_free
       6  SL_free::?relay
      24  SL_is_rx
       6  SL_is_rx::?relay
      24  SL_is_tx
       6  SL_is_tx::?relay
      99  SL_rx_available
       6  SL_rx_available::?relay
      56  SL_rx_slots
       6  SL_rx_slots::?relay
      64  SL_set_rx
       6  SL_set_rx::?relay
      64  SL_set_tx
       6  SL_set_tx::?relay
      99  SL_tx_available
       6  SL_tx_available::?relay
      56  SL_tx_slots
       6  SL_tx_slots::?relay
      72  SL_zone_check
       6  SL_zone_check::?relay
       1  ST0
       1  ST1
       1  ST2
       1  STLOAD
       3  SW_Init
       3  SW_Init
       3  SW_Init
       3  SW_Init
      52  SW_Init
      62  SW_Init
      83  SW_Init
     107  SW_Init
     132  SW_Init
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
      14  SW_MOD
      14  SW_restart
       6  SW_restart::?relay
      10  SYNC_MODULE
      71  SY_restart
       6  SY_restart::?relay
     243  SendData
       6  SendData::?relay
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
       3  TB_Receive
       6  TB_Receive::?relay
      68  TCP_Recive
       6  TCP_Recive::?relay
      94  TM_ClrAlarm
       6  TM_ClrAlarm::?relay
     110  TM_IRQ
       6  TM_IRQ::?relay
      91  TM_SetAlarm
       6  TM_SetAlarm::?relay
       2  TOFFSET
      37  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
     309  UDP_Recive
       6  UDP_Recive::?relay
     420  UDP_Send
       6  UDP_Send::?relay
     156  UDP_bind_port
       6  UDP_bind_port::?relay
      10  UST_MODULE
     194  UST_delay
       6  UST_delay::?relay
     141  UST_interval
       6  UST_interval::?relay
      79  UST_now
       6  UST_now::?relay
      78  UST_time_over
       6  UST_time_over::?relay
      44  UnLoadRXData
       6  UnLoadRXData::?relay
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P1
       4  __Constant_1
       4  __Constant_19833891
       4  __Constant_1e
       4  __Constant_1f4
       4  __Constant_1f40
       4  __Constant_20
       4  __Constant_384
       4  __Constant_396
       4  __Constant_3c
       4  __Constant_3d
       4  __Constant_5
       4  __Constant_5dc
       4  __Constant_6
       4  __Constant_78
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_9c4
       4  __Constant_a
       4  __Constant_f4240
       4  __Constant_ffff8000
       4  __Constant_ffffc180
       4  __Constant_ffffff
       7  __cli
       7  __cli
       7  __cli
       6  __cli::?relay
       6  __cli::?relay
       6  __cli::?relay
      34  _clr_all
       6  _clr_all::?relay
      50  _find_next_active
       6  _find_next_active::?relay
      46  _free
       6  _free::?relay
      18  _inc_timeslot
       6  _inc_timeslot::?relay
     127  _interval
       6  _interval::?relay
     433  _recv_ack
       6  _recv_ack::?relay
      93  _recv_frame
       6  _recv_frame::?relay
     253  _send_ack
       6  _send_ack::?relay
     130  _send_frame
       6  _send_frame::?relay
      52  _throw_dice
       6  _throw_dice::?relay
      27  accept_sync_data
       6  accept_sync_data::?relay
    1228  add_card
       6  add_card::?relay
     493  analyse_route_table
       6  analyse_route_table::?relay
     455  analyse_table
       6  analyse_table::?relay
      34  bits_count
       6  bits_count::?relay
     162  buf
     183  calcCompareTime
       6  calcCompareTime::?relay
      45  calc_xor
       6  calc_xor::?relay
     798  comm_node_choise
       6  comm_node_choise::?relay
     283  comm_node_info
       6  comm_node_info::?relay
      16  default_iv
      16  default_key
     148  energy_scan
       6  energy_scan::?relay
     352  eth_send
       6  eth_send::?relay
      76  ethernet_process
       6  ethernet_process::?relay
     111  fill_meta
       6  fill_meta::?relay
     151  fill_meta_data
       6  fill_meta_data::?relay
      80  find_free
       6  find_free::?relay
     594  find_node
       6  find_node::?relay
      82  frame_filter
     464  frame_filter
       6  frame_filter::?relay
       6  frame_filter::?relay
      81  free_index
       6  free_index::?relay
     226  generateAuthData
       6  generateAuthData::?relay
      53  getRNDByte
       6  getRNDByte::?relay
     319  get_AUTH_NODE_REQ
       6  get_AUTH_NODE_REQ::?relay
     137  index_by_addr
       6  index_by_addr::?relay
      26  init
       6  init::?relay
       5  isIRQEnable
       6  isIRQEnable::?relay
      78  is_free
       6  is_free::?relay
     716  is_repeated_frame
       6  is_repeated_frame::?relay
       4  last
       4  last_analyse_time
       4  last_analyse_time
       4  last_card_req_time
       4  last_card_send_time
       4  last_request
       4  last_send
      70  loadTimerCompare
       6  loadTimerCompare::?relay
      55  mac_cmp
       6  mac_cmp::?relay
     159  main
       6  main::?relay
       9  mcu_sleep
       6  mcu_sleep::?relay
      72  mem_move
       6  mem_move::?relay
     152  mode_1_process
       6  mode_1_process::?relay
     119  mode_1_receive_process
       6  mode_1_receive_process::?relay
      43  mode_1_retransmition_process
       6  mode_1_retransmition_process::?relay
      64  mode_2_process
       6  mode_2_process::?relay
     236  network_recv_sync
       6  network_recv_sync::?relay
     350  network_sync
       6  network_sync::?relay
      46  parse_frame
       6  parse_frame::?relay
     125  periodic_card_send
       6  periodic_card_send::?relay
      27  pre_config
       6  pre_config::?relay
      10  putchar
      74  random_core_init
       6  random_core_init::?relay
      49  readRandom
       6  readRandom::?relay
      54  receive
       6  receive::?relay
     743  receiveCMD_Request
       6  receiveCMD_Request::?relay
     570  receiveCMD_Response
       6  receiveCMD_Response::?relay
     243  recv_sync
       6  recv_sync::?relay
     419  request_cards
       6  request_cards::?relay
       4  ret_val
       1  retransmite
     189  route_find
       6  route_find::?relay
     127  route_find_by_fsrc
       6  route_find_by_fsrc::?relay
     387  route_update
       6  route_update::?relay
       1  scan_channel
     135  scheduler_rx
       6  scheduler_rx::?relay
     277  scheduler_tx
       6  scheduler_tx::?relay
      57  scheulder_next_alarm
       6  scheulder_next_alarm::?relay
     180  send_ip_frame
       6  send_ip_frame::?relay
     342  send_node_card
       6  send_node_card::?relay
     371  send_sync
       6  send_sync::?relay
     117  setFreq
       6  setFreq::?relay
     148  setNodeCHTS
       6  setNodeCHTS::?relay
      19  setUserTimeAllocation
       6  setUserTimeAllocation::?relay
     639  set_AUTH_NODE_RESP
       6  set_AUTH_NODE_RESP::?relay
       2  slot_busy
       2  slot_rx_cnt
       2  slot_tx_cnt
      80  stack_init
       6  stack_init::?relay
      46  start_mode_1
       6  start_mode_1::?relay
      17  start_mode_2
       6  start_mode_2::?relay
      83  syncronize_timer
       6  syncronize_timer::?relay
       4  time
     470  transmite
       6  transmite::?relay
      22  uart_init
       6  uart_init::?relay
       2  userTimeAllocation
      19  user_time_alloc
       6  user_time_alloc::?relay
       4  val
      59  validate_sync
       6  validate_sync::?relay
      60  vtimer_expired
       6  vtimer_expired::?relay
      36  vtimer_set
       6  vtimer_set::?relay
      23  vtimer_start
       6  vtimer_start::?relay
      51  xor_calc
       6  xor_calc::?relay
    1019  -- Other

 
 35 251 bytes in segment BANKED_CODE
  1 374 bytes in segment BANK_RELAYS
  4 784 bytes in segment CODE_C
      3 bytes in segment INTVEC
     47 bytes in segment NEAR_CODE
     35 bytes in segment SFR_AN
    231 bytes in segment XDATA_I
    231 bytes in segment XDATA_ID
  4 508 bytes in segment XDATA_Z
 
  6 348 bytes of CODE     memory (+ 91 bytes shared)
      0 bytes of DATA     memory (+ 35 bytes shared)
 35 251 bytes of HUGECODE memory
  4 739 bytes of XDATA    memory

Errors: none
Warnings: 9
