###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               24/Apr/2020  17:42:26
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  code
#    Dptr setup         =  1,16
#                          
#    Source file        =  E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EWC70D.tmp
#        (E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c -lc
#        "E:\Neocore\Hardware\PRG Node\Debug\List" -o "E:\Neocore\Hardware\PRG
#        Node\Debug\Obj" -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=code --nr_virtual_regs 8 --no_path_in_file_macros -I
#        E:\Neocore\Hardware\Stack_core_src\ -On --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_cross_call --mfc
#        E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c
#        "E:\Neocore\Hardware\PRG Node\auth.c" "E:\Neocore\Hardware\PRG
#        Node\auth_eth.c" "E:\Neocore\Hardware\PRG Node\balancer.c"
#        E:\Neocore\Hardware\STACK_CORE_SRC\coder.c
#        E:\Neocore\Hardware\Stack_core_src\config.c "E:\Neocore\Hardware\PRG
#        Node\controller.c" E:\Neocore\Hardware\Stack_core_src\cpu.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\debug.c
#        E:\Neocore\Hardware\Stack_core_src\dma.c "E:\Neocore\Hardware\PRG
#        Node\ethernet.c" E:\Neocore\Hardware\STACK_CORE_SRC\frame.c
#        "E:\Neocore\Hardware\PRG Node\ip.c"
#        E:\Neocore\Hardware\Stack_core_src\led.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\llc.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\mac.c "E:\Neocore\Hardware\PRG
#        Node\main.c" E:\Neocore\Hardware\STACK_CORE_SRC\mem_slots.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\mem_utils.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\model.c "E:\Neocore\Hardware\PRG
#        Node\neigh.c" E:\Neocore\Hardware\STACK_CORE_SRC\radio.c
#        "E:\Neocore\Hardware\PRG Node\route.c"
#        E:\Neocore\Hardware\Stack_core_src\rtc.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\sync.c "E:\Neocore\Hardware\PRG
#        Node\tcp.c" E:\Neocore\Hardware\STACK_CORE_SRC\time_manager.c
#        "E:\Neocore\Hardware\PRG Node\udp.c"
#        E:\Neocore\Hardware\STACK_CORE_SRC\ustimer.c)
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        E:\Neocore\Hardware\PRG Node\Debug\List\action_manager.lst
#    Object file        =  
#        E:\Neocore\Hardware\PRG Node\Debug\Obj\action_manager.r51
#
###############################################################################

E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c
      1          #include "action_manager.h"
      2          #include "modules_list.h"
      3          #include "model.h"
      4          #include "debug.h"
      5          
      6          /**
      7          @file
      8          */
      9          
     10          /* Определения */
     11          #define ITEMS_COUNT(name) (sizeof(name)/sizeof(module_s*))
     12          #define RUNNER(array, fun) {\
     13          for (char i = 0; i < ITEMS_COUNT(array); i++){\
     14              ASSERT(array[i]->fun != NULL);\
     15              array[i]->fun();\
     16              }\
     17          };
     18          
     19          /* Локальные переменные */
     20          static module_s* COLD_MOD[] = COLD_MOD_DEF;
     21          static module_s* HOT_MOD[] = HOT_MOD_DEF;
     22          static module_s* HW_MOD[] = HW_MOD_DEF;
     23          static module_s* SW_MOD[] = SW_MOD_DEF;
     24          static module_s* IRQ_MOD[] = IRQ_MOD_DEF;
     25          
     26          static void (*CALLBACK)(void);
     27          
     28          void AM_set_callback(void (*fn)(void)){
     29            ASSERT(fn);
     30            CALLBACK = fn;
     31          }
     32          
     33          void AM_Callback(void){
     34            ASSERT(CALLBACK);
     35            CALLBACK();
     36          }
     37          
     38          void AM_Cold_start(void){
     39            RUNNER(COLD_MOD, Cold_Start);
     40          }
     41          
     42          void AM_Hot_start(void){
     43            RUNNER(HOT_MOD, Hot_Start);  
     44          }
     45          
     46          void AM_HW_Init(void){
     47            RUNNER(HW_MOD, HW_Init);      
     48          }
     49          
     50          void AM_SW_Init(void){
     51            RUNNER(SW_MOD, SW_Init);
     52          }
     53          
     54          void AM_IRQ_Init(void){
     55            RUNNER(IRQ_MOD, IRQ_Init);
     56          }
     57          
     58          
E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c
      1          #include "alarm_timer.h"
      2          #include "time_manager.h"
      3          #include "action_manager.h"
      4          #include "ioCC2530.h"
      5          #include "stdbool.h"
      6          #include "stdint.h"
      7          #include "debug.h"
      8          #include "cpu.h"
      9          
     10          /**
     11          @file
     12          */
     13          
     14          #define MAX_NWTIME (nwtime_t)32767
     15          
     16          static void HW_Init(void);  
     17          static inline void IRQEnable(bool state);
     18          static uint32_t ReadTimer(void);
     19          static inline bool isIRQEnable(void);
     20          static inline uint32_t calcCompareTime(nwtime_t time);
     21          static void loadTimerCompare(uint32_t ticks);
     22          
     23          module_s AT_MODULE = {ALIAS(HW_Init)};
     24          static nwtime_t TOFFSET; 
     25          static uint32_t COMPARE_TIME; //!< Значение в регистре compare
     26          
     27          
     28          static void HW_Init(void){
     29            TOFFSET = 0;
     30            COMPARE_TIME = 0;
     31            IRQEnable(false);
     32          };
     33          
     34          static void SW_Init(void){
     35            TOFFSET = 0;
     36            COMPARE_TIME = 0;
     37            IRQEnable(false);
     38          }; 
     39          
     40          void AT_enable(bool state){
     41            ATOMIC_BLOCK_RESTORE{
     42              IRQEnable(state);
     43            }
     44          };
     45          
     46          nwtime_t AT_interval(nwtime_t beg, nwtime_t end){
     47            return (beg > end) ? (beg - end) : (MAX_NWTIME - beg + end);
     48          }
     49          
     50          void AT_set_time(nwtime_t time){
     51            ASSERT(time <= MAX_NWTIME);
     52            nwtime_t timer = ReadTimer();
     53            TOFFSET = time - timer;
     54            TOFFSET &= 0x7FFF;
     55            // После установки времени нужно изменить compare time в таймере
     56            // Но только в случаи если прерывание активно
     57            if (isIRQEnable())
     58              AT_set_alarm(COMPARE_TIME);
     59          }
     60          
     61          nwtime_t AT_time(void){
     62            uint32_t val = ReadTimer();
     63            // TOFFSET = NETWORK TIME - TIMER
     64            // NETWORK TIME = TIMER + TOFFSET
     65            val +=TOFFSET;
     66            val &= 0x7FFF; // Приводим значения таймера к 0-32767
     67            return val;
     68          }
     69          
     70          /**
     71          @brief Ждем наступления определенного момента времени
     72          */
     73          void AT_wait(nwtime_t time){
     74            ASSERT(time <= MAX_NWTIME);  
     75            static union 
     76            {
     77              uint32_t val;
     78              uint8_t fild[4];
     79            } val;
     80            val.val = 0;
     81            // TOFFSET = NETWORK TIME - TIMER
     82            // NETWORK TIME = TIMER + TOFFSET
     83            // Ждем синхронизацию таймера после пробуждения
     84            while (!(SLEEPSTA & 0x01));
     85            do{
     86              // Соблюдаем порядок чтения регисторов ST  
     87              val.fild[0] = ST0;
     88              val.fild[1] = ST1;
     89              val.fild[2] = ST2;
     90              val.val +=TOFFSET;
     91              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
     92            } while (val.val < time);
     93          }
     94          
     95          /**
     96          @brief Разрешение прерываний таймера сна
     97          @params[in] state = true - разрешить обработку прерываний
     98          */
     99          static inline void IRQEnable(bool state){
    100            if (state)
    101              STIE = 1;
    102            else
    103              STIE = 0;
    104          }
    105          
    106          /**
    107          @brief Устанавливает время прерывания
    108          @details Время прерывания устанавливается относительно времени сети
    109          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    110          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    111          @params[in] ticks время сети в тиках когда нужно проснуться
    112          */
    113          void AT_set_alarm(nwtime_t alarm){
    114            ASSERT(alarm <= MAX_NWTIME);
    115            COMPARE_TIME = alarm; // Сохраняем установленное значение
    116            uint32_t compare_time = calcCompareTime(alarm);
    117            loadTimerCompare(compare_time);
    118            IRQEnable(true);
    119          }
    120          
    121          /**
    122          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    123          @params[in] time время сети в тикак
    124          */
    125          static inline uint32_t calcCompareTime(nwtime_t time){   
    126              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    127              //NETWORK TIME = TIMER + TOFFSET  
    128              // Приводим такты к тактам таймера
    129              uint16_t ticks_offset = (time - TOFFSET) & 0x7FFF;
    130              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    131              cmp_time |= ticks_offset; // Вычисляем новое время
    132              if (cmp_time <= timer){
    133                cmp_time += 0x8000;
    134                cmp_time &=0xFFFFFF;
    135              }
    136               LOG_OFF("Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    137                    timer, ticks, cmp_time );
    138              return cmp_time;
    139          }
    140          
    141          /**
    142          @brief Возвращает текущее значение таймера
    143          @return Текущие ticks
    144          */
    145          static uint32_t ReadTimer(void){
    146            static union 
    147            {
    148              uint32_t val;
    149              uint8_t fild[4];
    150            } ret_val;
    151            ret_val.val = 0;
    152            // Ждем синхронизацию таймера после пробуждения
    153            while (!(SLEEPSTA & 0x01));
    154            // Соблюдаем порядок чтения регисторов ST  
    155            ret_val.fild[0] = ST0;
    156            ret_val.fild[1] = ST1;
    157            ret_val.fild[2] = ST2;
    158            return ret_val.val;
    159          }
    160          
    161          /**
    162          @brief Устанавливает время пробуждения микроконтролера
    163          @params[in] ticks 24 битное значение времени пробуждения в ticks
    164          */
    165          static void loadTimerCompare(uint32_t ticks){
    166            union 
    167            {
    168              uint32_t val;
    169              uint8_t fild[4];
    170            } value;
    171            value.val = ticks;
    172            // Ждем разрешения на запись нового значения
    173            while (!(STLOAD & 0x01));
    174            // Регистр ST0 должен быть записан в последнию очередь
    175            ST2 = value.fild[2];
    176            ST1 = value.fild[1];
    177            ST0 = value.fild[0];
    178          }
    179          
    180          /**
    181          @brief Проверка активности прерывания таймера
    182          @return true если прерывание установленно
    183          */
    184          static inline bool isIRQEnable(void){
    185            return STIE;
    186          }
    187          
    188          /**
    189          @brief Обработчик прерывания таймера сна
    190          */
    191          #pragma vector=ST_VECTOR
    192          __interrupt void TimerCompareInterrupt(void){ 
    193            nwtime_t time = AT_time();
    194            // Отключаем прерывание таймера. Забота пользователя его включить
    195            IRQEnable(false); 
    196            TM_IRQ(time); // Передаем управление менеджеру времени
    197            STIF = 0; // Очищаем флаг прерывания
    198          }
E:\Neocore\Hardware\PRG Node\auth_eth.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "frame.h"
      4          #include "ethernet.h"
      5          #include "protocol_defs.h"
      6          
      7          #define REQUEST_INTERVAL 30
      8          static unsigned long last_request = 0;
      9          
     10          static void AUTH_request();
     11          static void receiveCMD_Request(struct frame* frame);
     12          static void receiveCMD_Response(struct frame* frame);
     13          
     14          enum AUTH_ETH_TYPES {AUTH_CMD_REQ = 0, AUTH_CMD_RESP = 1};
     15          
     16          struct AUTH_ETH_REQ{
     17            char mac[8]; // Кто делает запрос
     18            char node_type;
     19            char node_ver;
     20            char sensor_types[7];
     21            char sensor_channels[7];
     22          } __attribute__((packed));
     23          
     24          struct AUTH_ETH_RESP{
     25            char mac[8]; // Для кого предназначен ответ
     26            bool access;
     27            unsigned int ipaddr;
     28            char param[16];
     29          } __attribute__((packed));
     30          
     31          void AUTH_ETH_Receive(struct frame *frame){
     32            LOG_ON("AUTH_ETH receive frame");
     33            // Проверим пакет.
     34            // Мы можем получить пакет REQ или RESP
     35            // Нужно типы пакетов разделить по нормальному а не cmd
     36            // Для этого первым байтом делаем тип команды/данных а потом
     37            // отрезаем от фрейма
     38            
     39            bool filter_rule = (frame->meta.TS == 1) &&
     40                               (frame->meta.NDST == 0xffff) &&
     41                               (frame->len > 0);  
     42            if (!filter_rule){
     43              LOG_ON("AUTH_ETH frame filltered");
     44              return;
     45            }
     46            
     47            char cmd = frame->payload[0];
     48            bool res = FR_del_header(frame, 1);
     49            ASSERT(res);
     50            
     51            switch(cmd){
     52              case AUTH_CMD_REQ :
     53                // TODO обработка приема
     54                receiveCMD_Request(frame);
     55                break;
     56            case AUTH_CMD_RESP:
     57                // TODO обработка приема 
     58                receiveCMD_Response(frame);
     59                break;
     60            default:
     61              LOG_ON("Unrecognized cmd");
     62              break;
     63            };
     64          };
     65          
     66          /** brief Обработка ответа об авторизации
     67          * Ответ принимается если узел еще не авторизован и пакет
     68          * предназначени этому узлу
     69          */
     70          static void receiveCMD_Response(struct frame* frame){
     71            LOG_ON("AUTH_ETH Response");
     72            if (MODEL.AUTH.auth_ok == true)
     73              return;  
     74            
     75            if (frame-> len != sizeof(struct AUTH_ETH_RESP)){
     76              LOG_ON("Frame AUTH_ETH_RESP wrong size");
     77              return;
     78            };
     79            LOG_ON("Extract response");
     80            struct AUTH_ETH_RESP *resp = (struct AUTH_ETH_RESP*)frame->payload;
     81            
     82            // Проверим что пакет для нас. Должны совпадать мак адресса
     83            bool mac_eq = true;
     84            for (char i = 0; i < 8; i++)
     85              if (resp->mac[i] != MODEL.node_mac[i]){
     86                mac_eq = false;
     87                break;
     88              };
     89            
     90            if (!mac_eq){
     91              LOG_ON("AUTH_ETH request filtered by mac");
     92              return;
     93            }
     94            
     95            MODEL.AUTH.auth_ok = true;
     96            // Пакет для нас. Проверим доступ
     97            if (!resp->access){
     98              LOG_ON("Access depricated");
     99              MODEL.AUTH.access_ok = false;
    100              return;
    101            };
    102            
    103            MODEL.AUTH.access_ok = true;
    104            
    105            for (char i = 0; i < 16 ; i++)
    106              MODEL.node_param[i] = resp->param[i];
    107            
    108            MODEL.node_adr = resp->ipaddr;
    109            LOG_ON("Node auth ok! ipaddr=%d", MODEL.node_adr);
    110          };
    111          
    112          /** brief Обработка запроса авторизации
    113          * Запрос обрабатывается если данный узел авторизован  
    114          */
    115          static void receiveCMD_Request(struct frame* frame){
    116            if (MODEL.AUTH.auth_ok == false)
    117              return;
    118            
    119            // TODO Сохранить запрос в таблице и добавить геттер запросов.
    120            // Авторизация уровня IP будет опрашивать таблицу и
    121            // общаться со шлюзом по этому вопросу.
    122            LOG_ON("AUTH REQ received and droped");
    123          };
    124          
    125          void AUTH_ETH_TimeAlloc(){
    126             // Выходим если узел авторизован
    127            if (MODEL.AUTH.auth_ok == true)
    128               return;
    129            
    130             AUTH_request(); 
    131          };
    132          
    133          static void AUTH_request(){
    134            // Еще не наступло время передачи запроса
    135            if ((MODEL.RTC.uptime - last_request) < REQUEST_INTERVAL)
    136              return;
    137            // Обновляем время
    138            last_request = MODEL.RTC.uptime;
    139            
    140            // Создаем запрос
    141            struct frame* frame = FR_create();
    142            struct AUTH_ETH_REQ req;
    143            for (int i = 0; i < 8; i++)
    144              req.mac[i] = MODEL.node_mac[i];
    145            
    146            req.node_type = NODE_TYPE;
    147            req.node_ver = NODE_VER;
    148          
    149            bool res;
    150            res = FR_add_header(frame, &req, sizeof(struct AUTH_ETH_REQ));
    151            ASSERT(res);
    152            char cmd = AUTH_CMD_REQ;
    153            res = FR_add_header(frame, &cmd, sizeof(cmd));
    154            ASSERT(res);
    155            
    156            frame->meta.TS = 1;
    157            frame->meta.CH = MODEL.SYNC.sys_channel;
    158            frame->meta.PID = PID_AUTH;
    159            frame->meta.NDST = 0xffff;
    160            frame->meta.NSRC = 0;
    161           
    162            eth_send(frame); 
    163            LOG_ON("AUTH req add to tx");
    164          };
E:\Neocore\Hardware\PRG Node\balancer.c
      1          #include "model.h"
      2          #include "debug.h"
      3          
      4          void TB_Receive(struct frame *frame){
      5          }
E:\Neocore\Hardware\STACK_CORE_SRC\coder.c
      1          #include "coder.h"
      2          #include "ioCC2530.h"
      3          #include "string.h"
      4          #include "ustimer.h" // Для профилирования, Отладка
      5          #include "dma.h"
      6          #include "action_manager.h"
      7          #include "model.h"
      8          #include "mem_utils.h"
      9          
     10          static void HW_Init(void);
     11          module_s CODER_MODULE = {ALIAS(HW_Init)};
     12          
     13          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     14          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     15          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     16          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     17          
     18          #define BV(n)                   (1 << (n))
     19          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     20          
     21          // Режимы шифрования
     22          #define AES_MODE_CBC            0x00
     23          #define AES_MODE_CFB            0x10
     24          #define AES_MODE_OFB            0x20
     25          #define AES_MODE_CTR            0x30
     26          #define AES_MODE_ECB            0x40
     27          #define AES_MODE_CBCMAC         0x50
     28          
     29          // Операции 
     30          #define AES_ENCRYPT             0x00
     31          #define AES_DECRYPT             0x02
     32          #define AES_LOAD_KEY            0x04
     33          #define AES_LOAD_IV             0x06
     34          
     35          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     36          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     37          
     38          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     39          
     40          
     41          // Приватные функции
     42          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     43                                                 uint8_t f, uint8_t lm);
     44          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     45          
     46          /**
     47          @brief Локальный буфер для работы режима CCM
     48          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     49           16 длина дополнения нулями
     50          */
     51          static uint8_t buf[128+18+16]; 
     52          
     53          
     54          typedef struct //!< Структура блока B0 для режима CCM
     55          {
     56            struct 
     57            {
     58              uint8_t L:3;
     59              uint8_t M:3;
     60              uint8_t A_Data:1;
     61            } flag;
     62            uint16_t nonce[9];
     63            uint8_t L_M[6];
     64          } __attribute__((packed)) B0_s;
     65          
     66          typedef struct //!< Структура блока A0 для режима CCM
     67          {
     68            struct 
     69            {
     70              uint8_t L:3;
     71            } flag;
     72            uint8_t nonce[11];
     73            uint8_t ctr;
     74          } __attribute__((packed)) A0_s;
     75          
     76          
     77          
     78          /**
     79          @brief Иницилизация модуля
     80          @detail Модуль использует DMA каналы 0 и 1
     81          */
     82          void HW_Init(void)
     83          {
     84            char STREAM_KEY[16] = DEFAULT_STREAM_KEY;
     85            char STREAM_IV[16] = DEFAULT_STREAM_IV;
     86            char CCM_KEY[16] = DEFAULT_CCM_KEY;
     87            char CCM_IV[16] = DEFAULT_CCM_IV;
     88            MEMCPY(MODEL.AES.STREAM_KEY, STREAM_KEY, 16);
     89            MEMCPY(MODEL.AES.STREAM_IV, STREAM_IV, 16);
     90            MEMCPY(MODEL.AES.CCM_KEY, CCM_KEY, 16);
     91            MEMCPY(MODEL.AES.CCM_IV, CCM_IV, 16);
     92            
     93            //DMA_AES_s DMA_CH[0]; //!< DMA на запись будет DMA[0]
     94            //DMA_AES_s DMA_CH[1]; //!< DMA на чтение DMA_CH[1]
     95            
     96            ST_DEF(DMA_CH[0], DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
     97            ST_DEF(DMA_CH[0], DSTADDRL, 0xB1); //  
     98            ST_DEF(DMA_CH[0], PRIORITY, 0x00); // Низкий приоритет
     99            ST_DEF(DMA_CH[0], M8, 0x00); // Используем 8 бит для счетика длинны
    100            ST_DEF(DMA_CH[0], IRQMASK, 0x00); // Запрещаем генерировать перывания
    101            ST_DEF(DMA_CH[0], DESTINC, 0x00); // Не увеличиваем адресс назначения
    102            ST_DEF(DMA_CH[0], SRCINC, 0x01); // Увеличиваем адресс источника
    103            ST_DEF(DMA_CH[0], TRIG, ENC_DW); // Тригер по загрузке
    104            ST_DEF(DMA_CH[0], WORDSIZE, 0x00); // Копируем по 1 байту
    105            ST_DEF(DMA_CH[0], TMODE, 0x01); //  Блочное копирование по тригеру
    106            ST_DEF(DMA_CH[0], VLEN, 0x00); //  Количество байт определяет поле LEN  
    107            ST_DEF(DMA_CH[0], LENH, 0x00); 
    108            
    109            ST_DEF(DMA_CH[1], SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    110            ST_DEF(DMA_CH[1], SRCADDRL, 0xB2);  
    111            ST_DEF(DMA_CH[1], PRIORITY, 0x00); // Низкий приоритет
    112            ST_DEF(DMA_CH[1], M8, 0x00); // Используем 8 бит для счетика длинны
    113            ST_DEF(DMA_CH[1], IRQMASK, 0x00); // Запрещаем генерировать перывания
    114            ST_DEF(DMA_CH[1], DESTINC, 0x01); // Увеличиваем адресс назначения
    115            ST_DEF(DMA_CH[1], SRCINC, 0x00); // Не увеличиваем адресс источника
    116            ST_DEF(DMA_CH[1], TRIG, ENC_UP); // Тригер по выгрузке
    117            ST_DEF(DMA_CH[1], WORDSIZE, 0x00); // Копируем по 1 байту
    118            ST_DEF(DMA_CH[1], TMODE, 0x01); //  Блочное копирование по тригеру
    119            ST_DEF(DMA_CH[1], VLEN, 0x00); //  Количество байт определяет поле LEN  
    120            ST_DEF(DMA_CH[1], LENH, 0x00); 
    121          }
    122          
    123          /**
    124          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    125          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    126          @param[in] src Указатель на данные подлежащии шифрованию
    127          @param[in] dst Указтель куда будут помещены зашифрованные данные
    128          @param[in] key Указатье на ключ. 16 байт
    129          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    130          @param[in] len Длинна данных
    131          */
    132          void AES_StreamCoder(bool enc_mode, char *src, char *dst, uint8_t len)
    133          {
    134            // Установим метод кодироваения
    135            AES_SET_MODE(STREAM_ENC_MODE);
    136            uint8_t *key = (uint8_t*)MODEL.AES.STREAM_KEY;  
    137            uint8_t *iv = (uint8_t*)MODEL.AES.STREAM_IV; 
    138            // Загружаем ключ
    139            AES_SET_OPERATION(AES_LOAD_KEY);
    140            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    141            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    142            ST_DEF(DMA_CH[0], LENL, 16);
    143            DMAARM |= 0x01;
    144            while(!AES_RDY());
    145            AES_START();
    146            while (DMAARM&0x01);
    147          
    148            // Загружаем IV
    149            AES_SET_OPERATION(AES_LOAD_IV);
    150            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    151            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    152            ST_DEF(DMA_CH[0], LENL, 16);
    153            DMAARM |= 0x01;
    154            while(!AES_RDY());
    155            AES_START();
    156            while (DMAARM&0x01);
    157          
    158            // Установим необходимую операцию AES
    159            if (enc_mode) 
    160              AES_SET_OPERATION(AES_ENCRYPT)
    161            else 
    162              AES_SET_OPERATION(AES_DECRYPT)
    163            
    164            switch(STREAM_ENC_MODE) 
    165            {
    166            case AES_MODE_ECB: // ECB, CBC не реализованы
    167            case AES_MODE_CBC:
    168              break;
    169            case AES_MODE_CFB:
    170            case AES_MODE_OFB:
    171            case AES_MODE_CTR:
    172              {
    173                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    174                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    175                uint8_t ptr, sub_ptr; // Смещение
    176                char *download, *upload;
    177                
    178                // Для этих типов шифрования длина блоков по 4 байта
    179                ST_DEF(DMA_CH[0], LENL, 4);
    180                ST_DEF(DMA_CH[1], LENL, 4);
    181                
    182                // Шифруем все целые блоки
    183                for (uint8_t block = 0; block < nbrBlocks; block ++)
    184                {
    185                  ptr = 16 * block;
    186                  while(!AES_RDY());
    187                  AES_START();
    188                  for (uint8_t j = 0; j < 4; j++)
    189                  {
    190                    sub_ptr = ptr + 4*j;
    191                    download = &src[sub_ptr];
    192                    upload = &dst[sub_ptr];
    193                    // Указываем адресс DMA откуда читать данные
    194                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    195                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    196                    // Указываем адрес DMA куда записывать данные          
    197                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    198                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    199                    // Активируем DMA
    200                    DMAARM |= 0x03;  
    201                    DMAREQ |= 0x01;
    202                    while (DMAARM&0x03);          
    203                  }
    204                }     
    205                // Шифруем последний блок
    206                uint8_t block_len = len % 16; // Размер последнего блока
    207                
    208                // Завершаем работу если блок пустой
    209                if (!block_len)
    210                  return;
    211                
    212                char padding_block[16]; // Блок заполненый нулями
    213                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    214                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    215                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    216                
    217                while(!AES_RDY());
    218                AES_START();
    219                for (uint8_t j = 0; j < 4; j++)
    220                  {
    221                    sub_ptr = 4*j;
    222                    download = &padding_block[sub_ptr];
    223                    // Указываем адресс DMA откуда читать данные
    224                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    225                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    226                    // Указываем аддрес DMA куда записывать данные          
    227                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    228                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    229                    // Активируем DMA
    230                    DMAARM |= 0x03;  
    231                    DMAREQ |= 0x01;
    232                    while (DMAARM&0x03);
    233                  }
    234                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    235                
    236              } //CASE
    237              
    238              break;
    239            } 
    240          }
    241          
    242          /**
    243          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    244          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    245          @param[in] src Указатель на данные подлежащии шифрованию
    246          @param[in] dst Указтель куда будут помещены зашифрованные данные
    247          @param[in] key Указатье на ключ. 16 байт
    248          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    249          @param[in] len Длинна данных
    250          */
    251          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    252                                   uint8_t *iv, uint8_t len)
    253          {
    254            // Установим метод кодироваения
    255            AES_SET_MODE(AES_MODE_CTR);
    256            
    257            // Загружаем ключ
    258            AES_SET_OPERATION(AES_LOAD_KEY);
    259            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    260            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    261            ST_DEF(DMA_CH[0], LENL, 16);
    262            DMAARM |= 0x01;
    263            while(!AES_RDY());
    264            AES_START();
    265            while (DMAARM&0x01);
    266          
    267            // Загружаем IV
    268            AES_SET_OPERATION(AES_LOAD_IV);
    269            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    270            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    271            ST_DEF(DMA_CH[0], LENL, 16);
    272            DMAARM |= 0x01;
    273            while(!AES_RDY());
    274            AES_START();
    275            while (DMAARM&0x01);
    276          
    277            // Установим необходимую операцию AES
    278            if (enc_mode) 
    279              AES_SET_OPERATION(AES_ENCRYPT)
    280            else 
    281              AES_SET_OPERATION(AES_DECRYPT)
    282            
    283            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    284            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    285            uint8_t ptr, sub_ptr; // Смещение
    286            uint8_t *download, *upload;
    287                
    288            // Для этих типов шифрования длина блоков по 4 байта
    289            ST_DEF(DMA_CH[0], LENL, 4);
    290            ST_DEF(DMA_CH[1], LENL, 4);
    291                
    292            // Шифруем все целые блоки
    293            for (uint8_t block = 0; block < nbrBlocks; block ++)
    294              {
    295                ptr = 16 * block;
    296                while(!AES_RDY());
    297                AES_START();
    298                for (uint8_t j = 0; j < 4; j++)
    299                  {
    300                    sub_ptr = ptr + 4*j;
    301                    download = &src[sub_ptr];
    302                    upload = &dst[sub_ptr];
    303                    // Указываем адресс DMA откуда читать данные
    304                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    305                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    306                    // Указываем адрес DMA куда записывать данные          
    307                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    308                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    309                    // Активируем DMA
    310                    DMAARM |= 0x03;  
    311                    DMAREQ |= 0x01;
    312                    while (DMAARM&0x03);          
    313                  }
    314              }     
    315              // Шифруем последний блок
    316              uint8_t block_len = len % 16; // Размер последнего блока
    317                
    318              // Завершаем работу если блок пустой
    319              if (!block_len)
    320                return;
    321                
    322              uint8_t padding_block[16]; // Блок заполненый нулями
    323              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    324              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    325              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    326              
    327              while(!AES_RDY());
    328              AES_START();
    329              for (uint8_t j = 0; j < 4; j++)
    330                {
    331                  sub_ptr = 4*j;
    332                  download = &padding_block[sub_ptr];
    333                  // Указываем адресс DMA откуда читать данные
    334                  ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    335                  ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    336                  // Указываем аддрес DMA куда записывать данные          
    337                  ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    338                  ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    339                  // Активируем DMA
    340                  DMAARM |= 0x03;  
    341                  DMAREQ |= 0x01;
    342                  while (DMAARM&0x03);
    343                }
    344              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    345          }
    346          
    347          /**
    348          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    349          @param[in] len улинна последовательности для вычисления MAC
    350          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    351          */
    352          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    353          {
    354            uint8_t IV[16];
    355            
    356            // Заполняем вектор нулями
    357            memset(IV, 0x00, sizeof(IV));
    358            
    359            // Установим метод кодироваения
    360            AES_SET_MODE(AES_MODE_CBCMAC);  
    361            
    362            { // Сворачиваем код для улучшения чтения
    363            // Загружаем ключ
    364            AES_SET_OPERATION(AES_LOAD_KEY);
    365            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    366            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    367            ST_DEF(DMA_CH[0], LENL, 16);
    368            DMAARM |= 0x01;
    369            while(!AES_RDY());
    370            AES_START();
    371            while (DMAARM&0x01);
    372          
    373            // Загружаем IV
    374            AES_SET_OPERATION(AES_LOAD_IV);
    375            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(IV));
    376            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(IV));
    377            ST_DEF(DMA_CH[0], LENL, 16);
    378            DMAARM |= 0x01;
    379            while(!AES_RDY());
    380            AES_START();
    381            while (DMAARM&0x01);
    382            };
    383            
    384            // Устанавливаем операцию шифрования
    385            AES_SET_OPERATION(AES_ENCRYPT);
    386            
    387            // Загрузка блоками по 128 бит
    388            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    389            uint8_t block_len = len % 16; // Размер последнего блока
    390            uint8_t ptr; // Смещение
    391                
    392            // Для этого типа шифрования длина блоков по 16 байт
    393            ST_DEF(DMA_CH[0], LENL, 16);
    394            // Устанавливаем куда будем выгружать вычисленный MAC
    395            ST_DEF(DMA_CH[1], DSTADDRL, LADDR(mac));
    396            ST_DEF(DMA_CH[1], DSTADDRH, HADDR(mac));
    397            ST_DEF(DMA_CH[1], LENL, 16);
    398            
    399            // Шифруем все целые блоки
    400            for (uint8_t block = 0; block < nbrBlocks; block ++)
    401              {
    402                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    403                // кратного 16 байтам.
    404                if (!block_len && (block == nbrBlocks - 1))
    405                  AES_SET_MODE(AES_MODE_CBC);
    406                    
    407                ptr = 16 * block;
    408                while(!AES_RDY());
    409                AES_START();
    410                // Указываем адресс DMA откуда читать данные
    411                ST_DEF(DMA_CH[0], SRCADDRL, LADDR(buf[ptr]));
    412                ST_DEF(DMA_CH[0], SRCADDRH, HADDR(buf[ptr]));
    413                // Активируем DMA
    414                DMAARM |= 0x01;  
    415                // Активируем выгрузку только последнего блока
    416                if (!block_len && (block == nbrBlocks - 1))
    417                  DMAARM |= 0x03;
    418                
    419                DMAREQ |= 0x01;
    420                while (DMAARM&0x03);          
    421               }
    422                 
    423            // Шифруем последний блок в режиме CBC
    424            AES_SET_MODE(AES_MODE_CBC);
    425                    
    426            // Завершаем работу если блок пустой
    427            if (!block_len)
    428              return;
    429                
    430            uint8_t padding_block[16]; // Блок заполненый нулями
    431            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    432            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    433            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    434                
    435            while(!AES_RDY());
    436            AES_START();
    437            // Указываем адресс DMA откуда читать данные
    438            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(padding_block));
    439            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(padding_block));
    440            // Активируем DMA и выгрузку MAC
    441            DMAARM |= 0x03;  
    442            DMAREQ |= 0x01;
    443            while (DMAARM&0x03);
    444          }
    445          
    446          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    447                                                 uint8_t f, uint8_t lm)
    448          {
    449            memcpy(buf, nonce,16);
    450            
    451            // Буфер от 0 до 15 байта специальный блок B0
    452            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    453            buf[0]=  0x01;  
    454            // Если есть данные для авторизации установим A_Data 
    455            if (f > 0)
    456              buf[0] |= 0x40;
    457            
    458            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    459            
    460            // Устанавливаем длинну сообщения
    461            buf[14] = 0x00;
    462            buf[15] = c;
    463            
    464            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    465            buf[16]= 0;
    466            buf[17]= f;
    467            
    468            // Копируем данные авторизации в буфер
    469            memcpy(&buf[18], src, f);
    470            
    471            // Смещение на следующий байт после данных авторизации.
    472            // Данные авторизации занимают положение в буфере [18, 18+f]
    473            uint8_t ptr_end= 18 + f;
    474            // Заполняем нулями до границы 16 байт  
    475            while (ptr_end & 0x0f)
    476              buf[ptr_end++] = 0x00;
    477            
    478            // Копируем данные для шифрования в буфер после нулей
    479            memcpy(&buf[ptr_end], &src[f], c);
    480            
    481            // Возвращаем размер данных в буфере
    482            return ptr_end+c;
    483          };
    484          
    485          /**
    486          @brief Шифрует/дешифрует данные с проверкой MIC
    487          @param[in] src Указатель на данные подлежащии шифрованию
    488          @param[in] len Размер данных
    489          @param[in] с Количество байт для шифрования
    490          @param[in] f Количество байт для авторизации
    491          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    492          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    493          @param[in] len Длинна данных
    494          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    495          */
    496          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m, uint8_t *MIC)
    497          {
    498            uint8_t *key = (uint8_t*)MODEL.AES.CCM_KEY;  
    499            uint8_t *nonce = (uint8_t*)MODEL.AES.CCM_IV; 
    500            uint8_t lm = MIC_2_MICLEN(m);
    501            
    502            // Генерируем данные для авторизации
    503            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    504            
    505            uint8_t mac[16]; // Сюда пишем мак
    506            CBCMAC_buf_encrypt(dlen, key, mac);
    507            
    508            // Шифруем MAC
    509            uint8_t CTR_IV[16];
    510            memcpy(CTR_IV, nonce, 16);
    511            CTR_IV[0] = 0x01; // Флаг режима CTR
    512            CTR_IV[15] = 0;   // Значение счетчика
    513            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    514            
    515            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    516            // dlen-c, dlen
    517            uint8_t ds = dlen - c; // Начало данных для шифрования
    518            
    519            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    520            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    521            CTR_IV[15] = 1; // Счетчик CTR
    522            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    523            
    524            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    525            // src[f, f+c] это шифрованные данные.
    526            memcpy(&src[f], &buf[ds], c); 
    527            memcpy(MIC, mac, lm);
    528            
    529            //https://github.com/zhaohengyi/CC2530Example/blob/
    530            //master/source/components/radios/cc2530/hal_rf_security.c
    531          }
    532          
    533          /**
    534          @brief Дешифрует данные с проверкой MIC
    535          @param[in] src Указатель на данные подлежащии шифрованию
    536          @param[in] len Размер данных
    537          @param[in] с Количество байт для шифрования
    538          @param[in] f Количество байт для авторизации
    539          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    540          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    541          @param[in] len Длинна данных
    542          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    543          */
    544          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m, uint8_t *MIC)
    545          {
    546            uint8_t *key = (uint8_t*)MODEL.AES.CCM_KEY;  
    547            uint8_t *nonce = (uint8_t*)MODEL.AES.CCM_IV;  
    548            uint8_t lm = MIC_2_MICLEN(m);
    549            
    550            // Расшифровываем MAC
    551            uint8_t mac[16]; // Расшифрованый мак
    552            uint8_t CTR_IV[16];
    553            memcpy(CTR_IV, nonce, 16);
    554            CTR_IV[0] = 0x01; // Флаг режима CTR
    555            CTR_IV[15] = 0;   // Значение счетчика
    556            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    557            
    558            // Генерируем данные для авторизации
    559            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    560            
    561            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    562            // dlen-c, dlen
    563            uint8_t ds = dlen - c; // Начало данных для дешифрования
    564            
    565            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    566            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    567            CTR_IV[15] = 1; // Счетчик CTR
    568            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    569            
    570            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    571            CBCMAC_buf_encrypt(dlen, key, new_mac);
    572            
    573            // Проверяем что маки совпадают, значит дешифровано верно
    574            bool mac_equal = true;
    575            for (uint8_t i = 0 ; i < lm ; i++)
    576            {
    577              if (mac[i] != new_mac[i])
    578              mac_equal = false;
    579              break;
    580            }
    581            
    582            // Выходим если MACи не совпали  
    583            if (!mac_equal)
    584              return false;
    585            
    586            // Копируем  расшифрованные данные
    587            memcpy(&src[f], &buf[ds], c); 
    588            return true;
    589          }
E:\Neocore\Hardware\Stack_core_src\config.c
      1          #include "stdint.h"
      2          #include "string.h"
      3          #include "stdbool.h"
      4          #include "string.h"
      5          #include "basic.h"
      6          #include "config.h"
      7          
      8          static uint8_t default_key[16] = DEFAULT_KEY;
      9          static uint8_t default_iv[16] = DEFAULT_IV;
     10          database_s CONFIG;
     11          
     12          
     13          void CF_init()
     14          {
     15            // Загрузка данных из различных источников
     16            memcpy(CONFIG.stream_key, default_key, 16); 
     17            memcpy(CONFIG.stream_iv,  default_iv, 16);
     18            CONFIG.node_ver = NODE_VER;
     19            CONFIG.node_type = NODE_TYPE;
     20            CONFIG.sync_channel = DEFAULT_SYNC_CHANNEL;
     21            CONFIG.sys_channel = DEFAULT_SYS_CHANNEL;
     22            CONFIG.tx_power = DEFAULT_TX_POWER;
     23            CONFIG.panid = DEFAULT_PANID;
     24          }
E:\Neocore\Hardware\PRG Node\controller.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "action_manager.h"
      4          #include "ethernet.h"
      5          
      6          static void HP_callback(void);
      7          
      8          void HP_Init(void){
      9              AM_set_callback(HP_callback);
     10          #warning Call other protocols init
                  ^
Warning[Pe1105]: #warning directive: Call other protocols init
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\controller.c"
     11          }
     12          
     13          static void HP_callback(void){
     14            ethernet_process();
     15          };
     16          
E:\Neocore\Hardware\Stack_core_src\cpu.c
      1          #include "action_manager.h"
      2          #include "ioCC2530.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          static void HW_Init(void);   
      9           
     10          module_s CPU_MODULE = {ALIAS(HW_Init)};
     11          
     12          static void HW_Init(void){
     13            /* Сбрасываем бит OSC32K, будет выбран 32.768 кварц */
     14            CLKCONCMD &= ~(1<<7); 
     15            /* Ждем пока бит не станет 0 */
     16            while (CLKCONSTA & (1<<7)); 
     17            /* Переходим на 32 Мгц */
     18            CLKCONCMD = 0;// (1<<3);
     19            while (CLKCONSTA&(1<<6));
     20            EA = 1;
     21          };  
E:\Neocore\Hardware\STACK_CORE_SRC\debug.c
      1          #include "debug.h"
      2          #include "action_manager.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          static void HW_Init(void);  
      9          static void uart_init(void);
     10           
     11          module_s DBG_MODULE = {ALIAS(HW_Init)};
     12          
     13          static void HW_Init(void){
     14          #ifndef DEBUG
     15            return;
     16          #endif
     17          #ifdef PRINT_TO_TERMINAL  
     18            uart_init();
     19          #endif
     20          #ifdef SIG_DEBUG
     21            P1DIR |=0x01;
     22            P1_0 |= 0x01;  
     23          #endif
     24          };  
     25          
     26          
     27          void DBG_CORE_HALT(void){
     28            while(1);
     29          }
     30          
     31          void DBG_CORE_FAULT(void){
     32            while(1);
     33          }
     34          
     35          // Настройка порта uart для отладки
     36          static void uart_init(void){
     37            // Выбор расположения UART на выводах
     38            char U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     39            PERCFG |= (U0CFG<<0); 
     40            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     41            U0CSR = (1<<7); // Выбираем режим uart  
     42            // Настройка скорости передачи данных на 2М  
     43            U0BAUD = 0;  // табличные значения из pdf
     44            U0GCR =  16;
     45            // Включаем альтернативные функции выводов
     46            P0SEL = (1<<2)|(1<<3);
     47            U0CSR |= (1<<6);
     48          }
     49          
     50          //#ifdef PRINT_TO_TERMINAL 
     51          //#include <yfuns.h>
     52          //_STD_BEGIN
     53          //#pragma module_name = "?__write"
     54          //
     55          __near_func int putchar(int x){
     56            while( U0CSR&(1<<0));
     57            U0DBUF = x;
     58            return x;
     59          }
     60          
E:\Neocore\Hardware\Stack_core_src\dma.c
      1          #include "dma.h"
      2          #include "ioCC2530.h"
      3          #include "action_manager.h"
      4          
      5          static void HW_Init(void);
      6          module_s DMA_MODULE = {ALIAS(HW_Init)};
      7          
      8            
      9          DMA_s DMA_CH[5];
     10          
     11          /**
     12          @brief Настройка DMA каналов.
     13          @detail Согласно документации каналы 1-4 идут последовательно
     14          */
     15          static void HW_Init(void){
     16              // Настроим канал 0 DMA для загрузки данных в AES
     17            uint16_t CONF_ADDR = (uint16_t)&DMA_CH[0];
     18            DMA0CFGH = CONF_ADDR >> 8;
     19            DMA0CFGL = CONF_ADDR & 0xFF;
     20            
     21            // Настроим канал 1 DMA для выгрузки данных из AES
     22            CONF_ADDR = (uint16_t)&DMA_CH[1];
     23            DMA1CFGH = CONF_ADDR >> 8;
     24            DMA1CFGL = CONF_ADDR & 0xFF;
     25          }
E:\Neocore\Hardware\PRG Node\ethernet.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "route.h"
      4          #include "auth_eth.h"
      5          #include "neigh.h"
      6          #include "llc.h"
      7          
      8          #define ETH_LAY_SIZE sizeof(struct ETH_LAY)
      9          
     10          struct ETH_LAY{  
     11            union{
     12              uint8_t value;
     13              struct {
     14                char PID:4;
     15                char UNUSED:1;
     16                char ETH_VER:3;
     17              } bits;
     18            } ETH_T;
     19          
     20            char NETID;
     21            unsigned int NDST;
     22            unsigned int NSRC;
     23            char NSRC_TS;
     24            char NSRC_CH;
     25            char XOR;
     26          } __attribute__((packed));
     27          
     28          static char calc_xor(struct ETH_LAY *eth){
     29            char xor_val = 0x57;
     30            char *ptr = (char*)eth;
     31            
     32            // Ксорим все кроме последнего байта структуы. он XOR
     33            for (int i = 0; i < sizeof(struct ETH_LAY) - 1; i++)
     34              xor_val ^=ptr[i];
     35            
     36            return xor_val;
     37          };
     38          
     39          static bool frame_filter(struct frame *frame){
     40            struct ETH_LAY *eth_header = (struct ETH_LAY*)frame->payload;
     41            
     42            // Фильтр 0: по размеру кадра
     43            if (frame->len < ETH_LAY_SIZE){
     44              LOG_ON("Filtered ETH_LAY_SIZE");
     45              return false;
     46            }
     47            
     48            // Фильтр 1: по XOR
     49            char xor_val = calc_xor(eth_header);
     50            if (xor_val != eth_header->XOR){
     51              LOG_ON("Filtered XOR");
     52              return false;
     53            };
     54            
     55            // Фильтр 2: по версии протокола
     56            if (eth_header->ETH_T.bits.ETH_VER != HEADER_ETH_VER){
     57              LOG_ON("Filtered ETH_VER. %d",eth_header->ETH_T.bits.ETH_VER );
     58              return false;
     59            }
     60          
     61            // Фильтр 3: по идентификатору сети
     62            if (eth_header->NETID!= MODEL.SYNC.panid){
     63              LOG_ON("Filtered panid");
     64              return false;
     65            }
     66            
     67            bool from_gw = (eth_header->NSRC_CH == 0xff) &&
     68                           (eth_header->NSRC_TS == 0xff);
     69            if (!from_gw){
     70              // Фильтр 4: по каналу отправителя
     71              if (eth_header->NSRC_CH  < CH11 || eth_header->NSRC_CH  > CH28){
     72                LOG_ON("Filtered NSRC_CH");
     73                return false;
     74              }
     75              // Фильтр 5: по таймслоту отправителя
     76              if (eth_header->NSRC_TS  < 1 || eth_header->NSRC_TS  > 49){
     77                LOG_ON("Filtered NSRC_TS");
     78                return false;
     79              }
     80            };
     81            
     82            // Фильтр 6: по адресу получателю
     83            if (eth_header->NDST != 0xffff )
     84              if (eth_header->NDST != MODEL.node_adr){
     85                LOG_ON("Filtered node addr");
     86                return false;
     87              }
     88            return true;
     89          }
     90          
     91          static inline void fill_meta_data(struct frame *frame){
     92            // Заполняем метаданные
     93            struct ETH_LAY *eth_header = (struct ETH_LAY*)frame->payload;
     94            frame->meta.NDST = eth_header->NDST;
     95            frame->meta.NSRC = eth_header->NSRC;
     96            frame->meta.PID = eth_header->ETH_T.bits.PID;  
     97            frame->meta.NSRC_TS = eth_header->NSRC_TS;
     98            frame->meta.NSRC_CH = eth_header->NSRC_CH;
     99          }
    100          
    101          static void parse_frame(struct frame *frame){
    102            // Разбор пакета
    103            LOG_ON("Frame Filter");
    104            if (!frame_filter(frame))
    105              return;
    106            
    107            LOG_ON("Fill metadata");
    108            fill_meta_data(frame);
    109            LOG_ON("Delete eth header");
    110            FR_del_header(frame, ETH_LAY_SIZE);
    111            LOG_ON("Route protocol");
    112            RP_Receive(frame);  
    113          }
    114          
    115          /* brief Обработка принятых пакетов
    116          * Извлекает пакеты из входящего буфера, разбирает заголовок ETH, фильтрует 
    117          * пакет и передает их на обработку  протоколу маршрутизации. 
    118          * После обработки пакет удаляется.
    119          */
    120          void ethernet_process(void){
    121            struct frame* frame = NULL;
    122            frame = FR_find_rx(frame); 
    123            LOG_OFF("Start search rx");
    124            while (frame){
    125              LOG_ON("Find rx!");
    126              LOG_ON("ETH. LEN:%d, TS:%d, CH:%d, PID:%d", frame->len,
    127                     frame->meta.TS, frame->meta.CH, frame->meta.PID);
    128              parse_frame(frame);
    129              FR_delete(frame);
    130              frame = FR_find_rx(frame);
    131            };
    132            LOG_OFF("Stop search rx");
    133            
    134            // Выделение свободного времени
    135            AUTH_ETH_TimeAlloc();
    136            NP_TimeAlloc();
    137            RP_TimeAlloc();
    138          };
    139          
    140          void eth_send(struct frame *frame){
    141            struct ETH_LAY eth_header;
    142            eth_header.ETH_T.bits.PID = frame->meta.PID ;
    143            eth_header.ETH_T.bits.ETH_VER =HEADER_ETH_VER;
    144            eth_header.NETID = MODEL.SYNC.panid;
    145            eth_header.NDST = frame->meta.NDST;
    146            eth_header.NSRC = frame->meta.NSRC;
    147            eth_header.NSRC_CH = MODEL.node_CH;
    148            eth_header.NSRC_TS = MODEL.node_TS;
    149            eth_header.XOR = calc_xor(&eth_header);
    150            
    151            bool res;
    152            res = FR_add_header(frame, &eth_header,
    153                                sizeof(struct ETH_LAY));
    154            ASSERT(res);
    155           
    156            frame->meta.tx_attempts = 5;
    157            res = LLC_add_tx_frame(frame); 
    158          };
E:\Neocore\Hardware\STACK_CORE_SRC\frame.c
      1          #include "action_manager.h"
      2          #include "frame.h"
      3          #include "debug.h"
      4          #include "global.h"
      5          #include "mem_utils.h"
      6          #include "mem_slots.h"
      7          
      8          /**
      9          @file Статическое хранение принятых пакетов
     10          */
     11          
     12          static void SW_Init(void); 
     13          
     14          module_s FR_MODULE = {ALIAS(SW_Init)};
     15          
     16          static void SW_Init(void){ 
     17          }; 
     18          
     19          void FR_restart(){
     20            SW_restart();
     21          }
     22          
     23          struct frame* FR_create(){
     24            return (struct frame*)SL_alloc();
     25          };
     26          
     27          bool FR_delete(struct frame *frame){
     28            return SL_free((char*)frame);
     29          }
     30          
     31          static void mem_move(char *dst, char *src, char len){
     32            for (int i = len - 1; i >= 0; i--)
     33              dst[i] = src[i];
     34          };
     35          
     36          bool FR_add_header(struct frame* frame ,void *head, char len){
     37            int new_len = frame->len + len;
     38            if (!(new_len < MAX_PAYLOAD_SIZE))
     39              return false;
     40            
     41            // Сдвинем данные на размер вставки при необходимости
     42            if (frame->len != 0)
     43              mem_move(&frame->payload[len], frame->payload, frame->len);
     44            
     45            // Скопируем новые данные
     46            MEMCPY(frame->payload, head, len);
     47            frame->len = new_len;
     48            return true;
     49          };
     50          
     51          
     52          bool FR_del_header(struct frame* frame, char len){
     53            if (len == 0 || len > frame->len )
     54              return false;
     55            frame->len = frame->len - len;
     56            MEMCPY(frame->payload, &frame->payload[len], frame->len);
     57            
     58            #ifdef FRAME_FOOTER_DEL
     59            MEMSET(&frame->payload[frame->len], 0, len);
     60            #endif
     61            return true;
     62          }
     63          
     64          void FR_set_rx(struct frame* frame){
     65            SL_set_rx((char*)frame);
     66          }
     67          
     68          void FR_set_tx(struct frame* frame){
     69            SL_set_tx((char*)frame);
     70          }
     71          
     72          bool FR_is_rx(struct frame* frame){
     73            return SL_is_rx((char*)frame);
     74          }
     75          
     76          bool FR_is_tx(struct frame* frame){
     77            return SL_is_tx((char*)frame);
     78          }
     79          
     80          int FR_rx_frames(){
     81            return SL_rx_slots();
     82          };
     83          
     84          int FR_tx_frames(){
     85            return SL_tx_slots();
     86          };
     87          
     88          int FR_busy(){
     89            return SL_busy();
     90          }
     91          
     92          struct frame* FR_find_tx(struct frame* frame){
     93            return (struct frame*)SL_find_tx((char*)frame);  
     94          }
     95          
     96          struct frame* FR_find_rx(struct frame* frame){
     97            return (struct frame*)SL_find_rx((char*)frame);  
     98          }
     99          
    100          int FR_available(){
    101            return SL_available();
    102          };
E:\Neocore\Hardware\PRG Node\ip.c
      1          #include "model.h"
      2          #include "debug.h"
      3          
      4          
      5          void IP_Receive(struct frame *frame){
      6          }
E:\Neocore\Hardware\Stack_core_src\led.c
      1          #include "action_manager.h"
      2          
      3          static void HW_Init(void);
      4          static void SW_Init(void);
      5          static void Cold_Start(void);
      6          static void Hot_Start(void);
      7          
      8          module_s LED_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
      9            ALIAS(Hot_Start), ALIAS(HW_Init)};
     10          
     11          static void HW_Init(void){};
     12          static void SW_Init(void){};
     13          static void Cold_Start(void){};
     14          static void Hot_Start(void){};
E:\Neocore\Hardware\STACK_CORE_SRC\llc.c
      1          #include "action_manager.h"
      2          #include "stddef.h"
      3          #include "macros.h"
      4          #include "model.h"
      5          #include "debug.h"
      6          #include "radio.h"
      7          #include "mac.h"
      8          
      9          
     10          #define MAX_SLOTS 50
     11          
     12          #define RX_ALARM (1<<0)
     13          #define TX_ALARM (1<<1)
     14          
     15          static void SW_Init(void);
     16          static void Cold_Start(void);
     17          static void Hot_Start(void);
     18          static void IRQ_Init(void);
     19          
     20          module_s LLC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
     21            ALIAS(Hot_Start), ALIAS(IRQ_Init)};
     22          
     23          struct action{
     24            channel_t rx;
     25            struct frame *frame_tx;
     26          };
     27          
     28          static struct action ACTIONSLOTS[MAX_SLOTS];
     29          
     30          static void IRQ_Init(void){
     31            for_each_type(struct action, ACTIONSLOTS, slot){
     32              slot->rx = 0;
     33              slot->frame_tx = NULL;
     34            }
     35          };
     36          
     37          static void SW_Init(void){
     38            for_each_type(struct action, ACTIONSLOTS, slot){
     39              slot->rx = 0;
     40              slot->frame_tx = NULL;
     41            }
     42          };
     43          
     44          void LLC_restart(){
     45            SW_Init();
     46          }
     47          
     48          void LLC_open_slot(timeslot_t ts, channel_t ch){
     49            ASSERT(ts >= 1 && ts < MAX_SLOTS);
     50            ASSERT(ch >= MIN_CH && ch <= MAX_CH);
     51            ACTIONSLOTS[ts].rx = ch;
     52          }
     53          
     54          void LLC_close_slot(timeslot_t ts){
     55            ASSERT(ts >= 1 && ts < MAX_SLOTS);
     56            ACTIONSLOTS[ts].rx = 0;
     57          }
     58          
     59          bool LLC_add_tx_frame(struct frame *frame){
     60            ASSERT(frame);
     61            AES_StreamCoder(true, frame->payload, frame->payload, frame->len); 
     62            FR_set_tx(frame);
     63            return true;
     64          }
     65          
     66          static void scheduler_tx(void){
     67            struct frame* tx_frame = NULL; 
     68            tx_frame = FR_find_tx(tx_frame);
     69            
     70            if (!tx_frame)
     71              return;
     72            
     73            while(tx_frame){
     74              ASSERT(tx_frame->meta.TS != 0);
     75              // Если у нас есть что передавать, берем следующий кадр из буфера
     76              if (ACTIONSLOTS[tx_frame->meta.TS].frame_tx){
     77                tx_frame = FR_find_tx(tx_frame);
     78                continue;
     79              }
     80              ACTIONSLOTS[tx_frame->meta.TS].frame_tx = tx_frame;
     81              TM_SetAlarm(tx_frame->meta.TS, TX_ALARM); 
     82              tx_frame = FR_find_tx(tx_frame);
     83            }
     84          }
     85          
     86          static void scheduler_rx(void){
     87            ASSERT(ACTIONSLOTS[0].rx == 0);
     88            for (char i = 1; i < MAX_SLOTS; i++)
     89              if (ACTIONSLOTS[i].rx)
     90                TM_SetAlarm(i, RX_ALARM);
     91              else
     92                TM_ClrAlarm(i, RX_ALARM);
     93          }
     94          
     95          static void Cold_Start(void){
     96          // Планировщик планирует на один суперфрейм в начале ts0
     97            if (MODEL.TM.timeslot != 0)
     98              return;
     99            
    100            scheduler_tx();
    101            scheduler_rx();
    102          };
    103          
    104          static inline void receive(){
    105            timeslot_t ts = MODEL.TM.timeslot;
    106            MAC_Receive(ACTIONSLOTS[ts].rx);
    107          }
    108          
    109          static void transmite(void){
    110            timeslot_t ts = MODEL.TM.timeslot;
    111            struct frame *frame = ACTIONSLOTS[ts].frame_tx;
    112            
    113            if (!frame)
    114              HALT("Error")
    115            
    116            // Неудачные передачи учитывает MAC_Send()
    117            int send_res = MAC_Send(frame);
    118            switch (send_res) {
    119              case 1: { // удачная передача
    120                TM_ClrAlarm(ts, TX_ALARM);
    121                ACTIONSLOTS[ts].frame_tx = NULL;
    122                LOG_ON("Send success");
    123                break;
    124              }
    125              case 0: { // неудачная передача. ACK не получен или CCA
    126                LOG_ON("CCA/ACK err")
    127                break;
    128              }
    129              case -1: { // Исчерпаны попытки отправки
    130                TM_ClrAlarm(ts, TX_ALARM);
    131                ACTIONSLOTS[ts].frame_tx = NULL;
    132                LOG_ON("Attempts exired");
    133                break;
    134              }
    135              default:
    136                HALT("Error");
    137            };
    138          }
    139          
    140          static void Hot_Start(void){
    141            timeslot_t ts = MODEL.TM.timeslot;
    142            if (ts == 0)
    143              return;
    144            char alarm = MODEL.TM.alarm;
    145            
    146            if (alarm & TX_ALARM)
    147              transmite();
    148            else if (alarm & RX_ALARM)
    149              receive();
    150          };
E:\Neocore\Hardware\STACK_CORE_SRC\mac.c
      1          #include "action_manager.h"
      2          #include "frame.h"
      3          #include "coder.h"
      4          #include "radio.h"
      5          #include "ustimer.h"
      6          #include "debug.h"
      7          #include "model.h"
      8          
      9          #define RECV_TIMEOUT 2500
     10          
     11          static void SW_Init(void);
     12          static void IRQ_Init(void);
     13          
     14          module_s MAC_MODULE = {ALIAS(SW_Init), ALIAS(IRQ_Init)};
     15          
     16          struct ack{ // Формат структуры пакета ACK
     17            char CRC8;
     18          } __attribute__((packed));
     19          
     20          static void SW_Init(void){};
     21          static void IRQ_Init(void){};
     22          
     23          
     24          static inline struct frame* _recv_frame(channel_t ch){
     25            if(!RI_SetChannel(ch))
     26              HALT("Wrong channel");
     27            
     28            //UST_delay(400);
     29            nwtime_t NOW1 = AT_time();
     30            struct frame *frame = RI_Receive(RECV_TIMEOUT); //
     31            nwtime_t NOW2 = AT_time();
     32            return frame;
     33          }
     34          
     35          static uint8_t xor_calc(struct frame *frame){
     36            uint8_t crc = 0x34; // Начальное значение
     37            uint8_t *val = (uint8_t*)frame->payload;
     38            for (uint8_t i = 0; i < frame->len; i++)
     39              crc ^= val[i];
     40            return crc;
     41          }
     42          
     43          static inline void _send_ack(struct frame *frame){
     44            struct ack ack;
     45            struct frame *ack_frame;
     46            // Создаем подтверждение кадра
     47            ack.CRC8 = xor_calc(frame);
     48            // Создаем кадр для отправки
     49            ack_frame = FR_create();
     50            FR_add_header(ack_frame, &ack, sizeof(struct ack));
     51            RI_Send(ack_frame);
     52            FR_delete(ack_frame);  
     53          }
     54          
     55          void MAC_Receive(channel_t ch){
     56            struct frame *frame = _recv_frame(ch);
     57            if (!frame)
     58              return;
     59            
     60            frame->meta.TS = MODEL.TM.timeslot;
     61            if (MODEL.TM.timeslot > 1) // не системный таймслот требует подтверждения
     62              _send_ack(frame);
     63            
     64            AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
     65            
     66            LOG_ON("push");
     67            FR_set_rx(frame);  
     68          }
     69          
     70          static inline bool _send_frame(struct frame *frame){
     71            if(!RI_SetChannel(frame->meta.CH))
     72              HALT("Wrong channel");  
     73            
     74            UST_delay(918);
     75            bool tx_success = RI_Send(frame);
     76            return tx_success;
     77          }
     78          
     79          static inline bool _recv_ack(struct frame *frame){
     80            return true;
     81          }
     82          
     83          int MAC_Send(struct frame *frame){
     84            bool tx_success = _send_frame(frame);
     85            
     86            bool ack_success = false;
     87            if (MODEL.TM.timeslot > 1) // Ждем подтверждения ack для не системных слотов
     88              ack_success = _recv_ack(frame);
     89            else
     90              ack_success = true;
     91            
     92            if (tx_success && ack_success){ // Удачная передача
     93              FR_delete(frame);
     94              return 1;
     95            }
     96            else{ // неудачная передача
     97              if (frame->meta.tx_attempts > 0)
     98                frame->meta.tx_attempts --;
     99              
    100              if (!frame->meta.tx_attempts){ // кончились попытки передачи
    101                FR_delete(frame);
    102                return -1;
    103              }
    104            }
    105            return 0;
    106          }
E:\Neocore\Hardware\PRG Node\main.c
      1          #include "action_manager.h"
      2          #include "time_manager.h"
      3          #include "debug.h"
      4          #include "model.h"
      5          #include "sync.h"
      6          #include "action_manager.h"
      7          #include "frame.h"
      8          #include "model.h"
      9          #include "radio.h"
     10          #include "llc.h"
     11          #include "ethernet.h"
     12          
     13          static struct frame* get_frame(void){
     14            struct frame *frame = FR_create(); 
     15            char data[10] = {1,2,3,4,5,6,7,8,9,0};
     16            FR_add_header(frame, data, sizeof(data));
     17            frame->meta.tx_attempts = 3;
     18            frame->meta.TS = 2;
     19            frame->meta.CH = CH20;
     20            return frame;
     21          }
     22          
     23          /** brief Функция вызывается после приема пакетов
     24          * Здесь происходит обработка протоколов верхнего уровня
     25          */
     26          static void callback(void){
     27            static bool first=true;
     28            if (first){
     29              LLC_open_slot(1, MODEL.SYNC.sys_channel);
     30              first = false;
     31            }
     32            ethernet_process();
     33          //  LLC_add_tx_frame(frame);
     34           LOG_ON("callback exit");
     35          }
     36          
     37          //TODO alarm manager вызывает из прерывания TM_IRQ
     38          //в TM_IRQ засоряется стек прерывания
     39          static void pre_init(void){
     40            AM_HW_Init();
     41            AM_SW_Init();
     42            LOG_ON("Hardware inited");
     43            MODEL.SYNC.mode = 1;
     44            MODEL.TM.MODE = 1;
     45            AM_set_callback(callback);
     46          }
     47          
     48          // TODO добавить в buffer.c размер RX и TX очереди
     49          void main(void){
     50            pre_init();
     51            LOG_ON("Node started");
     52            
     53            while (1){
     54              MODEL.SYNC.mode = 1;
     55              MODEL.TM.MODE = 1;
     56              while (!network_sync(1000000U));
     57              LOG_ON("Synced");
     58              MODEL.node_TS = 5;
     59              MODEL.node_CH =14;
     60              Neocore_start();
     61              AM_SW_Init();
     62              LOG_ON("START RESYNC");
     63            }
     64          };
E:\Neocore\Hardware\STACK_CORE_SRC\mem_slots.c
      1          #include "debug.h"
      2          #include "global.h"
      3          #include "macros.h"
      4          #include "stdbool.h"
      5          #include "action_manager.h"
      6          #include "mem_utils.h"  
      7          #include "cpu.h"
      8          #include "mem_slots.h"
      9          
     10          //!< Максимальный размер данных в одном слоте
     11          #define SLOT_BUFFER_SIZE 150
     12          #define RED_ZONE_CODE 0x73
     13          
     14          typedef char red_zone_t;
     15          
     16          static void SW_Init(void);
     17          module_s MS_MODULE = {ALIAS(SW_Init)};
     18          
     19          struct property{
     20            char taken: 1;
     21            char RX :1;
     22            char TX :1;
     23          };
     24          
     25          struct slot{
     26            struct property property;
     27            red_zone_t red_zone_1;
     28            char buffer[SLOT_BUFFER_SIZE];
     29            red_zone_t red_zone_2;
     30          };
     31          
     32          //!< Хранилище слотов
     33          static struct slot SLOT_POOL[SLOT_POOL_ITEMS];
     34          //!< Количество занятых слотов
     35          static int slot_busy;
     36          
     37          void SW_Init(void){
     38            slot_busy = 0;
     39            for_each_type(struct slot, SLOT_POOL, slot){
     40              slot->property.taken = false;
     41              slot->property.RX = false;
     42              slot->property.TX = false;
     43              #ifdef FILL_SLOT_ZERO
     44                MEMSET(slot->buffer, 0, SLOT_BUFFER_SIZE);
     45              #endif    
     46              slot->red_zone_1 = RED_ZONE_CODE;
     47              slot->red_zone_2 = RED_ZONE_CODE;
     48            }
     49          };
     50          
     51          void SW_restart(){
     52            SW_Init();
     53          };
     54          
     55          int SL_rx_slots(){
     56              int cnt=0;
     57              for_each_type(struct slot, SLOT_POOL, slot){
     58                if (slot->property.taken && slot->property.RX)
     59                  cnt++;
     60              }
     61              return cnt;
     62          }
     63          
     64          int SL_tx_slots(){
     65              int cnt=0;
     66              for_each_type(struct slot, SLOT_POOL, slot){
     67                if (slot->property.taken && slot->property.TX)
     68                  cnt++;
     69              }
     70              return cnt;
     71          }
     72          
     73          /**
     74          @brief Возвращает указатель на следующий буфер tx
     75          @param buff. buff = NULL поиск от начала списка или от последнего найденого 
     76           буфера.
     77          */
     78          char* SL_find_tx(char* buff){  
     79            if (!buff){
     80              for_each_type(struct slot, SLOT_POOL, slot){
     81                if (slot->property.taken && slot->property.TX)
     82                  return slot->buffer;
     83              }
     84              return NULL;
     85            }
     86            struct slot *geven_slot = container_of(buff, struct slot, buffer);
     87            geven_slot++;
     88            
     89            while (geven_slot <= &SLOT_POOL[SLOT_POOL_ITEMS]){
     90              if (geven_slot->property.taken && geven_slot->property.TX)
     91                return geven_slot->buffer;
     92              geven_slot++;
     93            }
     94            return NULL;
     95          }
     96          
     97          /**
     98          @brief Возвращает указатель на следующий буфер rx
     99          @param buff. buff = NULL поиск от начала списка или от последнего найденого 
    100           буфера.
    101          */
    102          char* SL_find_rx(char* buff){  
    103            if (!buff){
    104              for_each_type(struct slot, SLOT_POOL, slot){
    105                if (slot->property.taken && slot->property.RX)
    106                  return slot->buffer;
    107              }
    108              return NULL;
    109            }
    110            struct slot *geven_slot = container_of(buff, struct slot, buffer);
    111            geven_slot++;
    112            
    113            while (geven_slot <= &SLOT_POOL[SLOT_POOL_ITEMS]){
    114              if (geven_slot->property.taken && geven_slot->property.RX)
    115                return geven_slot->buffer;
    116              geven_slot++;
    117            }
    118            return NULL;
    119          }
    120          
    121          /**
    122          @brief Возвращает указатель на буфер или NULL. Буфер заполнен 0
    123          @detail 
    124          */
    125          char* SL_alloc(void){  
    126            char *ret_ptr = NULL;
    127            ATOMIC_BLOCK_RESTORE{
    128              for_each_type(struct slot, SLOT_POOL, slot){
    129                if (!slot->property.taken){
    130                  slot->property.taken = true;
    131                  slot->property.RX = false;
    132                  slot->property.TX = false;
    133                  slot_busy++;
    134                  #ifdef FILL_SLOT_ZERO
    135                    MEMSET(slot->buffer, 0, SLOT_BUFFER_SIZE);
    136                  #endif
    137                  ret_ptr = slot->buffer;
    138                  break;
    139                };
    140              };  
    141            };
    142            return ret_ptr;
    143          };
    144          
    145          static bool _free(char *buff){
    146            struct slot *slot = container_of(buff, struct slot, buffer);
    147              
    148            slot->property.taken = false;
    149            slot->property.RX = false;
    150            slot->property.TX = false;
    151            slot_busy--;
    152            return true;
    153          }
    154          
    155          bool SL_is_tx(char *buff){
    156            struct slot *slot = container_of(buff, struct slot, buffer);
    157            return slot->property.TX;
    158          }
    159          
    160          bool SL_is_rx(char *buff){
    161            struct slot *slot = container_of(buff, struct slot, buffer);
    162            return slot->property.RX;
    163          }
    164          
    165          void SL_set_tx(char *buff){
    166            ATOMIC_BLOCK_RESTORE{
    167              struct slot *slot = container_of(buff, struct slot, buffer);
    168              slot->property.TX = true;
    169            }
    170          }
    171          
    172          void SL_set_rx(char *buff){
    173            ATOMIC_BLOCK_RESTORE{
    174              struct slot *slot = container_of(buff, struct slot, buffer);
    175              slot->property.RX = true;
    176            }
    177          }
    178          
    179          bool SL_free(char *buff){
    180            bool res;
    181            ATOMIC_BLOCK_RESTORE{
    182              res = _free(buff);
    183            }
    184            return res;
    185          };
    186          
    187          
    188          int SL_busy(){
    189            ASSERT(slot_busy <= SLOT_POOL_ITEMS);
    190            return slot_busy;
    191          };
    192          
    193          int SL_available(){
    194            ASSERT(slot_busy <= SLOT_POOL_ITEMS);  
    195            return SLOT_POOL_ITEMS - slot_busy;
    196          };
    197          
    198          int SL_zone_check(){
    199            int index = 0;
    200            for_each_type(struct slot, SLOT_POOL, slot){
    201              if (!(slot->red_zone_1 == RED_ZONE_CODE &&
    202                    slot->red_zone_2 == RED_ZONE_CODE))
    203                return index;
    204              index++;
    205            }
    206            return -1;
    207          };
    208          
E:\Neocore\Hardware\STACK_CORE_SRC\mem_utils.c
      1          #include "mem_utils.h"
      2          #include "debug.h"
      3          
      4          /**
      5          @file Реентерабельное копирование
      6          */
      7          
      8          void MEM_memcpy(struct memcpy *memcpy){
      9            while (memcpy->len > 0){
     10              *memcpy->dst = *memcpy->src;
     11              memcpy->dst++;
     12              memcpy->src++;
     13              memcpy->len--;
     14            }
     15          };
     16          
     17          void MEM_memset(struct memset *memset){
     18            while (memset->len > 0){
     19              *memset->dst = memset->val;
     20              memset->dst++;
     21              memset->len--;
     22            }  
     23          };
     24          
     25          
E:\Neocore\Hardware\STACK_CORE_SRC\model.c
      1          #include "model.h"
      2          #include "action_manager.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          MODEL_s MODEL;
      9          
     10            
     11          static void SW_Init(void); 
     12          
     13          module_s MD_MODULE = {ALIAS(SW_Init)};
     14          
     15           
     16          static void SW_Init(void){
     17            for (int i = 0; i < sizeof(MODEL.PWR_SCAN.energy); i++)
     18              MODEL.PWR_SCAN.energy[i] = -127;
     19            
     20            MODEL.node_adr = 0;
     21            MODEL.node_mac[0] = 0x11;
     22            MODEL.node_mac[1] = 0x22;
     23            MODEL.node_mac[2] = 0x33;
     24            MODEL.node_mac[3] = 0x44;
     25            MODEL.node_mac[4] = 0x55;
     26            MODEL.node_mac[5] = 0xaa;
     27            MODEL.node_mac[6] = 0xee;
     28            MODEL.node_mac[7] = 0xff;
     29            
     30            MODEL.AUTH.auth_ok = false;
     31            MODEL.AUTH.access_ok = false;
     32            
     33          }; 
     34          
     35          
E:\Neocore\Hardware\PRG Node\neigh.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "protocol_defs.h"
      4          
      5          #define NB_TABLE_ITEMS 20
      6          #define MAX_OPEN_SLOTS 2
      7          #define REQ_CMD  0
      8          #define NB_FRAME_CARD_SIZE sizeof(struct frame_card)
      9          #define NB_FRAME_REQ_SIZE sizeof(struct frame_req)
     10          #define NB_TABLE_SIZE sizeof(struct table)
     11          
     12          #warning GW may open lot of slots
                  ^
Warning[Pe1105]: #warning directive: GW may open lot of slots
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"
     13          // Шлюз имеет предопределенные временные слоты и каналы?
     14          struct frame_card{ // Информационная карточка узла
     15              char ts_slots[MAX_OPEN_SLOTS]; // Временые слоты приема пакетов
     16              char ch_slots[MAX_OPEN_SLOTS]; // Частоты приема пакетов
     17              char ETX; // 0 - шлюз, 1 - одна передача до шлюза
     18          }__attribute__((packed));
     19          
     20          struct frame_req{ //Запрос от другого узла
     21            uint8_t cmd_req; // 0 - запрос информации
     22          }__attribute__((packed));
     23          
     24          
     25          struct table{
     26            unsigned int node_addr; // Адрес узла
     27            signed char RSSI_SIG;
     28            signed char LIQ;
     29            char weight; // Качество узла от 0 до 255. 0 - плохо
     30            struct frame_card card; // Информация об узле
     31            unsigned long update_time; // Время обновления записи
     32            bool record_active; // Запись действительна 
     33          } ;
     34          
     35          static struct table NB_TABLE[NB_TABLE_ITEMS];
     36          static unsigned long LAST_TIME_CARD_RECIEVED;
     37          
     38          static int find_index(struct frame *frame){
     39            // Попробуем найти пакет
     40            for (uint8_t i = 0; i < NB_TABLE_ITEMS; i++)
     41              if (NB_TABLE[i].node_addr == frame->meta.NSRC)
     42                if (NB_TABLE[i].record_active)
     43                  return i;
     44            return -1;
     45          }
     46          
     47          /**
     48          
     49          @brief Ищем свободное место
     50          
     51          @return -1 
     52          
     53          */
     54          
     55          static int find_free_index(){
     56            for (uint8_t i = 0; i < NB_TABLE_ITEMS; i++)
     57              if (!NB_TABLE[i].record_active)
     58                return i;
     59            return -1;
     60          }
     61          
     62          /**
     63          @brief Вычисляет вес карты
     64          @return 0 - плохо, 255 отлично
     65          */
     66          static uint8_t calc_weight(struct frame_card *card){
     67            // Сравнивает две карты по ETX, LIQ(пока не доступно), RSSI
     68            // ПОДУМАТЬ. При маршрутизаии от шлюза сохраняются маршруты до соседей
     69            // Если нет соседа ( выкинули его) то маршрут разрушится
     70            return 0;
     71          }
     72          
     73          /**
     74          
     75          @brief Обновление карточки по индексу
     76          
     77          */
     78          
     79          static void update_record(struct frame *frame, uint8_t index){
     80            struct frame_card *card = (struct frame_card*)frame->payload;
     81          //re_memcpy(&NB_TABLE[index].card, card, NB_FRAME_CARD_SIZE);
     82            NB_TABLE[index].update_time = MODEL.RTC.uptime;
     83            uint8_t weight = calc_weight(card);
     84            NB_TABLE[index].weight = weight;
     85            NB_TABLE[index].node_addr = frame->meta.NSRC;
     86            NB_TABLE[index].record_active = true;
     87            NB_TABLE[index].RSSI_SIG = frame->meta.RSSI_SIG;
     88            NB_TABLE[index].LIQ = frame->meta.LIQ;
     89          }
     90          
     91          static void insert_record(struct frame *frame){
     92            int index = find_free_index();
     93            struct frame_card *card = (struct frame_card*)frame->payload;
     94            uint8_t weight = calc_weight(card);
     95            if (index != -1){ // Нашли место, запихиваем карточку
     96              update_record(frame,index);
     97              LOG_ON("Card inserted.")
     98              return;
     99            }
    100            
    101            uint8_t bad_index, bad_weight = 255;
    102            bool found = false;
    103          
    104            // Свободных мест нет. Ищем самую плохую запись
    105            for (uint8_t i = 0; i < NB_TABLE_ITEMS; i++)
    106              if (NB_TABLE[i].record_active){
    107                if (NB_TABLE[i].weight < bad_weight){
    108                  bad_weight = NB_TABLE[i].weight ;
    109                  bad_index = i;
    110                  found = true;
    111                 }
    112              }
    113          
    114            if (!found){ // Если нету записей.
    115              LOG_ON("Card is bad. not inserted")
    116              return;
    117            }
    118            if (weight > bad_weight){ //// Карточка лучше чем самая плохая в таблице
    119              LOG_ON("Better card inserted")
    120              update_record(frame, bad_index);
    121            }
    122          }
    123          
    124          static bool frame_filter_card(struct frame *frame){ 
    125            // Фильтр 1: по размеру кадра
    126            if (frame->len < NB_FRAME_CARD_SIZE)
    127              return false;
    128            // struct frame_card *card = (struct frame_card*)frame->payload;
    129            // TODO Тут интелектуалные фильтры по содержимому
    130            // Желательно проверять что именно нам прислали и являются
    131            // ли данные корректными
    132            return true;
    133          }
    134          
    135          static bool frame_filter_cmd_req(struct frame *frame){
    136            // Фильтр 1: по размеру кадра
    137            if (frame->len < NB_FRAME_REQ_SIZE)
    138              return false;
    139            // TODO проверить доступные команды
    140            //struct frame_req *cmd_req = (struct frame_req*)frame->payload;
    141            return true;
    142          }
    143          /**
    144          
    145          @brief Обработка принятой карты 
    146          
    147          */
    148          
    149          static void process_card(struct frame *frame){
    150            int index = find_index(frame);
    151          
    152            if (index == -1) // Если нет записи об этом узле, вставим
    153              insert_record(frame);
    154            else{ // Если запись есть, то обновим 
    155              LOG_ON("Update card")
    156              update_record(frame, index);
    157            }
    158            // Обновим время получения последней карточки
    159            // мне не важно вставили или нет, главное что они регулярно приходят
    160            LAST_TIME_CARD_RECIEVED = MODEL.RTC.uptime;
    161          }
    162          
    163          static void send_card(void){
    164          //  struct frame_card card;
    165          //
    166          //  int etx = NP_GetETX();
    167          //  
    168          //  // Выходим если ETX не определен
    169          //  if (etx == -1){
    170          //    // Раз нет ETX то продлим время отправки карты
    171          //    uint32_t now = MODEL.RTC.uptime();
    172          //    NEXT_CARD_SEND_TIME = now + NEIGHBOR_CARD_SEND_INTERVAL + 
    173          //      rand() % NEIGHBOR_CARD_SEND_INTERVAL_DEV;
    174          //    LOG_ON("ETX not defind. Card not sended.")
    175          //    return;
    176          //  }
    177          //
    178          //  card.ETX = etx;
    179          //
    180          //  // Проверим что у нас есть открытые слоты
    181          //  bool opened = false;
    182          //  for (uint8_t i = 0; i < MAX_OPEN_SLOTS; i++){
    183          //  if (CONFIG.ts_slots[i] !=0 )
    184          //    if (CONFIG.ch_slots[i] !=0){
    185          //      opened = true;
    186          //      break;
    187          //    }
    188          //  }
    189          //
    190          // 
    191          //  if (!opened){
    192          //    uint32_t now = TIC_GetUptime();
    193          //    NEXT_CARD_SEND_TIME = now + NEIGHBOR_CARD_SEND_INTERVAL + 
    194          //      rand() % NEIGHBOR_CARD_SEND_INTERVAL_DEV;
    195          //    LOG_ON("Slots not opened. Card not sended.")
    196          //    return;
    197          //  }
    198          //
    199          //  for (uint8_t i = 0; i < MAX_OPEN_SLOTS; i++){
    200          //    card.ts_slots[i] = CONFIG.ts_slots[i];
    201          //    card.ch_slots[i] = CONFIG.ch_slots[i];
    202          //  }
    203          //
    204          //  frame_s *fr = frame_create();
    205          //  frame_addHeader(fr, &card, NB_FRAME_CARD_SIZE);
    206          //  fr->meta.PID = PID_NP;
    207          //  fr->meta.NDST = 0xffff;
    208          //  fr->meta.NSRC = MODEL.node_adr; 
    209          //  fr->meta.TS = 0;
    210          //  fr->meta.CH = CONFIG.sys_channel;
    211          //  fr->meta.TX_METHOD = BROADCAST;
    212          //  RP_Send(fr);
    213          //  LOG_ON("NP Card sended");
    214          }
    215          
    216          
    217          /**
    218          @brief Обработка принятой команды
    219          */
    220          static void process_cmd_req(struct frame *frame){
    221            struct frame_req *cmd_req = (struct frame_req*)frame->payload;  
    222          
    223            // Запрос информации об узле
    224            if (cmd_req->cmd_req == REQ_CMD)
    225              send_card();
    226            LOG_ON("CMD reques processed.")
    227          }
    228          
    229          void NP_Receive(struct frame *frame){
    230            if (frame->meta.NSRC == 0xffff)
    231              return;
    232            
    233            if (frame_filter_card(frame))
    234                process_card(frame);
    235            else if (frame_filter_cmd_req(frame))
    236                process_cmd_req(frame);
    237          }
    238          
    239          void NP_TimeAlloc(){
    240          };
E:\Neocore\Hardware\STACK_CORE_SRC\radio.c
      1          #include "radio.h"
      2          #include "mem_utils.h"
      3          #include "debug.h"
      4          #include "radio_defs.h"
      5          #include "ustimer.h"
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "alarm_timer.h"
      9          #include "model.h"
     10          #include "action_manager.h"
     11          #include "frame.h"
     12          #include "macros.h"
     13          #include "stdlib.h"
     14          
     15          static void HW_Init(void);
     16          static void SW_Init(void);
     17          module_s RADIO_MODULE = {ALIAS(SW_Init), ALIAS(HW_Init)};
     18          
     19          static void random_core_init(void);
     20          static char RXBUFF[128];
     21          
     22          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     23          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     24          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     25          /*!
     26          \details 
     27           Расчет качества связи. Коэффициенты получаются эксперементально.
     28           Есть предположение, что количество ошибок будет пропорционально квадрату
     29           коеффициента корреляции сигнала.
     30           LIQ = 255 передача 1000 пакетов без ошибок CRC
     31           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     32           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     33          */ 
     34          
     35          #define CONST_A (int8_t)0 //!< Коэффициент A
     36          #define CONST_B (int8_t)1 //!< Коэффициент B
     37          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     38          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     39          
     40          #ifdef RADIO_DEBUG
     41            #define WRITE_TIME_DBG(where) (where) = AT_time()
     42            #define WRITE_PARA_DBG(where,val) (where) = (val) 
     43          #else
     44            #define WRITE_TIME_DBG(where) {}
     45            #define WRITE_PARA_DBG(where,val)
     46          #endif
     47          
     48          static void SW_Init(void){
     49            // Настройки поумолчанию
     50            MODEL.RADIO.CRCError = 0;
     51            MODEL.RADIO.CCAReject = 0;
     52            MODEL.RADIO.channel = CH11;
     53            MODEL.RADIO.power_tx = m0x5;
     54            // Пост действия с радио
     55            random_core_init();
     56          }
     57          
     58          static void HW_Init(void){
     59            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
     60            MDMTEST1_u MDM1; // Устанавливаем режим модуляции
     61            MDM1.value = MDMTEST1;
     62            MDM1.bits.MODULATION_MODE = IEEE_MODE;
     63            MDMTEST1 = MDM1.value;   
     64          }
     65          
     66          static inline void setFreq(channel_t ch)
     67          {
     68            ASSERT( (ch >= MIN_CH) && (ch <= MAX_CH));
     69            // Устанавливаем частоту радиопередатчика
     70            FREQCTRL_u FRQ;
     71            FRQ.value = FRQ_CALC(MODEL.RADIO.channel);
     72            FREQCTRL = FRQ.value;  
     73          }
     74          
     75          static inline void pre_config(void){
     76            setFreq(MODEL.RADIO.channel); 
     77            TXPOWER = MODEL.RADIO.power_tx;
     78          }
     79          
     80          bool RI_SetChannel(channel_t channel){
     81            if (!(channel >= MIN_CH) && (channel <= MAX_CH))
     82              return false;
     83            MODEL.RADIO.channel = channel;
     84            return true;
     85          }
     86          
     87          static void LoadTXData(char *src, size_t len){
     88            ISFLUSHTX(); // Очищаем буфер передатчика
     89            RFD = len + 2; // Поле LEN на два байта больше
     90            for (size_t i = 0 ; i < len; i++)
     91              RFD = src[i];
     92            RFD = 0x00; // Добавляем CRC1,2
     93            RFD = 0x00;
     94          };
     95          
     96          static bool SendData(struct frame *fr, nwtime_t time){
     97            LoadTXData(fr->payload, fr->len);
     98            
     99            // Прежде чем включать радио нужно подождать
    100            if (time != 0) 
    101                AT_wait(time - 29);
    102            
    103            ISRXON();
    104            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.isrxon);
    105            RFIRQF1 &= ~RFIRQF1_TXDONE;
    106            RFIRQF0 &= ~RFIRQF0_SFD; 
    107            bool result = true;
    108            while(!RSSISTAT);
    109            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.rssistat);
    110            TRY{
    111              if (time != 0) // Отправка в определеное время
    112                AT_wait(time - 13); 
    113              ISTXONCCA();
    114              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.istxoncca);
    115              if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    116                THROW(1);
    117              // Ждем отправки SFD
    118              while (!(RFIRQF0 & RFIRQF0_SFD));
    119              fr->meta.TIMESTAMP = AT_time();
    120              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.sfd);
    121              // Ждем завершения отправки сообщения
    122              while (!(RFIRQF1 & RFIRQF1_TXDONE));
    123              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.txdone);
    124              
    125            }
    126            CATCH(1){ //SAMPLED_CCA == 0
    127              result = false;
    128            }
    129            FINALLY{
    130              ISRFOFF();
    131            }
    132            ETRY;  
    133            return result;
    134          }
    135          
    136          /*!
    137          \brief Передает данные в эфир
    138          */
    139          bool RI_Send(struct frame *fr){
    140            ASSERT(fr != NULL);
    141            pre_config();
    142            stamp_t start = UST_now();
    143            bool send_res = SendData(fr, 0);
    144            stamp_t stop = UST_now();
    145            //TODO Неверно считает интервал так как при отправке
    146            // sync пакета мы ждем
    147            ustime_t tx_time = UST_interval(start, stop); 
    148            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.fulltime, tx_time);
    149            MODEL.RADIO.UptimeTX += tx_time;
    150            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.ccasampled, send_res);
    151            if (!send_res)
    152              MODEL.RADIO.CCAReject++;
    153            return send_res;
    154          }
    155          
    156          bool RI_Send_time(struct frame *fr, nwtime_t time){
    157            ASSERT(fr != NULL);
    158            pre_config();
    159            //TODO начало start отложено! неверно вычисляем интервал
    160            stamp_t start = UST_now();
    161            bool send_res = SendData(fr, time);
    162            stamp_t stop = UST_now();
    163            //TODO Неверно считает интервал так как при отправке
    164            // sync пакета мы ждем
    165            ustime_t tx_time = UST_interval(start, stop); 
    166            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.fulltime, tx_time);
    167            MODEL.RADIO.UptimeTX += tx_time;
    168            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.ccasampled, send_res);
    169            if (!send_res)
    170              MODEL.RADIO.CCAReject++;
    171            return send_res;
    172          }
    173          
    174          
    175          static void UnLoadRXData(char *src, size_t len){
    176            for (size_t i = 0 ; i < len; i++)
    177              src[i] = RFD;
    178          };
    179          
    180          
    181          static bool RecvData(ustime_t timeout, nwtime_t *sfd_stamp){   
    182            bool recv_result = true;
    183            
    184            ISFLUSHRX();
    185            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    186            RFIRQF0 &= ~RFIRQF0_SFD; 
    187            ISRXON();
    188            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.isrxon);
    189            stamp_t start = UST_now();
    190            TRY{
    191              while(true){
    192                if (UST_time_over(start, timeout))
    193                  THROW(1);
    194                
    195                if ((RFIRQF0 & RFIRQF0_SFD)){ // Принят сигнал SFD
    196                  *sfd_stamp = AT_time(); 
    197                  WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.sfd);
    198                  break;
    199                }
    200              }
    201              // Ждем окончания приема пакета
    202              while (!(RFIRQF0 & RFIRQF0_RXPKTDONE));
    203              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.rxdone);
    204            }
    205            CATCH(1){ // Вышло время ожидания
    206              recv_result = false;
    207            }
    208            FINALLY{
    209              ISRFOFF();
    210            }
    211            ETRY;
    212            return recv_result;
    213          }
    214          
    215          /*!
    216          \brief Принимает данные из эфира
    217          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    218          RI_CRC_ERROR. Отмечает время прихода SFD в тактах сетевого времени .
    219          \param[in] timeout Время ожидания данных в микросекундах
    220          \return Возвращает NULL если данных нет
    221          */
    222          struct frame* RI_Receive(ustime_t timeout){
    223            // Устанавливаем частоту передачи пакета
    224            pre_config();
    225            nwtime_t sfd_stamp;
    226               
    227            // Принимаем пакет 
    228            stamp_t start = UST_now();
    229            bool recv_res = RecvData(timeout, &sfd_stamp);
    230            stamp_t stop = UST_now();
    231            ustime_t rx_time = UST_interval(start, stop); 
    232            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_RX.fulltime, rx_time);
    233            MODEL.RADIO.UptimeRX += rx_time;
    234            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_RX.received, recv_res);
    235            if (!recv_res) // Нет пакета, возвращаем NULL
    236              return NULL;
    237            
    238            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    239            
    240            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    241            if (frame_size <= 2)
    242              return NULL;
    243            
    244            UnLoadRXData(RXBUFF, frame_size);
    245            
    246            int8_t  FCS1 = RXBUFF[frame_size - 2]; // RSSI
    247            uint8_t FCS2 = RXBUFF[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    248            uint8_t LEN_F = RXBUFF[0]; // Поле LEN
    249            
    250            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    251            // с фактической длинной принятых данных
    252            if (LEN_F != frame_size - 1){
    253              MODEL.RADIO.CRCError++;
    254              return NULL;
    255            }
    256            
    257            // Проверим поле CRCOK
    258            if (!(FCS2 && 1<<7)){
    259              MODEL.RADIO.CRCError++;
    260              return NULL;
    261            }
    262            
    263            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    264            struct frame *frame = FR_create();
    265            ASSERT(frame);
    266            bool add_h = FR_add_header(frame, &RXBUFF[1], frame_size - 3);
    267            ASSERT(add_h);
    268            
    269            frame->meta.TIMESTAMP = sfd_stamp;
    270            frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    271            uint8_t corr = FCS2 & 0x7F;
    272            frame->meta.LIQ = LIQ_CALC(corr);
    273            frame->meta.CH = MODEL.RADIO.channel;
    274            return frame;
    275          }
    276          
    277          
    278          /**
    279          @breif Подссчет количества бит в байте
    280          @return Возвращает количество бит
    281          */
    282          static uint8_t bits_count(uint8_t value) {
    283            int ret = 0;
    284            for ( ; value; value = value >> 1 )
    285              ret += value & 1;
    286            return ret;
    287          }
    288          
    289          /**
    290          @brief Возращает 1 байт случайного числа
    291          @details Радио выдает всего лишь дви бита, нам нужно 8 
    292          */
    293          static inline uint8_t getRNDByte(void)
    294          {
    295            uint8_t val = 0;
    296            val |= RFRND << 0;
    297            val |= RFRND << 2;
    298            val |= RFRND << 4;
    299            val |= RFRND << 6;
    300            return val;
    301          }
    302          
    303          /**
    304          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    305          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    306          возвращает гарантированно новое значение. 
    307          @return возвращает случайное число.
    308          */
    309          static inline uint8_t readRandom(void)
    310          {
    311            uint8_t rnd_val = 0;
    312            uint8_t bit_cnt = 0;
    313            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    314            {
    315              rnd_val = getRNDByte();
    316              while (rnd_val == getRNDByte());
    317              rnd_val = getRNDByte();
    318              bit_cnt = bits_count(rnd_val);
    319            }
    320            return rnd_val;
    321          }
    322          
    323          /*!
    324          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    325          */
    326          static void random_core_init(void)  
    327          {
    328            unsigned int rnd_core = 0;;
    329               
    330            pre_config();
    331            FREQCTRL = 0x00; // Выбираем не используемую частоту
    332          
    333            // TODO По какой то причине OP_EXE не выполняет команду.
    334            // регистра RFST читается как 0xD0. это его состояние при reset
    335            // Включаем демодулятор
    336            ISRXON();
    337            
    338            // Ждем пока статус RSSI_VALID станет true
    339            while(!RSSISTAT);
    340            
    341            // Ждем случайных чисел
    342            while (RFRND == 0);
    343            
    344            // Настраиваем ядро случайного генератора
    345            rnd_core = readRandom();
    346            rnd_core |= (unsigned int)readRandom()<<8;
    347            srand(rnd_core);
    348            
    349            // Выключаем демодулятор
    350            ISRFOFF();
    351            // Первая генерация случайного числа занимает много времени.
    352            // Влияло на работу радио, так как использовались случайные посылки
    353            rand(); 
    354          }
    355          
    356          /**
    357          @brief Измерение мощности сигнала
    358          @details Частота = 2394+fch. fch = [0..113]. 2394MHz to 2507MHz.
    359           Устройство поддерживает частоты до 2507 МГц
    360          @param[in] fch номер ЧАСТОТНОГО канала
    361          @param[in] timeout_ms время сканирования в мс
    362          @param[out] Максимальная мощность сигнала за время сканирования
    363          @return true если успешно
    364          */
    365          bool RI_Measure_POW(char fch, ustime_t timeout, 
    366                              int8_t *RSSI_SIG){
    367            if (fch > 113)
    368              return false;
    369            //(2394+FREQCTRL.FREQ[6:0])
    370            FREQCTRL = fch; // Выбираем не используемую частоту
    371            ISRXON();
    372            while(!RSSISTAT);
    373            FRMCTRL0 |= 1<<4; // включаем ENERGY_SCAN, детектор пикового сигнала
    374            UST_delay(timeout);
    375            int8_t rssi = RSSI + RSSI_OFFSET;
    376            *RSSI_SIG = rssi;
    377            ISRFOFF();
    378            return true;
    379          }
    380          
E:\Neocore\Hardware\PRG Node\route.c
      1          #include "model.h"
      2          #include "debug.h"
      3          #include "protocol_defs.h"
      4          #include "ip.h"
      5          #include "neigh.h"
      6          #include "balancer.h"
      7          #include "auth_eth.h"
      8          
      9          #define ROUTE_TABLE_ITEMS 20
     10          
     11          struct route_record{
     12            unsigned int nsrc;
     13            unsigned int fsrc;
     14            unsigned long update_time;
     15            bool record_active;
     16          } __attribute__((packed));
     17          
     18          static struct route_record ROUTE_TABLE[ROUTE_TABLE_ITEMS];
     19          
     20          
     21          
     22          void RP_TimeAlloc(){
     23          };
     24          
     25          void RP_Receive(struct frame *frame){
     26            #warning update route tables
                    ^
Warning[Pe1105]: #warning directive: update route tables
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\route.c"
     27            switch (frame->meta.PID){
     28            case PID_IP: // Пакет относится к протоколу IP
     29              IP_Receive(frame);
     30              break;
     31            case PID_NP: // Пакет относится к протоколу соседей
     32              NP_Receive(frame);
     33              break;
     34            case PID_AUTH: // Пакет относится к протоколу авторизации
     35              AUTH_ETH_Receive(frame);
     36              break;
     37            default:
     38              return; // Пакет удалит ethernet
     39            };
     40            
     41            TB_Receive(frame);  
     42          };
     43          
     44          void RP_Send_GW(struct frame *frame){
     45          };
     46          
     47          void RP_Send(struct frame *frame){
     48          };
     49          
     50          void RP_SendRT_GW(struct frame *frame){
     51          };
     52          
     53          void RP_SendRT_RT(struct frame *frame){
     54          };
E:\Neocore\Hardware\Stack_core_src\rtc.c
      1          #include "action_manager.h"
      2          #include "model.h"
      3           
      4          static void SW_Init(void); 
      5          static void Cold_Start(void);
      6          static void Hot_Start(void);
      7          
      8          module_s RTC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
      9            ALIAS(Hot_Start)};
     10           
     11          static void SW_Init(void){}; 
     12          static void Cold_Start(void){};
     13          
     14          
     15          static void Hot_Start(void){
     16            if (MODEL.TM.timeslot != 0)
     17              return;    
     18            MODEL.RTC.uptime++;
     19            MODEL.RTC.rtc++;
     20          };
E:\Neocore\Hardware\STACK_CORE_SRC\sync.c
      1          #include "sync.h"
      2          #include "action_manager.h"
      3          #include "radio.h"
      4          #include "model.h"
      5          #include "alarm_timer.h"
      6          #include "debug.h"
      7          #include "frame.h"
      8          #include "coder.h"
      9          #include "stdlib.h"
     10          #include "macros.h"
     11          #include "global.h"
     12          
     13          #define MODE_0 0 // Отклчена модуль синхронизации 
     14          #define MODE_1 1 // Прием, ретрансляция, синхронизация
     15          #define MODE_2 2 // Периодическое вещание
     16          #define SYNC_TS 0 // Слот для синхронизации
     17          #define MAGIC 0x19833891 // Проверка что пакет действительно sync
     18          #define SYNC_TIME 163 // Точное время отправки пакета.nwtime
     19          #define NEG_RECV_OFFSET 33 // nwtime
     20          #define POS_RECV_OFFSET 33 // nwtime
     21          #define SEND_PERIOD 10 // Периодичность отправки пакетов
     22          #define RETRANSMITE_TRY 3 // Кол-во попыток отправки sync
     23          #define PROBABILIT 40 // % вероятность одной попытки отправки 
     24          #define UNSYNC_TIME 60 // Время в секундах рассинхронизации сети
     25          
     26          static void SW_Init(void);
     27          static void Cold_Start(void);
     28          static void Hot_Start(void);
     29          static bool send_sync(void);
     30          static struct frame* recv_sync(void);
     31          static char retransmite;
     32          
     33          module_s SYNC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
     34            ALIAS(Hot_Start)};
     35          
     36          struct sync{
     37            char sys_ch;
     38            char tx_power;
     39            char panid;
     40            unsigned long rtc;
     41            unsigned long magic;
     42          } __attribute__((packed));
     43          
     44          static void SW_Init(void){ 
     45            MODEL.SYNC.next_sync_send = 0;
     46            MODEL.SYNC.next_time_recv = 0;
     47            MODEL.SYNC.last_time_recv = 0;
     48            MODEL.SYNC.sys_channel = DEFAULT_SYS_CH;
     49            MODEL.SYNC.sync_channel = DEFAULT_SYNC_CH;
     50            retransmite = 0;
     51          };
     52          
     53          void SY_restart(){
     54            MODEL.SYNC.next_sync_send = 0;
     55            MODEL.SYNC.next_time_recv = 0;
     56            MODEL.SYNC.last_time_recv = 0;
     57            retransmite = 0;
     58          }
     59          
     60          static void Cold_Start(void){
     61          };
     62          
     63          static inline bool validate_sync(struct sync *sync){
     64            bool valid = 
     65              (sync->magic == MAGIC) &&
     66              (sync->panid == MODEL.SYNC.panid);
     67            return valid;
     68          }
     69          
     70          static inline void accept_sync_data(struct sync *sync){
     71            MODEL.RTC.rtc = sync->rtc;
     72          };
     73          
     74          static inline void syncronize_timer(struct frame *frame){
     75            nwtime_t now = AT_time();
     76            // Время прошедшее с момента получения пакета
     77            // RI_Send корректриует время, чтобы SFD был передан в SEND_TIME
     78            // Поэтому нам корректировать ненужно
     79            nwtime_t passed = AT_interval(now, frame->meta.TIMESTAMP);  
     80            AT_set_time(SYNC_TIME + passed);
     81            MODEL.SYNC.sync_err = SYNC_TIME - frame->meta.TIMESTAMP;
     82            LOG_ON("Sync err %d", MODEL.SYNC.sync_err);
     83          };
     84          
     85          static inline void mode_1_receive_process(void){
     86            LOW(PIN1);
     87            struct frame *fr = recv_sync();
     88            if (!fr)
     89              return;
     90            
     91            struct sync *sync = (struct sync*)(fr->payload);
     92            if (!validate_sync(sync)){
     93              FR_delete(fr);
     94              return;
     95            }
     96            syncronize_timer(fr);
     97            accept_sync_data(sync);
     98            FR_delete(fr);
     99            LOG_ON("Sichronize sync RSSI = %d", fr->meta.RSSI_SIG);
    100            retransmite = RETRANSMITE_TRY;
    101            MODEL.SYNC.next_time_recv = MODEL.RTC.uptime + SEND_PERIOD;
    102            MODEL.SYNC.last_time_recv = MODEL.RTC.uptime;   
    103            HIGH(PIN1);
    104          }
    105          
    106          static inline bool _throw_dice(void){
    107            return  ((rand() % 100) <= PROBABILIT) ? true : false;
    108          };
    109          
    110          static inline void mode_1_retransmition_process(void){
    111            retransmite--;
    112            if (!_throw_dice())
    113              return;
    114            send_sync();
    115            retransmite = 0;
    116          }
    117          
    118          static void mode_1_process(){
    119           // Прием, ретрансляция, синхронизация   
    120            if ( MODEL.RTC.uptime >= MODEL.SYNC.next_time_recv)
    121              mode_1_receive_process();
    122            else if(retransmite)
    123              mode_1_retransmition_process();
    124            
    125            if (MODEL.RTC.uptime - MODEL.SYNC.last_time_recv > UNSYNC_TIME){
    126              MODEL.SYNC.synced = false;
    127              MODEL.SYNC.mode = 0;
    128              MODEL.TM.MODE = 0;
    129              LOG_ON("unsynced");
    130            }
    131          }
    132          
    133          /**
    134          * brief Сканирование энергии в канале
    135          *
    136          * Работает только в режиме шлюза.
    137          */
    138          static void energy_scan(){
    139            static channel_t scan_channel = CH11;
    140            int8_t rssi_sig;
    141            
    142            RI_Measure_POW(scan_channel, 8000, &rssi_sig);
    143            // Сохраняем пиковые значения
    144            if (rssi_sig > MODEL.PWR_SCAN.energy[scan_channel - 11])
    145              MODEL.PWR_SCAN.energy[scan_channel - 11] = rssi_sig;
    146            
    147            scan_channel++;
    148            if (scan_channel > CH28)
    149              scan_channel = CH11;
    150          };
    151          
    152          static void mode_2_process(){
    153            // Периодическое вещание
    154            if ( MODEL.RTC.uptime < MODEL.SYNC.next_sync_send){
    155              energy_scan();
    156              return;
    157            }
    158            MODEL.SYNC.next_sync_send = MODEL.RTC.uptime + SEND_PERIOD;
    159            LOW(PIN1);
    160            send_sync();
    161            HIGH(PIN1);
    162          }
    163          
    164          static void Hot_Start(void){
    165            if (MODEL.TM.timeslot != SYNC_TS)
    166              return;
    167            switch(MODEL.SYNC.mode){
    168              case MODE_0: break;
    169              case MODE_1: mode_1_process(); break;
    170              case MODE_2: mode_2_process(); break;
    171              default:
    172              HALT("Wrong mode");
    173            }
    174          };
    175          
    176          static struct frame* recv_sync(void){
    177            if(!RI_SetChannel(MODEL.SYNC.sync_channel))
    178              HALT("Wrong channel");
    179            struct frame *frame;
    180            
    181            AT_wait(SYNC_TIME - NEG_RECV_OFFSET);
    182            ustime_t recv_time = NWTIME_TO_US(NEG_RECV_OFFSET + POS_RECV_OFFSET);
    183            TRY{
    184              frame = RI_Receive(recv_time);
    185              if (!frame)
    186                THROW(1);
    187              if (frame->len != sizeof(struct sync))
    188                THROW(2);
    189              AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
    190              return frame;
    191            }
    192            CATCH(1){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    193              return NULL;
    194            }
    195            CATCH(2){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    196              FR_delete(frame);
    197              return NULL;
    198            }
    199            ETRY;
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    200            return frame;
    201          }
    202          
    203          static bool send_sync(void){
    204            struct sync sync;
    205            sync.sys_ch = MODEL.SYNC.sys_channel;
    206            sync.tx_power = MODEL.RADIO.power_tx;
    207            sync.panid = MODEL.SYNC.panid;
    208            sync.rtc = MODEL.RTC.rtc;
    209            sync.magic = MAGIC;
    210            
    211            struct frame *fr = FR_create();
    212            ASSERT(fr);
    213            FR_add_header(fr, &sync, sizeof(struct sync));
    214            
    215            AES_StreamCoder(true, fr->payload, fr->payload, fr->len);
    216            
    217            bool set_ch_res = RI_SetChannel(MODEL.SYNC.sync_channel);
    218            ASSERT(set_ch_res);
    219            bool res = RI_Send_time(fr, (nwtime_t)SYNC_TIME);
    220            FR_delete(fr);
    221            LOG_ON("SYNC sended, res = %d", res);
    222            return res;
    223          }
    224          
    225          static struct frame* network_recv_sync(ustime_t timeout){
    226            if(!RI_SetChannel(MODEL.SYNC.sync_channel))
    227              HALT("Wrong channel");
    228            
    229            struct frame *frame = NULL;
    230            TRY{
    231              frame = RI_Receive(timeout);
    232              if (!frame)
    233                THROW(1);
    234              if (frame->len != sizeof(struct sync))
    235                THROW(2);
    236              AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
    237              return frame;
    238            }
    239            CATCH(1){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    240              return NULL;
    241            }
    242            CATCH(2){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    243              FR_delete(frame);
    244              return NULL;
    245            }
    246            ETRY;
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    247            return frame;
    248          }
    249          
    250          bool network_sync(ustime_t timeout){  
    251            stamp_t now = UST_now();
    252            struct frame *frame;
    253            struct sync *sync;
    254            
    255            TRY{
    256              while(true){
    257                if(UST_time_over(now, timeout))
    258                   THROW(1);
    259                
    260                frame = network_recv_sync(timeout);
    261                if (!frame)
    262                   continue;
    263                
    264                sync = (struct sync*)frame->payload;
    265                if (sync->magic != MAGIC){
    266                  FR_delete(frame);
    267                  continue;
    268                }
    269               
    270                syncronize_timer(frame);
    271                
    272                MODEL.SYNC.synced = true;
    273                MODEL.SYNC.sys_channel = sync->sys_ch;
    274                MODEL.SYNC.panid = sync->panid;
    275                MODEL.RADIO.power_tx = sync->tx_power;
    276                MODEL.RTC.rtc = sync->rtc;
    277                
    278                retransmite = RETRANSMITE_TRY;
    279                MODEL.SYNC.next_time_recv = MODEL.RTC.uptime +  SEND_PERIOD ;
    280                MODEL.SYNC.last_time_recv = MODEL.RTC.uptime;     
    281                break;
    282              }
    283            }
    284            CATCH(1){
    285              FR_delete(frame);
    286              return false; // timeout
    287            }
    288            FINALLY{
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"

  static void SW_Init(void){
              ^
"E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c",34  Warning[Pe177]: function
          "SW_Init" was declared but never referenced
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c"

  static struct frame* get_frame(void){
                       ^
"E:\Neocore\Hardware\PRG Node\main.c",13  Warning[Pe177]: function "get_frame"
          was declared but never referenced
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\main.c"

  static unsigned long LAST_TIME_CARD_RECIEVED;
                       ^
"E:\Neocore\Hardware\PRG Node\neigh.c",36  Warning[Pe550]: variable
          "LAST_TIME_CARD_RECIEVED" was set but never used
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\neigh.c"

  static struct route_record ROUTE_TABLE[ROUTE_TABLE_ITEMS];
                             ^
"E:\Neocore\Hardware\PRG Node\route.c",18  Warning[Pe177]: variable
          "ROUTE_TABLE" was declared but never referenced
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRG Node\route.c"
    289              FR_delete(frame);
    290            }
    291            ETRY;
    292            return true;  
    293          }
E:\Neocore\Hardware\STACK_CORE_SRC\time_manager.c
      1          #include "time_manager.h"
      2          #include "model.h"
      3          #include "action_manager.h"
      4          #include "debug.h"
      5          #include "cpu.h"
      6          #include "macros.h"
      7          #include "LLC.h"
      8          
      9          /**
     10          @file
     11          */
     12          
     13          #define MAX_TIME_SLOTS 50
     14          
     15          #define ACTIVE_INTERVAL (nwtime_t)327 // 9.979 мс
     16          #define SLEEP_INTERVAL (nwtime_t)327  // 9.979 мс
     17          #define UNACCOUNTED 68 // Остаток времени после 50ого интервала.
     18          #define FULL_INTERVAL (ACTIVE_INTERVAL + SLEEP_INTERVAL)
     19          #define SLOT_TO_NWTIME(slot) ((nwtime_t)((slot) * FULL_INTERVAL)) 
     20          #define NWTIME_TO_SLOT(nwtime) ((timeslot_t)((time)/FULL_INTERVAL))
     21           
     22          //!< Список задач менеджера. Индекс - номер слота, значение-действие
     23          static char ALARMS[MAX_TIME_SLOTS];
     24          
     25          
     26          void TM_SetAlarm(timeslot_t slot, char alarm){
     27            ASSERT(slot < MAX_TIME_SLOTS);
     28            ALARMS[slot] |= alarm;
     29          }
     30          
     31          void TM_ClrAlarm(timeslot_t slot, char alarm){
     32            ASSERT(slot < MAX_TIME_SLOTS);
     33            ALARMS[slot] &= ~alarm;
     34          }
     35          
     36          static inline timeslot_t _inc_timeslot(timeslot_t slot){
     37            slot++;
     38            return (slot >= MAX_TIME_SLOTS) ? 0 : slot;
     39          }
     40          
     41          static inline timeslot_t _find_next_active(timeslot_t slot){
     42            slot = _inc_timeslot(slot);
     43            while (slot && !ALARMS[slot])
     44              slot = _inc_timeslot(slot);
     45            return slot;
     46          }
     47          
     48          static void scheulder_next_alarm(nwtime_t time){
     49            timeslot_t slot = NWTIME_TO_SLOT(time);
     50            slot = _find_next_active(slot);
     51            AT_set_alarm(SLOT_TO_NWTIME(slot));
     52          }
     53          
     54          void TM_IRQ(nwtime_t time){
     55            if (MODEL.TM.MODE == 0){
     56              AT_enable(false);
     57              return;
     58            }
     59            
     60            ATOMIC_BLOCK_RESTORE{     
     61              MODEL.TM.timeslot = NWTIME_TO_SLOT(time);
     62              MODEL.TM.time = time;
     63              MODEL.TM.alarm = ALARMS[ MODEL.TM.timeslot];
     64              scheulder_next_alarm(time);
     65              AM_Hot_start();
     66              AM_Cold_start();
     67            };
     68          }
     69          
     70          static inline void mcu_sleep(void){
     71            SLEEPCMD = 2; // Режим PM2
     72            PCON = 1;
     73          }
     74          
     75          static inline void _clr_all(void){
     76            for_each_type(char, ALARMS, i)
     77              *i = 0;
     78          }
     79          
     80          static void init(void){
     81            _clr_all();
     82            scheulder_next_alarm(0);
     83            AT_enable(true);
     84          }
     85          
     86          static void start_mode_1(void){
     87            AM_IRQ_Init();
     88            init();
     89            while (true){
     90              mcu_sleep();
     91              if (MODEL.TM.MODE == 0){
     92                AT_enable(false);
     93                break;
     94              }
     95            AM_Callback();       
     96            }  
     97          }
     98          
     99          static void start_mode_2(void){
    100            AM_IRQ_Init();
    101            init();
    102          }
    103          
    104          void Neocore_start(void){
    105            FR_restart(); // Уничтожает все пакеты и mem_slot.
    106            LLC_restart(); // Убираем все пакеты на передачу
    107            switch (MODEL.TM.MODE){
    108            case 0:
    109              return;
    110            case 1:
    111              start_mode_1();
    112              break;
    113            case 2:
    114              start_mode_2();
    115              break;
    116            default: 
    117              HALT("Incorrect MODEL.TM.MODE");
    118            }
    119          }
E:\Neocore\Hardware\STACK_CORE_SRC\ustimer.c
      1          #include "ioCC2530.h"
      2          #include "ustimer.h"
      3          #include "stdint.h"
      4          #include "action_manager.h"
      5          #include "stdbool.h"
      6          
      7          
      8          #define ACCURATE_VAL_US 500 
      9          
     10          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     11          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     12          static uint32_t DELAY_CALIBRATE_TICS; // Калибровка функции задержки
     13          
     14          static void DelayCalibrate(void);
     15          static void HW_Init(void);  
     16          module_s UST_MODULE = {ALIAS(HW_Init)};
     17          
     18          
     19          void HW_Init(void){
     20            // Запускаем таймер, LATCH MODE = 1
     21            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     22            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     23            T2CTRL = (1<<0) | (1<<3); 
     24            // Калибровка функции задержки
     25            DelayCalibrate();
     26          }
     27          
     28          ustime_t UST_now(void){
     29            ustime_t now;
     30            ((char*)&now)[0] = T2M0;
     31            ((char*)&now)[1] = T2M1;
     32            ((char*)&now)[2] = T2MOVF0;
     33            ((char*)&now)[3] = T2MOVF1;
     34            return now;
     35          }
     36          
     37          bool UST_time_over(stamp_t beg, ustime_t wait){
     38            stamp_t now = UST_now(); 
     39            ustime_t delta = UST_interval(beg, now);
     40            return (delta > wait) ?  true:false;
     41          }
     42          
     43          ustime_t UST_interval(stamp_t beg, stamp_t end){
     44            return (end >= beg) ? 
     45              TICKS_TO_US(end - beg) :
     46              TICKS_TO_US(MAC_TIMER_MAX - beg + end);
     47          };
     48          
     49          void UST_delay(ustime_t time){
     50            stamp_t now = UST_now();
     51            stamp_t len = US_TO_TICKS(time);
     52            stamp_t offset = (time > DELAY_CALIBRATE_TICS) ?
     53                              DELAY_CALIBRATE_TICS : 0;
     54            while (UST_now() < (now + len - offset));
     55          }
     56          
     57          
     58          stamp_t _interval(stamp_t beg, stamp_t end){
     59            return (end >= beg) ? 
     60              (end - beg) :
     61              (MAC_TIMER_MAX - beg + end);
     62          };
     63          
     64          /**
     65          @brief Калибровка функции задержки TIM_delay
     66          */
     67          static void DelayCalibrate(void){
     68            DELAY_CALIBRATE_TICS = 0;  
     69            stamp_t start = UST_now();
     70            UST_delay(ACCURATE_VAL_US);
     71            stamp_t end = UST_now();
     72            DELAY_CALIBRATE_TICS = _interval(start, end) -
     73                                    US_TO_TICKS(ACCURATE_VAL_US);
     74          };

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     74   AES_CCMDecrypt
        0     68   -> CBCMAC_buf_encrypt
        0     72   -> CTR_enc_decrypt
        0     70   -> generateAuthData
        0     70   -> memcpy
        0     70   -> memset
      1     58   AES_CCMEncrypt
        0     52   -> CBCMAC_buf_encrypt
        0     56   -> CTR_enc_decrypt
        0     54   -> generateAuthData
        0     54   -> memcpy
        0     54   -> memset
      0    106   AES_StreamCoder
        0     43   -> memcpy
        0     43   -> memset
      0     12   AM_Callback
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     21   AM_Cold_start
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     22   AM_HW_Init
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     21   AM_Hot_start
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     12   AM_IRQ_Init
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     22   AM_SW_Init
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     22   AM_set_callback
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     18   AT_enable
        0      9   -> IRQEnable
        0      9   -> __cli
      0     14   AT_interval
      0     28   AT_set_alarm
        0     12   -> DBG_CORE_HALT
        0     12   -> IRQEnable
        0     12   -> calcCompareTime
        0     12   -> loadTimerCompare
        0     12   -> printf_P
        0     14   -> printf_P
      0     30   AT_set_time
        0     14   -> AT_set_alarm
        0     14   -> DBG_CORE_HALT
        0     14   -> ReadTimer
        0     14   -> isIRQEnable
        0     14   -> printf_P
        0     16   -> printf_P
      0     83   AT_time
        0     16   -> ReadTimer
      0     77   AT_wait
        0     12   -> DBG_CORE_HALT
        0     12   -> printf_P
        0     14   -> printf_P
      0     23   AUTH_ETH_Receive
        0     12   -> DBG_CORE_HALT
        0     12   -> FR_del_header
        0     12   -> printf_P
        0     14   -> printf_P
        0     12   -> receiveCMD_Request
        0     12   -> receiveCMD_Response
      2     10   AUTH_ETH_TimeAlloc
        2      0   -> AUTH_request
      2     39   AUTH_request
        0     37   -> DBG_CORE_HALT
        0     37   -> FR_add_header
        0     37   -> FR_create
        0     37   -> eth_send
        0     37   -> printf_P
        0     39   -> printf_P
      0    118   CBCMAC_buf_encrypt
        0     50   -> memcpy
        0     50   -> memset
      0     12   CF_init
        0     12   -> memcpy
      0    111   CTR_enc_decrypt
        0     39   -> memcpy
        0     39   -> memset
      0      0   Cold_Start
      0      0   Cold_Start
      0      0   Cold_Start
      2      0   Cold_Start
        2      0   -> scheduler_rx
        2      0   -> scheduler_tx
      0      0   DBG_CORE_FAULT
      0     63   DBG_CORE_HALT
      0     24   DelayCalibrate
        0     20   -> UST_delay
        0     20   -> UST_now
        0     24   -> _interval
      1     56   FR_add_header
        0     19   -> MEM_memcpy
        0     19   -> mem_move
      2      0   FR_available
        2      0   -> SL_available
      2      0   FR_busy
        2      0   -> SL_busy
      2     37   FR_create
        2      0   -> SL_alloc
      1     30   FR_del_header
        0     18   -> MEM_memcpy
        0     18   -> MEM_memset
      0     82   FR_delete
        0      9   -> SL_free
      0     19   FR_find_rx
        0      9   -> SL_find_rx
      0     19   FR_find_tx
        0      9   -> SL_find_tx
      0      9   FR_is_rx
        0      9   -> SL_is_rx
      0      9   FR_is_tx
        0      9   -> SL_is_tx
      2     10   FR_restart
        2      0   -> SW_restart
      2      0   FR_rx_frames
        2      0   -> SL_rx_slots
      0     21   FR_set_rx
        0      9   -> SL_set_rx
      0     19   FR_set_tx
        0      9   -> SL_set_tx
      2      0   FR_tx_frames
        2      0   -> SL_tx_slots
      2      0   HP_Init
        2      0   -> AM_set_callback
      2      0   HP_callback
        2      0   -> ethernet_process
      0      0   HW_Init
      2      0   HW_Init
        2      0   -> IRQEnable
      2     84   HW_Init
        2     84   -> MEM_memcpy
      2      0   HW_Init
        2      0   -> uart_init
      0      0   HW_Init
      0      0   HW_Init
      3      1   HW_Init
      2      0   HW_Init
        2      0   -> DelayCalibrate
      0      0   Hot_Start
      0      9   Hot_Start
        0      9   -> receive
        0      9   -> transmite
      0     12   Hot_Start
      0     12   Hot_Start
        0     10   -> DBG_CORE_HALT
        0     10   -> mode_1_process
        0     10   -> mode_2_process
        0     10   -> printf_P
        0     12   -> printf_P
      0      9   IP_Receive
      0     15   IRQEnable
      2      0   IRQ_Init
      0      0   IRQ_Init
      0     31   LLC_add_tx_frame
        0     10   -> AES_StreamCoder
        0     10   -> DBG_CORE_HALT
        0     10   -> FR_set_tx
        0     10   -> printf_P
        0     12   -> printf_P
      0     12   LLC_close_slot
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      1     22   LLC_open_slot
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      2     10   LLC_restart
        2      0   -> SW_Init
      2     61   LoadTXData
      1     23   MAC_Receive
        0     12   -> AES_StreamCoder
        0     12   -> FR_set_rx
        0     12   -> _recv_frame
        0     12   -> _send_ack
        0     12   -> printf_P
        0     14   -> printf_P
      0     23   MAC_Send
        0      9   -> FR_delete
        0      9   -> _recv_ack
        0      9   -> _send_frame
      3     84   MEM_memcpy
      3     18   MEM_memset
      0     18   NP_Receive
        0      9   -> frame_filter_card
        0      9   -> frame_filter_cmd_req
        0      9   -> process_card
        0      9   -> process_cmd_req
      0     10   NP_TimeAlloc
      0     12   Neocore_start
        0     10   -> DBG_CORE_HALT
        0     10   -> FR_restart
        0     10   -> LLC_restart
        0     10   -> printf_P
        0     12   -> printf_P
        0     10   -> start_mode_1
        0     10   -> start_mode_2
      1     29   RI_Measure_POW
        0     14   -> UST_delay
      1    103   RI_Receive
        0     36   -> DBG_CORE_HALT
        0     36   -> FR_add_header
        0     36   -> FR_create
        0     38   -> RecvData
        0     40   -> UST_interval
        0     36   -> UST_now
        0     36   -> UnLoadRXData
        0     36   -> pre_config
        0     36   -> printf_P
        0     38   -> printf_P
      0     47   RI_Send
        0     30   -> DBG_CORE_HALT
        0     30   -> SendData
        0     34   -> UST_interval
        0     30   -> UST_now
        0     30   -> pre_config
        0     30   -> printf_P
        0     32   -> printf_P
      0     57   RI_Send_time
        0     32   -> DBG_CORE_HALT
        0     32   -> SendData
        0     36   -> UST_interval
        0     32   -> UST_now
        0     32   -> pre_config
        0     32   -> printf_P
        0     34   -> printf_P
      2     63   RI_SetChannel
      0     19   RP_Receive
        0      9   -> AUTH_ETH_Receive
        0      9   -> IP_Receive
        0      9   -> NP_Receive
        0      9   -> TB_Receive
      0      0   RP_Send
      0      0   RP_SendRT_GW
      0      0   RP_SendRT_RT
      0      0   RP_Send_GW
      0     10   RP_TimeAlloc
      2     22   ReadTimer
      0    109   RecvData
        0     67   -> AT_time
        0     67   -> UST_now
        0     71   -> UST_time_over
      0     15   SL_alloc
        0     15   -> MEM_memset
        0     15   -> __cli
      0     12   SL_available
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     12   SL_busy
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      2      9   SL_find_rx
      2      9   SL_find_tx
      0     18   SL_free
        0      9   -> __cli
        0      9   -> _free
      2      9   SL_is_rx
      2      9   SL_is_tx
      2      0   SL_rx_slots
      0     18   SL_set_rx
        0      9   -> __cli
      0     18   SL_set_tx
        0      9   -> __cli
      2      0   SL_tx_slots
      2      0   SL_zone_check
      0      0   SW_Init
      0      0   SW_Init
      2      0   SW_Init
      0      0   SW_Init
      2      0   SW_Init
        2      0   -> random_core_init
      2      0   SW_Init
      0     13   SW_Init
        0     13   -> MEM_memset
      0      0   SW_Init
      2      0   SW_Init
      2      0   SW_restart
        2      0   -> SW_Init
      2      0   SY_restart
      0     93   SendData
        0     61   -> AT_time
        0     61   -> AT_wait
        0     61   -> LoadTXData
      0      9   TB_Receive
      0     26   TM_ClrAlarm
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     24   TM_IRQ
        0      9   -> AM_Cold_start
        0      9   -> AM_Hot_start
        0      9   -> AT_enable
        0      9   -> __cli
        0      9   -> scheulder_next_alarm
      0     22   TM_SetAlarm
        0     10   -> DBG_CORE_HALT
        0     10   -> printf_P
        0     12   -> printf_P
      0     15   TimerCompareInterrupt
        0     15   -> AT_time
        0     15   -> IRQEnable
        0     15   -> TM_IRQ
      0     52   UST_delay
        0     32   -> UST_now
      0     64   UST_interval
      3     77   UST_now
      0    105   UST_time_over
        0     28   -> UST_interval
        0     24   -> UST_now
      3     36   UnLoadRXData
      0      9   __cli
      0     15   __cli
      0      9   __cli
      2      0   _clr_all
      0     18   _find_next_active
        0      9   -> _inc_timeslot
      2      9   _free
      0      9   _inc_timeslot
      0     48   _interval
      0      9   _recv_ack
      0     30   _recv_frame
        0     16   -> AT_time
        0     16   -> DBG_CORE_HALT
        0     16   -> RI_Receive
        0     16   -> RI_SetChannel
        0     16   -> printf_P
        0     18   -> printf_P
      1     25   _send_ack
        0     13   -> FR_add_header
        0     13   -> FR_create
        0     13   -> FR_delete
        0     13   -> RI_Send
        0     13   -> xor_calc
      0     23   _send_frame
        0     12   -> DBG_CORE_HALT
        0     12   -> RI_Send
        0     12   -> RI_SetChannel
        0     12   -> UST_delay
        0     12   -> printf_P
        0     14   -> printf_P
      0     10   _throw_dice
        0     10   -> rand
      0     23   accept_sync_data
      0      9   bits_count
      2     34   calcCompareTime
        0     22   -> ReadTimer
      0     17   calc_weight
      0     28   calc_xor
      0     12   callback
        0     10   -> LLC_open_slot
        0     10   -> ethernet_process
        0     10   -> printf_P
        0     12   -> printf_P
      1     27   energy_scan
        0     15   -> RI_Measure_POW
      1     58   eth_send
        0     19   -> DBG_CORE_HALT
        0     19   -> FR_add_header
        0     19   -> LLC_add_tx_frame
        0     19   -> calc_xor
        0     19   -> printf_P
        0     21   -> printf_P
      0     28   ethernet_process
        0     10   -> AUTH_ETH_TimeAlloc
        0     10   -> FR_delete
        0     10   -> FR_find_rx
        0     10   -> NP_TimeAlloc
        0     10   -> RP_TimeAlloc
        0     10   -> parse_frame
        0     10   -> printf_P
        0     12   -> printf_P
        0     18   -> printf_P
      1     19   fill_meta_data
      2     17   find_free_index
      2     12   find_index
      0     26   frame_filter
        0     14   -> calc_xor
        0     14   -> printf_P
        0     16   -> printf_P
      2      9   frame_filter_card
      2      9   frame_filter_cmd_req
      0     88   generateAuthData
        0     18   -> memcpy
      2      9   getRNDByte
      2      0   init
        2      0   -> AT_enable
        2      0   -> _clr_all
        2      0   -> scheulder_next_alarm
      0     31   insert_record
        0     17   -> calc_weight
        0     17   -> find_free_index
        0     17   -> printf_P
        0     19   -> printf_P
        0     17   -> update_record
      0     14   isIRQEnable
      0     28   loadTimerCompare
      0      2   main
        0      0   -> AM_SW_Init
        0      0   -> Neocore_start
        0      0   -> network_sync
        0      0   -> pre_init
        0      0   -> printf_P
        0      2   -> printf_P
      0      0   mcu_sleep
      1     28   mem_move
      2     24   mode_1_process
        0     12   -> mode_1_receive_process
        0     12   -> mode_1_retransmition_process
        0     12   -> printf_P
        0     14   -> printf_P
      0     28   mode_1_receive_process
        0     14   -> FR_delete
        0     14   -> accept_sync_data
        0     14   -> printf_P
        0     16   -> printf_P
        0     14   -> recv_sync
        0     14   -> syncronize_timer
        0     14   -> validate_sync
      2     12   mode_1_retransmition_process
        2      0   -> _throw_dice
        2      0   -> send_sync
      0     22   mode_2_process
        0     12   -> energy_scan
        0     12   -> send_sync
      0    138   network_recv_sync
        0     63   -> AES_StreamCoder
        0     63   -> DBG_CORE_HALT
        0     63   -> FR_delete
        0     63   -> RI_Receive
        0     63   -> RI_SetChannel
        0     63   -> printf_P
        0     65   -> printf_P
      0     77   network_sync
        0     73   -> FR_delete
        0     73   -> UST_now
        0     77   -> UST_time_over
        0     73   -> network_recv_sync
        0     73   -> syncronize_timer
      0     22   parse_frame
        0     10   -> FR_del_header
        0     10   -> RP_Receive
        0     10   -> fill_meta_data
        0     10   -> frame_filter
        0     10   -> printf_P
        0     12   -> printf_P
      2     36   pre_config
        2      0   -> setFreq
      0     12   pre_init
        0     10   -> AM_HW_Init
        0     10   -> AM_SW_Init
        0     10   -> AM_set_callback
        0     10   -> printf_P
        0     12   -> printf_P
      0     23   process_card
        0     12   -> find_index
        0     12   -> insert_record
        0     12   -> printf_P
        0     14   -> printf_P
        0     12   -> update_record
      0     23   process_cmd_req
        0     12   -> printf_P
        0     14   -> printf_P
        0     12   -> send_card
      0      0   putchar
      0      9   random_core_init
        0      9   -> pre_config
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      0     18   readRandom
        0      9   -> bits_count
        0      9   -> getRNDByte
      0     18   receive
        0      9   -> MAC_Receive
      0     24   receiveCMD_Request
        0     10   -> printf_P
        0     12   -> printf_P
      1     26   receiveCMD_Response
        0     12   -> printf_P
        0     14   -> printf_P
      0     79   recv_sync
        0     63   -> AES_StreamCoder
        0     63   -> AT_wait
        0     63   -> DBG_CORE_HALT
        0     63   -> FR_delete
        0     63   -> RI_Receive
        0     63   -> RI_SetChannel
        0     63   -> printf_P
        0     65   -> printf_P
      0     12   scheduler_rx
        0     10   -> DBG_CORE_HALT
        0     10   -> TM_ClrAlarm
        0     10   -> TM_SetAlarm
        0     10   -> printf_P
        0     12   -> printf_P
      0     12   scheduler_tx
        0     10   -> DBG_CORE_HALT
        0     10   -> FR_find_tx
        0     10   -> TM_SetAlarm
        0     10   -> printf_P
        0     12   -> printf_P
      0     18   scheulder_next_alarm
        0      9   -> AT_set_alarm
        0      9   -> _find_next_active
      0     12   send_card
      1     35   send_sync
        0     21   -> AES_StreamCoder
        0     21   -> DBG_CORE_HALT
        0     21   -> FR_add_header
        0     21   -> FR_create
        0     21   -> FR_delete
        0     21   -> RI_Send_time
        0     21   -> RI_SetChannel
        0     21   -> printf_P
        0     23   -> printf_P
      1     13   setFreq
        0     11   -> DBG_CORE_HALT
        0     11   -> printf_P
        0     13   -> printf_P
      2     10   start_mode_1
        2      0   -> AM_Callback
        2      0   -> AM_IRQ_Init
        2      0   -> AT_enable
        2      0   -> init
        2      0   -> mcu_sleep
      2     10   start_mode_2
        2      0   -> AM_IRQ_Init
        2      0   -> init
      0     89   syncronize_timer
        0     14   -> AT_interval
        0     14   -> AT_set_time
        0     14   -> AT_time
        0     14   -> printf_P
        0     16   -> printf_P
      0     25   transmite
        0     14   -> DBG_CORE_HALT
        0     14   -> MAC_Send
        0     14   -> TM_ClrAlarm
        0     14   -> printf_P
        0     16   -> printf_P
      0      0   uart_init
      1     29   update_record
        0     12   -> calc_weight
      0     26   validate_sync
      0     22   xor_calc


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      33  ?<Constant "(ch >= MIN_CH) && (ch...">
       3  ?<Constant "->">
       3  ?<Constant "->">_1
       3  ?<Constant "->">_10
       3  ?<Constant "->">_11
       3  ?<Constant "->">_2
       3  ?<Constant "->">_3
       3  ?<Constant "->">_4
       3  ?<Constant "->">_5
       3  ?<Constant "->">_6
       3  ?<Constant "->">_7
       3  ?<Constant "->">_8
       3  ?<Constant "->">_9
       5  ?<Constant ":%d:">
       5  ?<Constant ":%d:">_1
       5  ?<Constant ":%d:">_10
       5  ?<Constant ":%d:">_11
       5  ?<Constant ":%d:">_2
       5  ?<Constant ":%d:">_3
       5  ?<Constant ":%d:">_4
       5  ?<Constant ":%d:">_5
       5  ?<Constant ":%d:">_6
       5  ?<Constant ":%d:">_7
       5  ?<Constant ":%d:">_8
       5  ?<Constant ":%d:">_9
      23  ?<Constant "ACTIONSLOTS[0].rx == 0">
      29  ?<Constant "AUTH REQ received and...">
      19  ?<Constant "AUTH req add to tx">
      18  ?<Constant "AUTH_ETH Response">
      25  ?<Constant "AUTH_ETH frame filltered">
      23  ?<Constant "AUTH_ETH receive frame">
      33  ?<Constant "AUTH_ETH request filt...">
      18  ?<Constant "Access depricated">
      16  ?<Constant "Attempts exired">
      21  ?<Constant "Better card inserted">
       9  ?<Constant "CALLBACK">
      12  ?<Constant "CCA/ACK err">
      22  ?<Constant "CMD reques processed.">
      32  ?<Constant "COLD_MOD[i]->Cold_Sta...">
      15  ?<Constant "Card inserted.">
      26  ?<Constant "Card is bad. not inse...">
      18  ?<Constant "Delete eth header">
      34  ?<Constant "ETH. LEN:%d, TS:%d, C...">
       6  ?<Constant "Error">
      17  ?<Constant "Extract response">
      14  ?<Constant "Fill metadata">
      22  ?<Constant "Filtered ETH_LAY_SIZE">
      21  ?<Constant "Filtered ETH_VER. %d">
      17  ?<Constant "Filtered NSRC_CH">
      17  ?<Constant "Filtered NSRC_TS">
      13  ?<Constant "Filtered XOR">
      19  ?<Constant "Filtered node addr">
      15  ?<Constant "Filtered panid">
       9  ?<Constant "Find rx!">
      31  ?<Constant "Frame AUTH_ETH_RESP w...">
      13  ?<Constant "Frame Filter">
      30  ?<Constant "HOT_MOD[i]->Hot_Start...">
      27  ?<Constant "HW_MOD[i]->HW_Init !=...">
      16  ?<Constant "Hardware inited">
      29  ?<Constant "IRQ_MOD[i]->IRQ_Init ...">
      24  ?<Constant "Incorrect MODEL.TM.MODE">
      24  ?<Constant "Node auth ok! ipaddr=%d">
      13  ?<Constant "Node started">
      15  ?<Constant "Route protocol">
      13  ?<Constant "START RESYNC">
      27  ?<Constant "SW_MOD[i]->SW_Init !=...">
      22  ?<Constant "SYNC sended, res = %d">
      13  ?<Constant "Send success">
      26  ?<Constant "Sichronize sync RSSI ...">
      12  ?<Constant "Sync err %d">
       7  ?<Constant "Synced">
      17  ?<Constant "Unrecognized cmd">
      12  ?<Constant "Update card">
      14  ?<Constant "Wrong channel">
      14  ?<Constant "Wrong channel">_1
      11  ?<Constant "Wrong mode">
       3  ?<Constant "\r\n">
       3  ?<Constant "\r\n">_1
       3  ?<Constant "\r\n">_2
       3  ?<Constant "\r\n">_3
       3  ?<Constant "\r\n">_4
       3  ?<Constant "\r\n">_5
       3  ?<Constant "\r\n">_6
      17  ?<Constant "action_manager.c">
       6  ?<Constant "add_h">
      20  ?<Constant "alarm <= MAX_NWTIME">
      14  ?<Constant "alarm_timer.c">
      11  ?<Constant "auth_eth.c">
      14  ?<Constant "callback exit">
      29  ?<Constant "ch >= MIN_CH && ch <=...">
      11  ?<Constant "ethernet.c">
       3  ?<Constant "fn">
      11  ?<Constant "fr != NULL">
       3  ?<Constant "fr">
       6  ?<Constant "frame">
       6  ?<Constant "frame">_1
       6  ?<Constant "llc.c">
       6  ?<Constant "mac.c">
       7  ?<Constant "main.c">
      12  ?<Constant "mem_slots.c">
       8  ?<Constant "neigh.c">
       5  ?<Constant "push">
       8  ?<Constant "radio.c">
       4  ?<Constant "res">
       4  ?<Constant "res">_1
      11  ?<Constant "set_ch_res">
      22  ?<Constant "slot < MAX_TIME_SLOTS">
      29  ?<Constant "slot_busy <= SLOT_POO...">
       7  ?<Constant "sync.c">
      19  ?<Constant "time <= MAX_NWTIME">
      15  ?<Constant "time_manager.c">
      26  ?<Constant "ts >= 1 && ts < MAX_S...">
      23  ?<Constant "tx_frame->meta.TS != 0">
       9  ?<Constant "unsynced">
       4  ?<Constant {(char *)0, 0, 0}>
       4  ?<Constant {(char *)0, 150, 0}>
       4  ?<Constant {(char *)0, 150, 0}>_1
       5  ?<Constant {(char *)MODEL.AES.CCM_IV, (char *)
       5  ?<Constant {(char *)MODEL.AES.CCM_KEY, (char *
       5  ?<Constant {(char *)MODEL.AES.STREAM_IV, (char
       5  ?<Constant {(char *)MODEL.AES.STREAM_KEY, (cha
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_1
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_2
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_3
      10  ?<Initializer for AT_MODULE>
      10  ?<Initializer for CODER_MODULE>
       6  ?<Initializer for COLD_MOD>
      10  ?<Initializer for CPU_MODULE>
      10  ?<Initializer for DBG_MODULE>
      10  ?<Initializer for DMA_MODULE>
      10  ?<Initializer for FR_MODULE>
       8  ?<Initializer for HOT_MOD>
      16  ?<Initializer for HW_MOD>
       4  ?<Initializer for IRQ_MOD>
      10  ?<Initializer for LED_MODULE>
      10  ?<Initializer for LLC_MODULE>
      10  ?<Initializer for MAC_MODULE>
      10  ?<Initializer for MD_MODULE>
      10  ?<Initializer for MS_MODULE>
      10  ?<Initializer for RADIO_MODULE>
      10  ?<Initializer for RTC_MODULE>
      14  ?<Initializer for SW_MOD>
      10  ?<Initializer for SYNC_MODULE>
      10  ?<Initializer for UST_MODULE>
      16  ?<Initializer for default_iv>
      16  ?<Initializer for default_key>
       1  ?<Initializer for first>
       1  ?<Initializer for scan_channel>
     150  ACTIONSLOTS
     482  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     452  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     632  AES_StreamCoder
       6  AES_StreamCoder::?relay
      50  ALARMS
      90  AM_Callback
       6  AM_Callback::?relay
     197  AM_Cold_start
       6  AM_Cold_start::?relay
     185  AM_HW_Init
       6  AM_HW_Init::?relay
     197  AM_Hot_start
       6  AM_Hot_start::?relay
     193  AM_IRQ_Init
       6  AM_IRQ_Init::?relay
     189  AM_SW_Init
       6  AM_SW_Init::?relay
      80  AM_set_callback
       6  AM_set_callback::?relay
      10  AT_MODULE
      43  AT_enable
       6  AT_enable::?relay
      34  AT_interval
       6  AT_interval::?relay
     129  AT_set_alarm
       6  AT_set_alarm::?relay
     143  AT_set_time
       6  AT_set_time::?relay
      55  AT_time
       6  AT_time::?relay
     177  AT_wait
       6  AT_wait::?relay
     353  AUTH_ETH_Receive
       6  AUTH_ETH_Receive::?relay
      20  AUTH_ETH_TimeAlloc
       6  AUTH_ETH_TimeAlloc::?relay
     458  AUTH_request
       6  AUTH_request::?relay
       2  CALLBACK
     469  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
     100  CF_init
       6  CF_init::?relay
       1  CLKCONCMD
       1  CLKCONSTA
      10  CODER_MODULE
       6  COLD_MOD
       4  COMPARE_TIME
      45  CONFIG
      10  CPU_MODULE
     608  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
       3  Cold_Start
       3  Cold_Start
       3  Cold_Start
      23  Cold_Start
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       2  DBG_CORE_FAULT
       6  DBG_CORE_FAULT::?relay
       2  DBG_CORE_HALT
       6  DBG_CORE_HALT::?relay
      10  DBG_MODULE
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
      40  DMA_CH
      10  DMA_MODULE
     125  DelayCalibrate
       6  DelayCalibrate::?relay
       1  ENCCS
      10  FR_MODULE
     181  FR_add_header
       6  FR_add_header::?relay
      14  FR_available
       6  FR_available::?relay
      14  FR_busy
       6  FR_busy::?relay
      14  FR_create
       6  FR_create::?relay
     185  FR_del_header
       6  FR_del_header::?relay
      21  FR_delete
       6  FR_delete::?relay
      21  FR_find_rx
       6  FR_find_rx::?relay
      21  FR_find_tx
       6  FR_find_tx::?relay
      21  FR_is_rx
       6  FR_is_rx::?relay
      21  FR_is_tx
       6  FR_is_tx::?relay
      14  FR_restart
       6  FR_restart::?relay
      14  FR_rx_frames
       6  FR_rx_frames::?relay
      21  FR_set_rx
       6  FR_set_rx::?relay
      21  FR_set_tx
       6  FR_set_tx::?relay
      14  FR_tx_frames
       6  FR_tx_frames::?relay
       8  HOT_MOD
      18  HP_Init
       6  HP_Init::?relay
      14  HP_callback
       6  HP_callback::?relay
       3  HW_Init
      17  HW_Init
      19  HW_Init
      23  HW_Init
      37  HW_Init
      44  HW_Init
      63  HW_Init
     409  HW_Init
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
      16  HW_MOD
       3  Hot_Start
      41  Hot_Start
      48  Hot_Start
      87  Hot_Start
       6  Hot_Start::?relay
       6  Hot_Start::?relay
       6  Hot_Start::?relay
       6  Hot_Start::?relay
       3  IP_Receive
       6  IP_Receive::?relay
      17  IRQEnable
       6  IRQEnable::?relay
       3  IRQ_Init
      52  IRQ_Init
       6  IRQ_Init::?relay
       6  IRQ_Init::?relay
       4  IRQ_MOD
       4  LAST_TIME_CARD_RECIEVED
      10  LED_MODULE
      10  LLC_MODULE
     105  LLC_add_tx_frame
       6  LLC_add_tx_frame::?relay
     113  LLC_close_slot
       6  LLC_close_slot::?relay
     184  LLC_open_slot
       6  LLC_open_slot::?relay
      14  LLC_restart
       6  LLC_restart::?relay
      54  LoadTXData
       6  LoadTXData::?relay
      10  MAC_MODULE
     153  MAC_Receive
       6  MAC_Receive::?relay
     120  MAC_Send
       6  MAC_Send::?relay
       4  MAC_TIMER_MAX
      10  MD_MODULE
     116  MEM_memcpy
       6  MEM_memcpy::?relay
      79  MEM_memset
       6  MEM_memset::?relay
     198  MODEL
      10  MS_MODULE
     300  NB_TABLE
      73  NP_Receive
       6  NP_Receive::?relay
       3  NP_TimeAlloc
       6  NP_TimeAlloc::?relay
      87  Neocore_start
       6  Neocore_start::?relay
       1  P0SEL
       1  P1DIR
       1  PCON
       1  PERCFG
      10  RADIO_MODULE
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
      96  RI_Measure_POW
       6  RI_Measure_POW::?relay
     595  RI_Receive
       6  RI_Receive::?relay
     259  RI_Send
       6  RI_Send::?relay
     275  RI_Send_time
       6  RI_Send_time::?relay
      32  RI_SetChannel
       6  RI_SetChannel::?relay
      69  RP_Receive
       6  RP_Receive::?relay
       3  RP_Send
       6  RP_Send::?relay
       3  RP_SendRT_GW
       6  RP_SendRT_GW::?relay
       3  RP_SendRT_RT
       6  RP_SendRT_RT::?relay
       3  RP_Send_GW
       6  RP_Send_GW::?relay
       3  RP_TimeAlloc
       6  RP_TimeAlloc::?relay
      10  RTC_MODULE
     128  RXBUFF
      59  ReadTimer
       6  ReadTimer::?relay
     203  RecvData
       6  RecvData::?relay
       1  SLEEPCMD
       1  SLEEPSTA
    3060  SLOT_POOL
     175  SL_alloc
       6  SL_alloc::?relay
      99  SL_available
       6  SL_available::?relay
      90  SL_busy
       6  SL_busy::?relay
     129  SL_find_rx
       6  SL_find_rx::?relay
     129  SL_find_tx
       6  SL_find_tx::?relay
      49  SL_free
       6  SL_free::?relay
      24  SL_is_rx
       6  SL_is_rx::?relay
      24  SL_is_tx
       6  SL_is_tx::?relay
      56  SL_rx_slots
       6  SL_rx_slots::?relay
      52  SL_set_rx
       6  SL_set_rx::?relay
      52  SL_set_tx
       6  SL_set_tx::?relay
      56  SL_tx_slots
       6  SL_tx_slots::?relay
      76  SL_zone_check
       6  SL_zone_check::?relay
       1  ST0
       1  ST1
       1  ST2
       1  STLOAD
       3  SW_Init
       3  SW_Init
       3  SW_Init
       3  SW_Init
      52  SW_Init
      62  SW_Init
      83  SW_Init
     114  SW_Init
     133  SW_Init
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
      14  SW_MOD
      14  SW_restart
       6  SW_restart::?relay
      10  SYNC_MODULE
      71  SY_restart
       6  SY_restart::?relay
     243  SendData
       6  SendData::?relay
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
       3  TB_Receive
       6  TB_Receive::?relay
      94  TM_ClrAlarm
       6  TM_ClrAlarm::?relay
     110  TM_IRQ
       6  TM_IRQ::?relay
      91  TM_SetAlarm
       6  TM_SetAlarm::?relay
       2  TOFFSET
      37  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
      10  UST_MODULE
     191  UST_delay
       6  UST_delay::?relay
     141  UST_interval
       6  UST_interval::?relay
      79  UST_now
       6  UST_now::?relay
     108  UST_time_over
       6  UST_time_over::?relay
      44  UnLoadRXData
       6  UnLoadRXData::?relay
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P1
       4  __Constant_1
       4  __Constant_19833891
       4  __Constant_1e
       4  __Constant_1f4
       4  __Constant_1f40
       4  __Constant_20
       4  __Constant_396
       4  __Constant_3d
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_9c4
       4  __Constant_a
       4  __Constant_f4240
       4  __Constant_ffff8000
       4  __Constant_ffffc180
       4  __Constant_ffffff
       7  __cli
       7  __cli
       7  __cli
       6  __cli::?relay
       6  __cli::?relay
       6  __cli::?relay
      34  _clr_all
       6  _clr_all::?relay
      50  _find_next_active
       6  _find_next_active::?relay
      56  _free
       6  _free::?relay
      18  _inc_timeslot
       6  _inc_timeslot::?relay
     127  _interval
       6  _interval::?relay
       4  _recv_ack
       6  _recv_ack::?relay
     121  _recv_frame
       6  _recv_frame::?relay
      81  _send_ack
       6  _send_ack::?relay
     108  _send_frame
       6  _send_frame::?relay
      52  _throw_dice
       6  _throw_dice::?relay
      26  accept_sync_data
       6  accept_sync_data::?relay
      34  bits_count
       6  bits_count::?relay
     162  buf
     189  calcCompareTime
       6  calcCompareTime::?relay
       5  calc_weight
       6  calc_weight::?relay
      48  calc_xor
       6  calc_xor::?relay
      93  callback
       6  callback::?relay
      16  default_iv
      16  default_key
     148  energy_scan
       6  energy_scan::?relay
     294  eth_send
       6  eth_send::?relay
     276  ethernet_process
       6  ethernet_process::?relay
     151  fill_meta_data
       6  fill_meta_data::?relay
      70  find_free_index
       6  find_free_index::?relay
     137  find_index
       6  find_index::?relay
       1  first
     691  frame_filter
       6  frame_filter::?relay
      25  frame_filter_card
       6  frame_filter_card::?relay
      22  frame_filter_cmd_req
       6  frame_filter_cmd_req::?relay
     241  generateAuthData
       6  generateAuthData::?relay
      53  getRNDByte
       6  getRNDByte::?relay
      26  init
       6  init::?relay
     428  insert_record
       6  insert_record::?relay
       5  isIRQEnable
       6  isIRQEnable::?relay
       4  last_request
      70  loadTimerCompare
       6  loadTimerCompare::?relay
     231  main
       6  main::?relay
       9  mcu_sleep
       6  mcu_sleep::?relay
      72  mem_move
       6  mem_move::?relay
     152  mode_1_process
       6  mode_1_process::?relay
     220  mode_1_receive_process
       6  mode_1_receive_process::?relay
      32  mode_1_retransmition_process
       6  mode_1_retransmition_process::?relay
      64  mode_2_process
       6  mode_2_process::?relay
     236  network_recv_sync
       6  network_recv_sync::?relay
     406  network_sync
       6  network_sync::?relay
     281  parse_frame
       6  parse_frame::?relay
      27  pre_config
       6  pre_config::?relay
      93  pre_init
       6  pre_init::?relay
     127  process_card
       6  process_card::?relay
      91  process_cmd_req
       6  process_cmd_req::?relay
      10  putchar
      78  random_core_init
       6  random_core_init::?relay
      54  readRandom
       6  readRandom::?relay
      55  receive
       6  receive::?relay
      78  receiveCMD_Request
       6  receiveCMD_Request::?relay
     573  receiveCMD_Response
       6  receiveCMD_Response::?relay
     243  recv_sync
       6  recv_sync::?relay
       4  ret_val
       1  retransmite
       1  scan_channel
     135  scheduler_rx
       6  scheduler_rx::?relay
     263  scheduler_tx
       6  scheduler_tx::?relay
      65  scheulder_next_alarm
       6  scheulder_next_alarm::?relay
       3  send_card
       6  send_card::?relay
     371  send_sync
       6  send_sync::?relay
     120  setFreq
       6  setFreq::?relay
       2  slot_busy
      38  start_mode_1
       6  start_mode_1::?relay
      17  start_mode_2
       6  start_mode_2::?relay
     162  syncronize_timer
       6  syncronize_timer::?relay
     476  transmite
       6  transmite::?relay
      23  uart_init
       6  uart_init::?relay
     325  update_record
       6  update_record::?relay
       4  val
      59  validate_sync
       6  validate_sync::?relay
      51  xor_calc
       6  xor_calc::?relay
     628  -- Other

 
 21 239 bytes in segment BANKED_CODE
  1 134 bytes in segment BANK_RELAYS
  2 287 bytes in segment CODE_C
      3 bytes in segment INTVEC
     47 bytes in segment NEAR_CODE
     35 bytes in segment SFR_AN
    232 bytes in segment XDATA_I
    232 bytes in segment XDATA_ID
  4 164 bytes in segment XDATA_Z
 
  3 636 bytes of CODE     memory (+ 67 bytes shared)
      0 bytes of DATA     memory (+ 35 bytes shared)
 21 239 bytes of HUGECODE memory
  4 396 bytes of XDATA    memory

Errors: none
Warnings: 14
