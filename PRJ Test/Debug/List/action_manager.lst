###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               31/Mar/2020  12:04:26
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  extended stack reentrant
#    Constant location  =  data_rom
#    Extended stack     =  enabled
#    Dptr setup         =  1,16
#                          
#    Source file        =  E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EWC751.tmp
#        (E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c -lC
#        "E:\Neocore\Hardware\PRJ Test\Debug\List" -o "E:\Neocore\Hardware\PRJ
#        Test\Debug\Obj" -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=ext_stack_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 --extended_stack
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\8051\LIB\DLIB\dl8051Normal.h" --no_path_in_file_macros -I
#        E:\Neocore\Hardware\Stack_core_src\ -On --vla --use_c++_inline
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --mfc E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\buffer.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\coder.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\cpu.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\debug.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\dma.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\frame.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\led.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\llc.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\mac.c "E:\Neocore\Hardware\PRJ
#        Test\main.c" E:\Neocore\Hardware\STACK_CORE_SRC\mem_slots.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\mem_utils.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\model.c
#        E:\Neocore\Hardware\Stack_core_src\radio.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\rtc.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\sync.c
#        E:\Neocore\Hardware\STACK_CORE_SRC\time_manager.c
#        "E:\Neocore\Hardware\PRJ Test\u_alarm_timer.c"
#        "E:\Neocore\Hardware\PRJ Test\u_buffer.c" "E:\Neocore\Hardware\PRJ
#        Test\u_debug.c" "E:\Neocore\Hardware\PRJ Test\u_frame.c"
#        "E:\Neocore\Hardware\PRJ Test\u_macros.c" "E:\Neocore\Hardware\PRJ
#        Test\u_mem_slots.c" "E:\Neocore\Hardware\PRJ Test\u_mem_utils.c"
#        E:\Neocore\Hardware\STACK_CORE_SRC\ustimer.c "E:\Neocore\Hardware\PRJ
#        Test\utest.c")
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        E:\Neocore\Hardware\PRJ Test\Debug\List\action_manager.lst
#    Object file        =  
#        E:\Neocore\Hardware\PRJ Test\Debug\Obj\action_manager.r51
#
###############################################################################

E:\Neocore\Hardware\STACK_CORE_SRC\action_manager.c
      1          #include "action_manager.h"
      2          #include "modules_list.h"
      3          #include "model.h"
      4          #include "debug.h"

   \                                 In  segment SFR_AN, at 0x86
   \   unsigned char volatile __sfr U0CSR
   \                     U0CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x87
   \   unsigned char volatile __sfr PCON
   \                     PCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x91
   \   unsigned char volatile __sfr RFIRQF1
   \                     RFIRQF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x94
   \   unsigned char volatile __sfr T2CTRL
   \                     T2CTRL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x96
   \   unsigned char volatile __sfr ST1
   \                     ST1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x97
   \   unsigned char volatile __sfr ST2
   \                     ST2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa2
   \   unsigned char volatile __sfr T2M0
   \                     T2M0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa3
   \   unsigned char volatile __sfr T2M1
   \                     T2M1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa4
   \   unsigned char volatile __sfr T2MOVF0
   \                     T2MOVF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa5
   \   unsigned char volatile __sfr T2MOVF1
   \                     T2MOVF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xad
   \   unsigned char volatile __sfr STLOAD
   \                     STLOAD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb3
   \   unsigned char volatile __sfr ENCCS
   \                     ENCCS:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc1
   \   unsigned char volatile __sfr U0DBUF
   \                     U0DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc2
   \   unsigned char volatile __sfr U0BAUD
   \                     U0BAUD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc5
   \   unsigned char volatile __sfr U0GCR
   \                     U0GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd2
   \   unsigned char volatile __sfr DMA1CFGL
   \                     DMA1CFGL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd3
   \   unsigned char volatile __sfr DMA1CFGH
   \                     DMA1CFGH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd4
   \   unsigned char volatile __sfr DMA0CFGL
   \                     DMA0CFGL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd5
   \   unsigned char volatile __sfr DMA0CFGH
   \                     DMA0CFGH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd7
   \   unsigned char volatile __sfr DMAREQ
   \                     DMAREQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd9
   \   unsigned char volatile __sfr RFD
   \                     RFD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe1
   \   unsigned char volatile __sfr RFST
   \                     RFST:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe9
   \   unsigned char volatile __sfr RFIRQF0
   \                     RFIRQF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf1
   \   unsigned char volatile __sfr PERCFG
   \                     PERCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
      5          
      6          /**
      7          @file
      8          */
      9          
     10          /* Определения */
     11          #define ITEMS_COUNT(name) (sizeof(name)/sizeof(module_s*))
     12          #define RUNNER(array, fun) {\
     13          for (char i = 0; i < ITEMS_COUNT(array); i++){\
     14              ASSERT(array[i]->fun != NULL);\
     15              array[i]->fun();\
     16              }\
     17          };
     18          
     19          
     20          /* Локальные переменные */

   \                                 In  segment XDATA_I, align 1, keep-with-next
     21          static module_s* COLD_MOD[] = COLD_MOD_DEF;
   \                     ??COLD_MOD:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for COLD_MOD>`
   \   000006                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
     22          static module_s* HOT_MOD[] = HOT_MOD_DEF;
   \                     ??HOT_MOD:
   \   000000                DS 8
   \   000008                REQUIRE `?<Initializer for HOT_MOD>`
   \   000008                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
     23          static module_s* HW_MOD[] = HW_MOD_DEF;
   \                     ??HW_MOD:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for HW_MOD>`
   \   000010                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
     24          static module_s* SW_MOD[] = SW_MOD_DEF;
   \                     ??SW_MOD:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for SW_MOD>`
   \   000010                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
     25          static module_s* IRQ_MOD[] = IRQ_MOD_DEF;
   \                     ??IRQ_MOD:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for IRQ_MOD>`
   \   000006                REQUIRE __INIT_XDATA_I
     26          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     27          static void (*CALLBACK)(void);
   \                     ??CALLBACK:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     28          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     29          void AM_set_callback(void (*fn)(void)){
   \                     AM_set_callback:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
   \   000006   EA           MOV       A,R2
   \   000007   FE           MOV       R6,A
   \   000008   EB           MOV       A,R3
   \   000009   FF           MOV       R7,A
     30            ASSERT(fn);
   \   00000A   EE           MOV       A,R6
   \   00000B   4F           ORL       A,R7
   \   00000C   701F         JNZ       ??AM_set_callback_0
   \   00000E                ; Setup parameters for call to function printf
   \   00000E   741E         MOV       A,#0x1e
   \   000010   C0E0         PUSH      A
   \   000012   7400         MOV       A,#0x0
   \   000014   C0E0         PUSH      A
   \   000016   74..         MOV       A,#`?<Constant "action_manager.c">` & 0xff
   \   000018   C0E0         PUSH      A
   \   00001A   74..         MOV       A,#(`?<Constant "action_manager.c">` >> 8) & 0xff
   \   00001C   C0E0         PUSH      A
   \   00001E   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">` & 0xff
   \   000020   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">` >> 8) & 0xff
   \   000022   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000025   74FC         MOV       A,#-0x4
   \   000027   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002A                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002A   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     31            CALLBACK = fn;
   \                     ??AM_set_callback_0:
   \   00002D   90....       MOV       DPTR,#??CALLBACK
   \   000030   EE           MOV       A,R6
   \   000031   F0           MOVX      @DPTR,A
   \   000032   A3           INC       DPTR
   \   000033   EF           MOV       A,R7
   \   000034   F0           MOVX      @DPTR,A
     32          }
   \   000035   D0E0         POP       A
   \   000037   FF           MOV       R7,A
   \   000038   D0E0         POP       A
   \   00003A   FE           MOV       R6,A
   \   00003B   02....       LJMP      ?BRET
     33          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     34          void AM_Callback(void){
   \                     AM_Callback:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     35            ASSERT(CALLBACK);
   \   000000   90....       MOV       DPTR,#??CALLBACK
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F9           MOV       R1,A
   \   000008   E8           MOV       A,R0
   \   000009   49           ORL       A,R1
   \   00000A   701F         JNZ       ??AM_Callback_0
   \   00000C                ; Setup parameters for call to function printf
   \   00000C   7423         MOV       A,#0x23
   \   00000E   C0E0         PUSH      A
   \   000010   7400         MOV       A,#0x0
   \   000012   C0E0         PUSH      A
   \   000014   74..         MOV       A,#`?<Constant "action_manager.c">` & 0xff
   \   000016   C0E0         PUSH      A
   \   000018   74..         MOV       A,#(`?<Constant "action_manager.c">` >> 8) & 0xff
   \   00001A   C0E0         PUSH      A
   \   00001C   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">` & 0xff
   \   00001E   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">` >> 8) & 0xff
   \   000020   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000023   74FC         MOV       A,#-0x4
   \   000025   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000028                ; Setup parameters for call to function DBG_CORE_HALT
   \   000028   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     36            CALLBACK();
   \                     ??AM_Callback_0:
   \   00002B                ; Setup parameters for indirect call
   \   00002B   90....       MOV       DPTR,#??CALLBACK
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   F8           MOV       R0,A
   \   000030   A3           INC       DPTR
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F583         MOV       DPH,A
   \   000034   8882         MOV       DPL,R0
   \   000036   12....       LCALL     ?CALL_IND
     37          }
   \   000039   02....       LJMP      ?BRET
     38          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     39          void AM_Cold_start(void){
   \                     AM_Cold_start:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
     40            RUNNER(COLD_MOD, Cold_Start);
   \   000003   7E00         MOV       R6,#0x0
   \                     ??AM_Cold_start_0:
   \   000005   EE           MOV       A,R6
   \   000006   C3           CLR       C
   \   000007   9403         SUBB      A,#0x3
   \   000009   4003         JC        $+5
   \   00000B   02....       LJMP      ??AM_Cold_start_1 & 0xFFFF
   \   00000E   EE           MOV       A,R6
   \   00000F   F8           MOV       R0,A
   \   000010   7900         MOV       R1,#0x0
   \   000012   E8           MOV       A,R0
   \   000013   75F002       MOV       B,#0x2
   \   000016   A4           MUL       AB
   \   000017   C8           XCH       A,R0
   \   000018   AAF0         MOV       R2,B
   \   00001A   75F000       MOV       B,#0x0
   \   00001D   A4           MUL       AB
   \   00001E   2A           ADD       A,R2
   \   00001F   FA           MOV       R2,A
   \   000020   75F002       MOV       B,#0x2
   \   000023   E9           MOV       A,R1
   \   000024   A4           MUL       AB
   \   000025   2A           ADD       A,R2
   \   000026   F9           MOV       R1,A
   \   000027   74..         MOV       A,#??COLD_MOD & 0xff
   \   000029   28           ADD       A,R0
   \   00002A   F582         MOV       DPL,A
   \   00002C   74..         MOV       A,#(??COLD_MOD >> 8) & 0xff
   \   00002E   39           ADDC      A,R1
   \   00002F   F583         MOV       DPH,A
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F8           MOV       R0,A
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   C8           XCH       A,R0
   \   000036   2406         ADD       A,#0x6
   \   000038   F582         MOV       DPL,A
   \   00003A   C8           XCH       A,R0
   \   00003B   3400         ADDC      A,#0x0
   \   00003D   F583         MOV       DPH,A
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   F8           MOV       R0,A
   \   000041   A3           INC       DPTR
   \   000042   E0           MOVX      A,@DPTR
   \   000043   F9           MOV       R1,A
   \   000044   E8           MOV       A,R0
   \   000045   49           ORL       A,R1
   \   000046   701F         JNZ       ??AM_Cold_start_2
   \   000048                ; Setup parameters for call to function printf
   \   000048   7428         MOV       A,#0x28
   \   00004A   C0E0         PUSH      A
   \   00004C   7400         MOV       A,#0x0
   \   00004E   C0E0         PUSH      A
   \   000050   74..         MOV       A,#`?<Constant "action_manager.c">` & 0xff
   \   000052   C0E0         PUSH      A
   \   000054   74..         MOV       A,#(`?<Constant "action_manager.c">` >> 8) & 0xff
   \   000056   C0E0         PUSH      A
   \   000058   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">` & 0xff
   \   00005A   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">` >> 8) & 0xff
   \   00005C   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00005F   74FC         MOV       A,#-0x4
   \   000061   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000064                ; Setup parameters for call to function DBG_CORE_HALT
   \   000064   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
   \                     ??AM_Cold_start_2:
   \   000067                ; Setup parameters for indirect call
   \   000067   EE           MOV       A,R6
   \   000068   F8           MOV       R0,A
   \   000069   7900         MOV       R1,#0x0
   \   00006B   E8           MOV       A,R0
   \   00006C   75F002       MOV       B,#0x2
   \   00006F   A4           MUL       AB
   \   000070   C8           XCH       A,R0
   \   000071   AAF0         MOV       R2,B
   \   000073   75F000       MOV       B,#0x0
   \   000076   A4           MUL       AB
   \   000077   2A           ADD       A,R2
   \   000078   FA           MOV       R2,A
   \   000079   75F002       MOV       B,#0x2
   \   00007C   E9           MOV       A,R1
   \   00007D   A4           MUL       AB
   \   00007E   2A           ADD       A,R2
   \   00007F   F9           MOV       R1,A
   \   000080   74..         MOV       A,#??COLD_MOD & 0xff
   \   000082   28           ADD       A,R0
   \   000083   F582         MOV       DPL,A
   \   000085   74..         MOV       A,#(??COLD_MOD >> 8) & 0xff
   \   000087   39           ADDC      A,R1
   \   000088   F583         MOV       DPH,A
   \   00008A   E0           MOVX      A,@DPTR
   \   00008B   F8           MOV       R0,A
   \   00008C   A3           INC       DPTR
   \   00008D   E0           MOVX      A,@DPTR
   \   00008E   C8           XCH       A,R0
   \   00008F   2406         ADD       A,#0x6
   \   000091   F582         MOV       DPL,A
   \   000093   C8           XCH       A,R0
   \   000094   3400         ADDC      A,#0x0
   \   000096   F583         MOV       DPH,A
   \   000098   E0           MOVX      A,@DPTR
   \   000099   F8           MOV       R0,A
   \   00009A   A3           INC       DPTR
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   F583         MOV       DPH,A
   \   00009E   8882         MOV       DPL,R0
   \   0000A0   12....       LCALL     ?CALL_IND
   \   0000A3   0E           INC       R6
   \   0000A4   02....       LJMP      ??AM_Cold_start_0 & 0xFFFF
     41          }
   \                     ??AM_Cold_start_1:
   \   0000A7   D0E0         POP       A
   \   0000A9   FE           MOV       R6,A
   \   0000AA   02....       LJMP      ?BRET
     42          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     43          void AM_Hot_start(void){
   \                     AM_Hot_start:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
     44            RUNNER(HOT_MOD, Hot_Start);  
   \   000003   7E00         MOV       R6,#0x0
   \                     ??AM_Hot_start_0:
   \   000005   EE           MOV       A,R6
   \   000006   C3           CLR       C
   \   000007   9404         SUBB      A,#0x4
   \   000009   4003         JC        $+5
   \   00000B   02....       LJMP      ??AM_Hot_start_1 & 0xFFFF
   \   00000E   EE           MOV       A,R6
   \   00000F   F8           MOV       R0,A
   \   000010   7900         MOV       R1,#0x0
   \   000012   E8           MOV       A,R0
   \   000013   75F002       MOV       B,#0x2
   \   000016   A4           MUL       AB
   \   000017   C8           XCH       A,R0
   \   000018   AAF0         MOV       R2,B
   \   00001A   75F000       MOV       B,#0x0
   \   00001D   A4           MUL       AB
   \   00001E   2A           ADD       A,R2
   \   00001F   FA           MOV       R2,A
   \   000020   75F002       MOV       B,#0x2
   \   000023   E9           MOV       A,R1
   \   000024   A4           MUL       AB
   \   000025   2A           ADD       A,R2
   \   000026   F9           MOV       R1,A
   \   000027   74..         MOV       A,#??HOT_MOD & 0xff
   \   000029   28           ADD       A,R0
   \   00002A   F582         MOV       DPL,A
   \   00002C   74..         MOV       A,#(??HOT_MOD >> 8) & 0xff
   \   00002E   39           ADDC      A,R1
   \   00002F   F583         MOV       DPH,A
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F8           MOV       R0,A
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   C8           XCH       A,R0
   \   000036   2408         ADD       A,#0x8
   \   000038   F582         MOV       DPL,A
   \   00003A   C8           XCH       A,R0
   \   00003B   3400         ADDC      A,#0x0
   \   00003D   F583         MOV       DPH,A
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   F8           MOV       R0,A
   \   000041   A3           INC       DPTR
   \   000042   E0           MOVX      A,@DPTR
   \   000043   F9           MOV       R1,A
   \   000044   E8           MOV       A,R0
   \   000045   49           ORL       A,R1
   \   000046   701F         JNZ       ??AM_Hot_start_2
   \   000048                ; Setup parameters for call to function printf
   \   000048   742C         MOV       A,#0x2c
   \   00004A   C0E0         PUSH      A
   \   00004C   7400         MOV       A,#0x0
   \   00004E   C0E0         PUSH      A
   \   000050   74..         MOV       A,#`?<Constant "action_manager.c">` & 0xff
   \   000052   C0E0         PUSH      A
   \   000054   74..         MOV       A,#(`?<Constant "action_manager.c">` >> 8) & 0xff
   \   000056   C0E0         PUSH      A
   \   000058   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">` & 0xff
   \   00005A   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">` >> 8) & 0xff
   \   00005C   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00005F   74FC         MOV       A,#-0x4
   \   000061   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000064                ; Setup parameters for call to function DBG_CORE_HALT
   \   000064   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
   \                     ??AM_Hot_start_2:
   \   000067                ; Setup parameters for indirect call
   \   000067   EE           MOV       A,R6
   \   000068   F8           MOV       R0,A
   \   000069   7900         MOV       R1,#0x0
   \   00006B   E8           MOV       A,R0
   \   00006C   75F002       MOV       B,#0x2
   \   00006F   A4           MUL       AB
   \   000070   C8           XCH       A,R0
   \   000071   AAF0         MOV       R2,B
   \   000073   75F000       MOV       B,#0x0
   \   000076   A4           MUL       AB
   \   000077   2A           ADD       A,R2
   \   000078   FA           MOV       R2,A
   \   000079   75F002       MOV       B,#0x2
   \   00007C   E9           MOV       A,R1
   \   00007D   A4           MUL       AB
   \   00007E   2A           ADD       A,R2
   \   00007F   F9           MOV       R1,A
   \   000080   74..         MOV       A,#??HOT_MOD & 0xff
   \   000082   28           ADD       A,R0
   \   000083   F582         MOV       DPL,A
   \   000085   74..         MOV       A,#(??HOT_MOD >> 8) & 0xff
   \   000087   39           ADDC      A,R1
   \   000088   F583         MOV       DPH,A
   \   00008A   E0           MOVX      A,@DPTR
   \   00008B   F8           MOV       R0,A
   \   00008C   A3           INC       DPTR
   \   00008D   E0           MOVX      A,@DPTR
   \   00008E   C8           XCH       A,R0
   \   00008F   2408         ADD       A,#0x8
   \   000091   F582         MOV       DPL,A
   \   000093   C8           XCH       A,R0
   \   000094   3400         ADDC      A,#0x0
   \   000096   F583         MOV       DPH,A
   \   000098   E0           MOVX      A,@DPTR
   \   000099   F8           MOV       R0,A
   \   00009A   A3           INC       DPTR
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   F583         MOV       DPH,A
   \   00009E   8882         MOV       DPL,R0
   \   0000A0   12....       LCALL     ?CALL_IND
   \   0000A3   0E           INC       R6
   \   0000A4   02....       LJMP      ??AM_Hot_start_0 & 0xFFFF
     45          }
   \                     ??AM_Hot_start_1:
   \   0000A7   D0E0         POP       A
   \   0000A9   FE           MOV       R6,A
   \   0000AA   02....       LJMP      ?BRET
     46          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     47          void AM_HW_Init(void){
   \                     AM_HW_Init:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
     48            RUNNER(HW_MOD, HW_Init);      
   \   000003   7E00         MOV       R6,#0x0
   \                     ??AM_HW_Init_0:
   \   000005   EE           MOV       A,R6
   \   000006   C3           CLR       C
   \   000007   9408         SUBB      A,#0x8
   \   000009   4003         JC        $+5
   \   00000B   02....       LJMP      ??AM_HW_Init_1 & 0xFFFF
   \   00000E   EE           MOV       A,R6
   \   00000F   F8           MOV       R0,A
   \   000010   7900         MOV       R1,#0x0
   \   000012   E8           MOV       A,R0
   \   000013   75F002       MOV       B,#0x2
   \   000016   A4           MUL       AB
   \   000017   C8           XCH       A,R0
   \   000018   AAF0         MOV       R2,B
   \   00001A   75F000       MOV       B,#0x0
   \   00001D   A4           MUL       AB
   \   00001E   2A           ADD       A,R2
   \   00001F   FA           MOV       R2,A
   \   000020   75F002       MOV       B,#0x2
   \   000023   E9           MOV       A,R1
   \   000024   A4           MUL       AB
   \   000025   2A           ADD       A,R2
   \   000026   F9           MOV       R1,A
   \   000027   74..         MOV       A,#??HW_MOD & 0xff
   \   000029   28           ADD       A,R0
   \   00002A   F582         MOV       DPL,A
   \   00002C   74..         MOV       A,#(??HW_MOD >> 8) & 0xff
   \   00002E   39           ADDC      A,R1
   \   00002F   F583         MOV       DPH,A
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F8           MOV       R0,A
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F583         MOV       DPH,A
   \   000037   8882         MOV       DPL,R0
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   F8           MOV       R0,A
   \   00003B   A3           INC       DPTR
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F9           MOV       R1,A
   \   00003E   E8           MOV       A,R0
   \   00003F   49           ORL       A,R1
   \   000040   701F         JNZ       ??AM_HW_Init_2
   \   000042                ; Setup parameters for call to function printf
   \   000042   7430         MOV       A,#0x30
   \   000044   C0E0         PUSH      A
   \   000046   7400         MOV       A,#0x0
   \   000048   C0E0         PUSH      A
   \   00004A   74..         MOV       A,#`?<Constant "action_manager.c">` & 0xff
   \   00004C   C0E0         PUSH      A
   \   00004E   74..         MOV       A,#(`?<Constant "action_manager.c">` >> 8) & 0xff
   \   000050   C0E0         PUSH      A
   \   000052   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">` & 0xff
   \   000054   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">` >> 8) & 0xff
   \   000056   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000059   74FC         MOV       A,#-0x4
   \   00005B   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00005E                ; Setup parameters for call to function DBG_CORE_HALT
   \   00005E   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
   \                     ??AM_HW_Init_2:
   \   000061                ; Setup parameters for indirect call
   \   000061   EE           MOV       A,R6
   \   000062   F8           MOV       R0,A
   \   000063   7900         MOV       R1,#0x0
   \   000065   E8           MOV       A,R0
   \   000066   75F002       MOV       B,#0x2
   \   000069   A4           MUL       AB
   \   00006A   C8           XCH       A,R0
   \   00006B   AAF0         MOV       R2,B
   \   00006D   75F000       MOV       B,#0x0
   \   000070   A4           MUL       AB
   \   000071   2A           ADD       A,R2
   \   000072   FA           MOV       R2,A
   \   000073   75F002       MOV       B,#0x2
   \   000076   E9           MOV       A,R1
   \   000077   A4           MUL       AB
   \   000078   2A           ADD       A,R2
   \   000079   F9           MOV       R1,A
   \   00007A   74..         MOV       A,#??HW_MOD & 0xff
   \   00007C   28           ADD       A,R0
   \   00007D   F582         MOV       DPL,A
   \   00007F   74..         MOV       A,#(??HW_MOD >> 8) & 0xff
   \   000081   39           ADDC      A,R1
   \   000082   F583         MOV       DPH,A
   \   000084   E0           MOVX      A,@DPTR
   \   000085   F8           MOV       R0,A
   \   000086   A3           INC       DPTR
   \   000087   E0           MOVX      A,@DPTR
   \   000088   F583         MOV       DPH,A
   \   00008A   8882         MOV       DPL,R0
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   F8           MOV       R0,A
   \   00008E   A3           INC       DPTR
   \   00008F   E0           MOVX      A,@DPTR
   \   000090   F583         MOV       DPH,A
   \   000092   8882         MOV       DPL,R0
   \   000094   12....       LCALL     ?CALL_IND
   \   000097   0E           INC       R6
   \   000098   02....       LJMP      ??AM_HW_Init_0 & 0xFFFF
     49          }
   \                     ??AM_HW_Init_1:
   \   00009B   D0E0         POP       A
   \   00009D   FE           MOV       R6,A
   \   00009E   02....       LJMP      ?BRET
     50          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     51          void AM_SW_Init(void){
   \                     AM_SW_Init:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
     52            RUNNER(SW_MOD, SW_Init);
   \   000003   7E00         MOV       R6,#0x0
   \                     ??AM_SW_Init_0:
   \   000005   EE           MOV       A,R6
   \   000006   C3           CLR       C
   \   000007   9408         SUBB      A,#0x8
   \   000009   4003         JC        $+5
   \   00000B   02....       LJMP      ??AM_SW_Init_1 & 0xFFFF
   \   00000E   EE           MOV       A,R6
   \   00000F   F8           MOV       R0,A
   \   000010   7900         MOV       R1,#0x0
   \   000012   E8           MOV       A,R0
   \   000013   75F002       MOV       B,#0x2
   \   000016   A4           MUL       AB
   \   000017   C8           XCH       A,R0
   \   000018   AAF0         MOV       R2,B
   \   00001A   75F000       MOV       B,#0x0
   \   00001D   A4           MUL       AB
   \   00001E   2A           ADD       A,R2
   \   00001F   FA           MOV       R2,A
   \   000020   75F002       MOV       B,#0x2
   \   000023   E9           MOV       A,R1
   \   000024   A4           MUL       AB
   \   000025   2A           ADD       A,R2
   \   000026   F9           MOV       R1,A
   \   000027   74..         MOV       A,#??SW_MOD & 0xff
   \   000029   28           ADD       A,R0
   \   00002A   F582         MOV       DPL,A
   \   00002C   74..         MOV       A,#(??SW_MOD >> 8) & 0xff
   \   00002E   39           ADDC      A,R1
   \   00002F   F583         MOV       DPH,A
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F8           MOV       R0,A
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F583         MOV       DPH,A
   \   000037   8882         MOV       DPL,R0
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   F8           MOV       R0,A
   \   00003D   A3           INC       DPTR
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   F9           MOV       R1,A
   \   000040   E8           MOV       A,R0
   \   000041   49           ORL       A,R1
   \   000042   701F         JNZ       ??AM_SW_Init_2
   \   000044                ; Setup parameters for call to function printf
   \   000044   7434         MOV       A,#0x34
   \   000046   C0E0         PUSH      A
   \   000048   7400         MOV       A,#0x0
   \   00004A   C0E0         PUSH      A
   \   00004C   74..         MOV       A,#`?<Constant "action_manager.c">` & 0xff
   \   00004E   C0E0         PUSH      A
   \   000050   74..         MOV       A,#(`?<Constant "action_manager.c">` >> 8) & 0xff
   \   000052   C0E0         PUSH      A
   \   000054   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">` & 0xff
   \   000056   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">` >> 8) & 0xff
   \   000058   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00005B   74FC         MOV       A,#-0x4
   \   00005D   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000060                ; Setup parameters for call to function DBG_CORE_HALT
   \   000060   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
   \                     ??AM_SW_Init_2:
   \   000063                ; Setup parameters for indirect call
   \   000063   EE           MOV       A,R6
   \   000064   F8           MOV       R0,A
   \   000065   7900         MOV       R1,#0x0
   \   000067   E8           MOV       A,R0
   \   000068   75F002       MOV       B,#0x2
   \   00006B   A4           MUL       AB
   \   00006C   C8           XCH       A,R0
   \   00006D   AAF0         MOV       R2,B
   \   00006F   75F000       MOV       B,#0x0
   \   000072   A4           MUL       AB
   \   000073   2A           ADD       A,R2
   \   000074   FA           MOV       R2,A
   \   000075   75F002       MOV       B,#0x2
   \   000078   E9           MOV       A,R1
   \   000079   A4           MUL       AB
   \   00007A   2A           ADD       A,R2
   \   00007B   F9           MOV       R1,A
   \   00007C   74..         MOV       A,#??SW_MOD & 0xff
   \   00007E   28           ADD       A,R0
   \   00007F   F582         MOV       DPL,A
   \   000081   74..         MOV       A,#(??SW_MOD >> 8) & 0xff
   \   000083   39           ADDC      A,R1
   \   000084   F583         MOV       DPH,A
   \   000086   E0           MOVX      A,@DPTR
   \   000087   F8           MOV       R0,A
   \   000088   A3           INC       DPTR
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   F583         MOV       DPH,A
   \   00008C   8882         MOV       DPL,R0
   \   00008E   A3           INC       DPTR
   \   00008F   A3           INC       DPTR
   \   000090   E0           MOVX      A,@DPTR
   \   000091   F8           MOV       R0,A
   \   000092   A3           INC       DPTR
   \   000093   E0           MOVX      A,@DPTR
   \   000094   F583         MOV       DPH,A
   \   000096   8882         MOV       DPL,R0
   \   000098   12....       LCALL     ?CALL_IND
   \   00009B   0E           INC       R6
   \   00009C   02....       LJMP      ??AM_SW_Init_0 & 0xFFFF
     53          }
   \                     ??AM_SW_Init_1:
   \   00009F   D0E0         POP       A
   \   0000A1   FE           MOV       R6,A
   \   0000A2   02....       LJMP      ?BRET
     54          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     55          void AM_IRQ_Init(void){
   \                     AM_IRQ_Init:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
     56            RUNNER(IRQ_MOD, IRQ_Init);
   \   000003   7E00         MOV       R6,#0x0
   \                     ??AM_IRQ_Init_0:
   \   000005   EE           MOV       A,R6
   \   000006   C3           CLR       C
   \   000007   9403         SUBB      A,#0x3
   \   000009   4003         JC        $+5
   \   00000B   02....       LJMP      ??AM_IRQ_Init_1 & 0xFFFF
   \   00000E   EE           MOV       A,R6
   \   00000F   F8           MOV       R0,A
   \   000010   7900         MOV       R1,#0x0
   \   000012   E8           MOV       A,R0
   \   000013   75F002       MOV       B,#0x2
   \   000016   A4           MUL       AB
   \   000017   C8           XCH       A,R0
   \   000018   AAF0         MOV       R2,B
   \   00001A   75F000       MOV       B,#0x0
   \   00001D   A4           MUL       AB
   \   00001E   2A           ADD       A,R2
   \   00001F   FA           MOV       R2,A
   \   000020   75F002       MOV       B,#0x2
   \   000023   E9           MOV       A,R1
   \   000024   A4           MUL       AB
   \   000025   2A           ADD       A,R2
   \   000026   F9           MOV       R1,A
   \   000027   74..         MOV       A,#??IRQ_MOD & 0xff
   \   000029   28           ADD       A,R0
   \   00002A   F582         MOV       DPL,A
   \   00002C   74..         MOV       A,#(??IRQ_MOD >> 8) & 0xff
   \   00002E   39           ADDC      A,R1
   \   00002F   F583         MOV       DPH,A
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F8           MOV       R0,A
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F583         MOV       DPH,A
   \   000037   8882         MOV       DPL,R0
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   F8           MOV       R0,A
   \   00003F   A3           INC       DPTR
   \   000040   E0           MOVX      A,@DPTR
   \   000041   F9           MOV       R1,A
   \   000042   E8           MOV       A,R0
   \   000043   49           ORL       A,R1
   \   000044   701F         JNZ       ??AM_IRQ_Init_2
   \   000046                ; Setup parameters for call to function printf
   \   000046   7438         MOV       A,#0x38
   \   000048   C0E0         PUSH      A
   \   00004A   7400         MOV       A,#0x0
   \   00004C   C0E0         PUSH      A
   \   00004E   74..         MOV       A,#`?<Constant "action_manager.c">` & 0xff
   \   000050   C0E0         PUSH      A
   \   000052   74..         MOV       A,#(`?<Constant "action_manager.c">` >> 8) & 0xff
   \   000054   C0E0         PUSH      A
   \   000056   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">` & 0xff
   \   000058   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">` >> 8) & 0xff
   \   00005A   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00005D   74FC         MOV       A,#-0x4
   \   00005F   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000062                ; Setup parameters for call to function DBG_CORE_HALT
   \   000062   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
   \                     ??AM_IRQ_Init_2:
   \   000065                ; Setup parameters for indirect call
   \   000065   EE           MOV       A,R6
   \   000066   F8           MOV       R0,A
   \   000067   7900         MOV       R1,#0x0
   \   000069   E8           MOV       A,R0
   \   00006A   75F002       MOV       B,#0x2
   \   00006D   A4           MUL       AB
   \   00006E   C8           XCH       A,R0
   \   00006F   AAF0         MOV       R2,B
   \   000071   75F000       MOV       B,#0x0
   \   000074   A4           MUL       AB
   \   000075   2A           ADD       A,R2
   \   000076   FA           MOV       R2,A
   \   000077   75F002       MOV       B,#0x2
   \   00007A   E9           MOV       A,R1
   \   00007B   A4           MUL       AB
   \   00007C   2A           ADD       A,R2
   \   00007D   F9           MOV       R1,A
   \   00007E   74..         MOV       A,#??IRQ_MOD & 0xff
   \   000080   28           ADD       A,R0
   \   000081   F582         MOV       DPL,A
   \   000083   74..         MOV       A,#(??IRQ_MOD >> 8) & 0xff
   \   000085   39           ADDC      A,R1
   \   000086   F583         MOV       DPH,A
   \   000088   E0           MOVX      A,@DPTR
   \   000089   F8           MOV       R0,A
   \   00008A   A3           INC       DPTR
   \   00008B   E0           MOVX      A,@DPTR
   \   00008C   F583         MOV       DPH,A
   \   00008E   8882         MOV       DPL,R0
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   A3           INC       DPTR
   \   000093   A3           INC       DPTR
   \   000094   E0           MOVX      A,@DPTR
   \   000095   F8           MOV       R0,A
   \   000096   A3           INC       DPTR
   \   000097   E0           MOVX      A,@DPTR
   \   000098   F583         MOV       DPH,A
   \   00009A   8882         MOV       DPL,R0
   \   00009C   12....       LCALL     ?CALL_IND
   \   00009F   0E           INC       R6
   \   0000A0   02....       LJMP      ??AM_IRQ_Init_0 & 0xFFFF
     57          }
   \                     ??AM_IRQ_Init_1:
   \   0000A3   D0E0         POP       A
   \   0000A5   FE           MOV       R6,A
   \   0000A6   02....       LJMP      ?BRET
     58          
     59          
E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c
      1          #include "alarm_timer.h"
      2          #include "time_manager.h"
      3          #include "action_manager.h"
      4          #include "ioCC2530.h"
      5          #include "stdbool.h"
      6          #include "stdint.h"
      7          #include "debug.h"
      8          #include "cpu.h"

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant char __cli(void)
   \                     ??__cli:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   C2AF         CLR       0xa8.7
   \   000002   7901         MOV       R1,#0x1
   \   000004   02....       LJMP      ?BRET
   \   000007                REQUIRE _A_IEN0
      9          
     10          /**
     11          @file
     12          */
     13          
     14          #define MAX_NWTIME (nwtime_t)32767
     15          
     16          static void HW_Init(void);  
     17          static inline void IRQEnable(bool state);
     18          static uint32_t ReadTimer(void);
     19          static inline bool isIRQEnable(void);
     20          static inline uint32_t calcCompareTime(nwtime_t time);
     21          static void loadTimerCompare(uint32_t ticks);
     22          

   \                                 In  segment XDATA_I, align 1, keep-with-next
     23          module_s AT_MODULE = {ALIAS(HW_Init)};
   \                     AT_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for AT_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     24          static nwtime_t TOFFSET; 
   \                     ??TOFFSET:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     25          static uint32_t COMPARE_TIME; //!< Значение в регистре compare
   \                     ??COMPARE_TIME:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
     26          
     27          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     28          static void HW_Init(void){
   \                     ??HW_Init:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     29            TOFFSET = 0;
   \   000000   90....       MOV       DPTR,#??TOFFSET
   \   000003   7400         MOV       A,#0x0
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   7400         MOV       A,#0x0
   \   000009   F0           MOVX      @DPTR,A
     30            COMPARE_TIME = 0;
   \   00000A   90....       MOV       DPTR,#??COMPARE_TIME
   \   00000D   7400         MOV       A,#0x0
   \   00000F   F0           MOVX      @DPTR,A
   \   000010   A3           INC       DPTR
   \   000011   7400         MOV       A,#0x0
   \   000013   F0           MOVX      @DPTR,A
   \   000014   A3           INC       DPTR
   \   000015   7400         MOV       A,#0x0
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   7400         MOV       A,#0x0
   \   00001B   F0           MOVX      @DPTR,A
     31            IRQEnable(false);
   \   00001C                ; Setup parameters for call to function IRQEnable
   \   00001C   C2F0         CLR       B.0
   \   00001E   12....       LCALL     `??IRQEnable::?relay`; Banked call to: IRQEnable
     32          };
   \   000021   02....       LJMP      ?BRET
     33          
     34          static void SW_Init(void){
     35            TOFFSET = 0;
     36            COMPARE_TIME = 0;
     37            IRQEnable(false);
     38          }; 
     39          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     40          void AT_enable(bool state){
   \                     AT_enable:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   C0..         PUSH      ?VB
   \   000005                ; Saved register size: 2
   \   000005                ; Auto size: 0
   \   000005   A2F0         MOV       C,B.0
   \   000007   92..         MOV       ?VB.0,C
     41            ATOMIC_BLOCK_RESTORE{
   \   000009   A2AF         MOV       C,0xa8.7
   \   00000B   E4           CLR       A
   \   00000C   33           RLC       A
   \   00000D   FE           MOV       R6,A
   \   00000E                ; Setup parameters for call to function __cli
   \   00000E   12....       LCALL     `??__cli::?relay`; Banked call to: __cli
   \   000011   E9           MOV       A,R1
   \   000012   F8           MOV       R0,A
   \                     ??AT_enable_0:
   \   000013   E8           MOV       A,R0
   \   000014   6010         JZ        ??AT_enable_1
     42              IRQEnable(state);
   \   000016                ; Setup parameters for call to function IRQEnable
   \   000016   A2..         MOV       C,?VB.0
   \   000018   92F0         MOV       B.0,C
   \   00001A   12....       LCALL     `??IRQEnable::?relay`; Banked call to: IRQEnable
     43            }
   \   00001D   7800         MOV       R0,#0x0
   \   00001F   EE           MOV       A,R6
   \   000020   A2E0         MOV       C,0xE0 /* A   */.0
   \   000022   92AF         MOV       0xa8.7,C
   \   000024   80ED         SJMP      ??AT_enable_0
     44          };
   \                     ??AT_enable_1:
   \   000026   D0..         POP       ?VB
   \   000028   D0E0         POP       A
   \   00002A   FE           MOV       R6,A
   \   00002B   02....       LJMP      ?BRET
   \   00002E                REQUIRE _A_IEN0
     45          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     46          nwtime_t AT_interval(nwtime_t beg, nwtime_t end){
   \                     AT_interval:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     47            return (beg > end) ? (beg - end) : (MAX_NWTIME - beg + end);
   \   000000   C3           CLR       C
   \   000001   EC           MOV       A,R4
   \   000002   9A           SUBB      A,R2
   \   000003   ED           MOV       A,R5
   \   000004   9B           SUBB      A,R3
   \   000005   5009         JNC       ??AT_interval_0
   \   000007   EA           MOV       A,R2
   \   000008   C3           CLR       C
   \   000009   9C           SUBB      A,R4
   \   00000A   FA           MOV       R2,A
   \   00000B   EB           MOV       A,R3
   \   00000C   9D           SUBB      A,R5
   \   00000D   FB           MOV       R3,A
   \   00000E   800F         SJMP      ??AT_interval_1
   \                     ??AT_interval_0:
   \   000010   74FF         MOV       A,#-0x1
   \   000012   C3           CLR       C
   \   000013   9A           SUBB      A,R2
   \   000014   F8           MOV       R0,A
   \   000015   747F         MOV       A,#0x7f
   \   000017   9B           SUBB      A,R3
   \   000018   F9           MOV       R1,A
   \   000019   E8           MOV       A,R0
   \   00001A   2C           ADD       A,R4
   \   00001B   FA           MOV       R2,A
   \   00001C   E9           MOV       A,R1
   \   00001D   3D           ADDC      A,R5
   \   00001E   FB           MOV       R3,A
   \                     ??AT_interval_1:
   \   00001F   02....       LJMP      ?BRET
     48          }
     49          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     50          void AT_set_time(nwtime_t time){
   \                     AT_set_time:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
     51            ASSERT(time <= MAX_NWTIME);
   \   000009   C3           CLR       C
   \   00000A   EE           MOV       A,R6
   \   00000B   9400         SUBB      A,#0x0
   \   00000D   EF           MOV       A,R7
   \   00000E   9480         SUBB      A,#-0x80
   \   000010   401F         JC        ??AT_set_time_0
   \   000012                ; Setup parameters for call to function printf
   \   000012   7433         MOV       A,#0x33
   \   000014   C0E0         PUSH      A
   \   000016   7400         MOV       A,#0x0
   \   000018   C0E0         PUSH      A
   \   00001A   74..         MOV       A,#`?<Constant "alarm_timer.c">` & 0xff
   \   00001C   C0E0         PUSH      A
   \   00001E   74..         MOV       A,#(`?<Constant "alarm_timer.c">` >> 8) & 0xff
   \   000020   C0E0         PUSH      A
   \   000022   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_1` & 0xff
   \   000024   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_1` >> 8) & 0xff
   \   000026   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000029   74FC         MOV       A,#-0x4
   \   00002B   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002E                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002E   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     52            nwtime_t timer = ReadTimer();
   \                     ??AT_set_time_0:
   \   000031                ; Setup parameters for call to function ReadTimer
   \   000031   12....       LCALL     `??ReadTimer::?relay`; Banked call to: ReadTimer
   \   000034   8A..         MOV       ?V0,R2
   \   000036   8B..         MOV       ?V1,R3
   \   000038   8C..         MOV       ?V2,R4
   \   00003A   8D..         MOV       ?V3,R5
   \   00003C   85....       MOV       ?V4,?V0
   \   00003F   85....       MOV       ?V5,?V1
     53            TOFFSET = time - timer;
   \   000042   EE           MOV       A,R6
   \   000043   C3           CLR       C
   \   000044   95..         SUBB      A,?V4
   \   000046   F8           MOV       R0,A
   \   000047   EF           MOV       A,R7
   \   000048   95..         SUBB      A,?V5
   \   00004A   F9           MOV       R1,A
   \   00004B   90....       MOV       DPTR,#??TOFFSET
   \   00004E   E8           MOV       A,R0
   \   00004F   F0           MOVX      @DPTR,A
   \   000050   A3           INC       DPTR
   \   000051   E9           MOV       A,R1
   \   000052   F0           MOVX      @DPTR,A
     54            TOFFSET &= 0x7FFF;
   \   000053   90....       MOV       DPTR,#??TOFFSET
   \   000056   E0           MOVX      A,@DPTR
   \   000057   54FF         ANL       A,#0xff
   \   000059   F0           MOVX      @DPTR,A
   \   00005A   A3           INC       DPTR
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   547F         ANL       A,#0x7f
   \   00005E   F0           MOVX      @DPTR,A
     55            // После установки времени нужно изменить compare time в таймере
     56            // Но только в случаи если прерывание активно
     57            if (isIRQEnable())
   \   00005F                ; Setup parameters for call to function isIRQEnable
   \   00005F   12....       LCALL     `??isIRQEnable::?relay`; Banked call to: isIRQEnable
   \   000062   500F         JNC       ??AT_set_time_1
     58              AT_set_alarm(COMPARE_TIME);
   \   000064                ; Setup parameters for call to function AT_set_alarm
   \   000064   90....       MOV       DPTR,#??COMPARE_TIME
   \   000067   78..         MOV       R0,#?V0
   \   000069   12....       LCALL     ?L_MOV_X
   \   00006C   AA..         MOV       R2,?V0
   \   00006E   AB..         MOV       R3,?V1
   \   000070   12....       LCALL     `??AT_set_alarm::?relay`; Banked call to: AT_set_alarm
     59          }
   \                     ??AT_set_time_1:
   \   000073   7F06         MOV       R7,#0x6
   \   000075   02....       LJMP      ?BANKED_LEAVE_SP
     60          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     61          nwtime_t AT_time(void){
   \                     AT_time:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
     62            uint32_t val = ReadTimer();
   \   000005                ; Setup parameters for call to function ReadTimer
   \   000005   12....       LCALL     `??ReadTimer::?relay`; Banked call to: ReadTimer
   \   000008   8A..         MOV       ?V4,R2
   \   00000A   8B..         MOV       ?V5,R3
   \   00000C   8C..         MOV       ?V6,R4
   \   00000E   8D..         MOV       ?V7,R5
     63            // TOFFSET = NETWORK TIME - TIMER
     64            // NETWORK TIME = TIMER + TOFFSET
     65            val +=TOFFSET;
   \   000010   90....       MOV       DPTR,#??TOFFSET
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F5..         MOV       ?V0,A
   \   000016   A3           INC       DPTR
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F5..         MOV       ?V1,A
   \   00001A   E4           CLR       A
   \   00001B   F5..         MOV       ?V2,A
   \   00001D   F5..         MOV       ?V3,A
   \   00001F   78..         MOV       R0,#?V4
   \   000021   79..         MOV       R1,#?V0
   \   000023   12....       LCALL     ?L_ADD
     66            val &= 0x7FFF; // Приводим значения таймера к 0-32767
   \   000026   90....       MOV       DPTR,#__Constant_7fff
   \   000029   78..         MOV       R0,#?V4
   \   00002B   12....       LCALL     ?L_AND_X
     67            return val;
   \   00002E   AA..         MOV       R2,?V4
   \   000030   AB..         MOV       R3,?V5
   \   000032   7F08         MOV       R7,#0x8
   \   000034   02....       LJMP      ?BANKED_LEAVE_SP
     68          }
     69          
     70          /**
     71          @brief Ждем наступления определенного момента времени
     72          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     73          void AT_wait(nwtime_t time){
   \                     AT_wait:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
     74            ASSERT(time <= MAX_NWTIME);  
   \   000009   C3           CLR       C
   \   00000A   EE           MOV       A,R6
   \   00000B   9400         SUBB      A,#0x0
   \   00000D   EF           MOV       A,R7
   \   00000E   9480         SUBB      A,#-0x80
   \   000010   401F         JC        ??AT_wait_0
   \   000012                ; Setup parameters for call to function printf
   \   000012   744A         MOV       A,#0x4a
   \   000014   C0E0         PUSH      A
   \   000016   7400         MOV       A,#0x0
   \   000018   C0E0         PUSH      A
   \   00001A   74..         MOV       A,#`?<Constant "alarm_timer.c">` & 0xff
   \   00001C   C0E0         PUSH      A
   \   00001E   74..         MOV       A,#(`?<Constant "alarm_timer.c">` >> 8) & 0xff
   \   000020   C0E0         PUSH      A
   \   000022   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_1` & 0xff
   \   000024   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_1` >> 8) & 0xff
   \   000026   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000029   74FC         MOV       A,#-0x4
   \   00002B   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002E                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002E   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     75            static union 
     76            {
     77              uint32_t val;
     78              uint8_t fild[4];
     79            } val;
     80            val.val = 0;
   \                     ??AT_wait_0:
   \   000031   90....       MOV       DPTR,#??val
   \   000034   7400         MOV       A,#0x0
   \   000036   F0           MOVX      @DPTR,A
   \   000037   A3           INC       DPTR
   \   000038   7400         MOV       A,#0x0
   \   00003A   F0           MOVX      @DPTR,A
   \   00003B   A3           INC       DPTR
   \   00003C   7400         MOV       A,#0x0
   \   00003E   F0           MOVX      @DPTR,A
   \   00003F   A3           INC       DPTR
   \   000040   7400         MOV       A,#0x0
   \   000042   F0           MOVX      @DPTR,A
     81            // TOFFSET = NETWORK TIME - TIMER
     82            // NETWORK TIME = TIMER + TOFFSET
     83            // Ждем синхронизацию таймера после пробуждения
     84            while (!(SLEEPSTA & 0x01));
   \                     ??AT_wait_1:
   \   000043   E59D         MOV       A,0x9d
   \   000045   A2E0         MOV       C,0xE0 /* A   */.0
   \   000047   50FA         JNC       ??AT_wait_1
     85            do{
     86              // Соблюдаем порядок чтения регисторов ST  
     87              val.fild[0] = ST0;
   \                     ??AT_wait_2:
   \   000049   E595         MOV       A,0x95
   \   00004B   90....       MOV       DPTR,#??val
   \   00004E   F0           MOVX      @DPTR,A
     88              val.fild[1] = ST1;
   \   00004F   E596         MOV       A,0x96
   \   000051   90....       MOV       DPTR,#??val + 1
   \   000054   F0           MOVX      @DPTR,A
     89              val.fild[2] = ST2;
   \   000055   E597         MOV       A,0x97
   \   000057   90....       MOV       DPTR,#??val + 2
   \   00005A   F0           MOVX      @DPTR,A
     90              val.val +=TOFFSET;
   \   00005B   90....       MOV       DPTR,#??TOFFSET
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   F5..         MOV       ?V0,A
   \   000061   A3           INC       DPTR
   \   000062   E0           MOVX      A,@DPTR
   \   000063   F5..         MOV       ?V1,A
   \   000065   E4           CLR       A
   \   000066   F5..         MOV       ?V2,A
   \   000068   F5..         MOV       ?V3,A
   \   00006A   90....       MOV       DPTR,#??val
   \   00006D   78..         MOV       R0,#?V0
   \   00006F   12....       LCALL     ?L_ADD_TO_X
     91              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
   \   000072   90....       MOV       DPTR,#__Constant_7fff
   \   000075   78..         MOV       R0,#?V0
   \   000077   12....       LCALL     ?L_MOV_X
   \   00007A   90....       MOV       DPTR,#??val
   \   00007D   78..         MOV       R0,#?V0
   \   00007F   12....       LCALL     ?L_AND_TO_X
     92            } while (val.val < time);
   \   000082   8E..         MOV       ?V0,R6
   \   000084   8F..         MOV       ?V1,R7
   \   000086   E4           CLR       A
   \   000087   F5..         MOV       ?V2,A
   \   000089   F5..         MOV       ?V3,A
   \   00008B   90....       MOV       DPTR,#??val
   \   00008E   78..         MOV       R0,#?V0
   \   000090   12....       LCALL     ?UL_GT_X
   \   000093   40B4         JC        ??AT_wait_2
     93          }
   \   000095   7F04         MOV       R7,#0x4
   \   000097   02....       LJMP      ?BANKED_LEAVE_SP
   \   00009A                REQUIRE SLEEPSTA
   \   00009A                REQUIRE ST0
   \   00009A                REQUIRE ST1
   \   00009A                REQUIRE ST2

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??val:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
     94          
     95          /**
     96          @brief Разрешение прерываний таймера сна
     97          @params[in] state = true - разрешить обработку прерываний
     98          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     99          static inline void IRQEnable(bool state){
   \                     ??IRQEnable:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   A2F0         MOV       C,B.0
   \   000002   92F0         MOV       B.0,C
    100            if (state)
   \   000004   A2F0         MOV       C,B.0
   \   000006   5004         JNC       ??IRQEnable_1
    101              STIE = 1;
   \   000008   D2AD         SETB      0xa8.5
   \   00000A   8002         SJMP      ??IRQEnable_2
    102            else
    103              STIE = 0;
   \                     ??IRQEnable_1:
   \   00000C   C2AD         CLR       0xa8.5
    104          }
   \                     ??IRQEnable_2:
   \   00000E   02....       LJMP      ?BRET
   \   000011                REQUIRE _A_IEN0
    105          
    106          /**
    107          @brief Устанавливает время прерывания
    108          @details Время прерывания устанавливается относительно времени сети
    109          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    110          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    111          @params[in] ticks время сети в тиках когда нужно проснуться
    112          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    113          void AT_set_alarm(nwtime_t alarm){
   \                     AT_set_alarm:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    114            ASSERT(alarm <= MAX_NWTIME);
   \   000009   C3           CLR       C
   \   00000A   EE           MOV       A,R6
   \   00000B   9400         SUBB      A,#0x0
   \   00000D   EF           MOV       A,R7
   \   00000E   9480         SUBB      A,#-0x80
   \   000010   401F         JC        ??AT_set_alarm_0
   \   000012                ; Setup parameters for call to function printf
   \   000012   7472         MOV       A,#0x72
   \   000014   C0E0         PUSH      A
   \   000016   7400         MOV       A,#0x0
   \   000018   C0E0         PUSH      A
   \   00001A   74..         MOV       A,#`?<Constant "alarm_timer.c">` & 0xff
   \   00001C   C0E0         PUSH      A
   \   00001E   74..         MOV       A,#(`?<Constant "alarm_timer.c">` >> 8) & 0xff
   \   000020   C0E0         PUSH      A
   \   000022   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_1` & 0xff
   \   000024   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_1` >> 8) & 0xff
   \   000026   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000029   74FC         MOV       A,#-0x4
   \   00002B   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002E                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002E   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    115            COMPARE_TIME = alarm; // Сохраняем установленное значение
   \                     ??AT_set_alarm_0:
   \   000031   EE           MOV       A,R6
   \   000032   FA           MOV       R2,A
   \   000033   EF           MOV       A,R7
   \   000034   FB           MOV       R3,A
   \   000035   E4           CLR       A
   \   000036   FC           MOV       R4,A
   \   000037   FD           MOV       R5,A
   \   000038   90....       MOV       DPTR,#??COMPARE_TIME
   \   00003B   EA           MOV       A,R2
   \   00003C   F0           MOVX      @DPTR,A
   \   00003D   A3           INC       DPTR
   \   00003E   EB           MOV       A,R3
   \   00003F   F0           MOVX      @DPTR,A
   \   000040   A3           INC       DPTR
   \   000041   EC           MOV       A,R4
   \   000042   F0           MOVX      @DPTR,A
   \   000043   A3           INC       DPTR
   \   000044   ED           MOV       A,R5
   \   000045   F0           MOVX      @DPTR,A
    116            uint32_t compare_time = calcCompareTime(alarm);
   \   000046                ; Setup parameters for call to function calcCompareTime
   \   000046   EE           MOV       A,R6
   \   000047   FA           MOV       R2,A
   \   000048   EF           MOV       A,R7
   \   000049   FB           MOV       R3,A
   \   00004A   12....       LCALL     `??calcCompareTime::?relay`; Banked call to: calcCompareTime
   \   00004D   8A..         MOV       ?V0,R2
   \   00004F   8B..         MOV       ?V1,R3
   \   000051   8C..         MOV       ?V2,R4
   \   000053   8D..         MOV       ?V3,R5
    117            loadTimerCompare(compare_time);
   \   000055                ; Setup parameters for call to function loadTimerCompare
   \   000055   AA..         MOV       R2,?V0
   \   000057   AB..         MOV       R3,?V1
   \   000059   AC..         MOV       R4,?V2
   \   00005B   AD..         MOV       R5,?V3
   \   00005D   12....       LCALL     `??loadTimerCompare::?relay`; Banked call to: loadTimerCompare
    118            IRQEnable(true);
   \   000060                ; Setup parameters for call to function IRQEnable
   \   000060   D2F0         SETB      B.0
   \   000062   12....       LCALL     `??IRQEnable::?relay`; Banked call to: IRQEnable
    119          }
   \   000065   7F04         MOV       R7,#0x4
   \   000067   02....       LJMP      ?BANKED_LEAVE_SP
    120          
    121          /**
    122          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    123          @params[in] time время сети в тикак
    124          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    125          static inline uint32_t calcCompareTime(nwtime_t time){   
   \                     ??calcCompareTime:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 6
   \   000005   7406         MOV       A,#0x6
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   90FFF9       MOV       DPTR,#-0x7
   \   00000D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
    126              uint32_t timer = ReadTimer(); // Текущее значение счетчика
   \   000015                ; Setup parameters for call to function ReadTimer
   \   000015   12....       LCALL     `??ReadTimer::?relay`; Banked call to: ReadTimer
   \   000018   8A..         MOV       ?V4,R2
   \   00001A   8B..         MOV       ?V5,R3
   \   00001C   8C..         MOV       ?V6,R4
   \   00001E   8D..         MOV       ?V7,R5
    127              //NETWORK TIME = TIMER + TOFFSET  
    128              // Приводим такты к тактам таймера
    129              uint16_t ticks_offset = (time - TOFFSET) & 0x7FFF;
   \   000020   90FFF9       MOV       DPTR,#-0x7
   \   000023   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000026   C082         PUSH      DPL
   \   000028   C083         PUSH      DPH
   \   00002A   90....       MOV       DPTR,#??TOFFSET
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   F8           MOV       R0,A
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F9           MOV       R1,A
   \   000032   D083         POP       DPH
   \   000034   D082         POP       DPL
   \   000036   E0           MOVX      A,@DPTR
   \   000037   C3           CLR       C
   \   000038   98           SUBB      A,R0
   \   000039   F8           MOV       R0,A
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   99           SUBB      A,R1
   \   00003D   F9           MOV       R1,A
   \   00003E   E8           MOV       A,R0
   \   00003F   54FF         ANL       A,#0xff
   \   000041   FE           MOV       R6,A
   \   000042   E9           MOV       A,R1
   \   000043   547F         ANL       A,#0x7f
   \   000045   FF           MOV       R7,A
    130              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
   \   000046   85....       MOV       ?V0,?V4
   \   000049   85....       MOV       ?V1,?V5
   \   00004C   85....       MOV       ?V2,?V6
   \   00004F   85....       MOV       ?V3,?V7
   \   000052   90....       MOV       DPTR,#__Constant_ffff8000
   \   000055   78..         MOV       R0,#?V0
   \   000057   12....       LCALL     ?L_AND_X
   \   00005A   90FFFB       MOV       DPTR,#-0x5
   \   00005D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000060   78..         MOV       R0,#?V0
   \   000062   12....       LCALL     ?L_MOV_TO_X
    131              cmp_time |= ticks_offset; // Вычисляем новое время
   \   000065   8E..         MOV       ?V0,R6
   \   000067   8F..         MOV       ?V1,R7
   \   000069   E4           CLR       A
   \   00006A   F5..         MOV       ?V2,A
   \   00006C   F5..         MOV       ?V3,A
   \   00006E   90FFFB       MOV       DPTR,#-0x5
   \   000071   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000074   78..         MOV       R0,#?V0
   \   000076   12....       LCALL     ?L_IOR_TO_X
    132              if (cmp_time <= timer){
   \   000079   90FFFB       MOV       DPTR,#-0x5
   \   00007C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00007F   78..         MOV       R0,#?V4
   \   000081   12....       LCALL     ?UL_GE_X
   \   000084   5026         JNC       ??calcCompareTime_1
    133                cmp_time += 0x8000;
   \   000086   90....       MOV       DPTR,#__Constant_8000
   \   000089   78..         MOV       R0,#?V0
   \   00008B   12....       LCALL     ?L_MOV_X
   \   00008E   90FFFB       MOV       DPTR,#-0x5
   \   000091   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000094   78..         MOV       R0,#?V0
   \   000096   12....       LCALL     ?L_ADD_TO_X
    134                cmp_time &=0xFFFFFF;
   \   000099   90....       MOV       DPTR,#__Constant_ffffff
   \   00009C   78..         MOV       R0,#?V0
   \   00009E   12....       LCALL     ?L_MOV_X
   \   0000A1   90FFFB       MOV       DPTR,#-0x5
   \   0000A4   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A7   78..         MOV       R0,#?V0
   \   0000A9   12....       LCALL     ?L_AND_TO_X
    135              }
    136               LOG_OFF("Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    137                    timer, ticks, cmp_time );
    138              return cmp_time;
   \                     ??calcCompareTime_1:
   \   0000AC   90FFFB       MOV       DPTR,#-0x5
   \   0000AF   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000B2   12....       LCALL     ?XLOAD_R2345
   \   0000B5   74FA         MOV       A,#-0x6
   \   0000B7   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000BA   7F08         MOV       R7,#0x8
   \   0000BC   02....       LJMP      ?BANKED_LEAVE_SP
    139          }
    140          
    141          /**
    142          @brief Возвращает текущее значение таймера
    143          @return Текущие ticks
    144          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          static uint32_t ReadTimer(void){
   \                     ??ReadTimer:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    146            static union 
    147            {
    148              uint32_t val;
    149              uint8_t fild[4];
    150            } ret_val;
    151            ret_val.val = 0;
   \   000000   90....       MOV       DPTR,#??ret_val
   \   000003   7400         MOV       A,#0x0
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   7400         MOV       A,#0x0
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   A3           INC       DPTR
   \   00000B   7400         MOV       A,#0x0
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   A3           INC       DPTR
   \   00000F   7400         MOV       A,#0x0
   \   000011   F0           MOVX      @DPTR,A
    152            // Ждем синхронизацию таймера после пробуждения
    153            while (!(SLEEPSTA & 0x01));
   \                     ??ReadTimer_1:
   \   000012   E59D         MOV       A,0x9d
   \   000014   A2E0         MOV       C,0xE0 /* A   */.0
   \   000016   50FA         JNC       ??ReadTimer_1
    154            // Соблюдаем порядок чтения регисторов ST  
    155            ret_val.fild[0] = ST0;
   \   000018   E595         MOV       A,0x95
   \   00001A   90....       MOV       DPTR,#??ret_val
   \   00001D   F0           MOVX      @DPTR,A
    156            ret_val.fild[1] = ST1;
   \   00001E   E596         MOV       A,0x96
   \   000020   90....       MOV       DPTR,#??ret_val + 1
   \   000023   F0           MOVX      @DPTR,A
    157            ret_val.fild[2] = ST2;
   \   000024   E597         MOV       A,0x97
   \   000026   90....       MOV       DPTR,#??ret_val + 2
   \   000029   F0           MOVX      @DPTR,A
    158            return ret_val.val;
   \   00002A   90....       MOV       DPTR,#??ret_val
   \   00002D   12....       LCALL     ?XLOAD_R2345
   \   000030   02....       LJMP      ?BRET
   \   000033                REQUIRE SLEEPSTA
   \   000033                REQUIRE ST0
   \   000033                REQUIRE ST1
   \   000033                REQUIRE ST2
    159          }

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??ret_val:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    160          
    161          /**
    162          @brief Устанавливает время пробуждения микроконтролера
    163          @params[in] ticks 24 битное значение времени пробуждения в ticks
    164          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    165          static void loadTimerCompare(uint32_t ticks){
   \                     ??loadTimerCompare:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004   C0..         PUSH      ?V2
   \   000006   C0..         PUSH      ?V3
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 4
   \   000008   7404         MOV       A,#0x4
   \   00000A   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000D   8A..         MOV       ?V0,R2
   \   00000F   8B..         MOV       ?V1,R3
   \   000011   8C..         MOV       ?V2,R4
   \   000013   8D..         MOV       ?V3,R5
    166            union 
    167            {
    168              uint32_t val;
    169              uint8_t fild[4];
    170            } value;
    171            value.val = ticks;
   \   000015   90FFFB       MOV       DPTR,#-0x5
   \   000018   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00001B   78..         MOV       R0,#?V0
   \   00001D   12....       LCALL     ?L_MOV_TO_X
    172            // Ждем разрешения на запись нового значения
    173            while (!(STLOAD & 0x01));
   \                     ??loadTimerCompare_1:
   \   000020   E5AD         MOV       A,0xad
   \   000022   A2E0         MOV       C,0xE0 /* A   */.0
   \   000024   50FA         JNC       ??loadTimerCompare_1
    174            // Регистр ST0 должен быть записан в последнию очередь
    175            ST2 = value.fild[2];
   \   000026   90FFFD       MOV       DPTR,#-0x3
   \   000029   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F597         MOV       0x97,A
    176            ST1 = value.fild[1];
   \   00002F   90FFFC       MOV       DPTR,#-0x4
   \   000032   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000035   E0           MOVX      A,@DPTR
   \   000036   F596         MOV       0x96,A
    177            ST0 = value.fild[0];
   \   000038   90FFFB       MOV       DPTR,#-0x5
   \   00003B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   F595         MOV       0x95,A
    178          }
   \   000041   74FC         MOV       A,#-0x4
   \   000043   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000046   D0..         POP       ?V3
   \   000048   D0..         POP       ?V2
   \   00004A   D0..         POP       ?V1
   \   00004C   D0..         POP       ?V0
   \   00004E   02....       LJMP      ?BRET
   \   000051                REQUIRE STLOAD
   \   000051                REQUIRE ST2
   \   000051                REQUIRE ST1
   \   000051                REQUIRE ST0
    179          
    180          /**
    181          @brief Проверка активности прерывания таймера
    182          @return true если прерывание установленно
    183          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    184          static inline bool isIRQEnable(void){
   \                     ??isIRQEnable:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    185            return STIE;
   \   000000   A2AD         MOV       C,0xa8.5
   \   000002   02....       LJMP      ?BRET
   \   000005                REQUIRE _A_IEN0
    186          }
    187          
    188          /**
    189          @brief Обработчик прерывания таймера сна
    190          */
    191          #pragma vector=ST_VECTOR

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    192          __interrupt void TimerCompareInterrupt(void){ 
   \                     TimerCompareInterrupt:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   C0E0         PUSH      A
   \   000002   7402         MOV       A,#0x2
   \   000004   12....       LCALL     ?INTERRUPT_ENTER_ESP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    193            nwtime_t time = AT_time();
   \   000007                ; Setup parameters for call to function AT_time
   \   000007   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   AE..         MOV       R6,?V0
   \   000010   AF..         MOV       R7,?V1
    194            // Отключаем прерывание таймера. Забота пользователя его включить
    195            IRQEnable(false); 
   \   000012                ; Setup parameters for call to function IRQEnable
   \   000012   C2F0         CLR       B.0
   \   000014   12....       LCALL     `??IRQEnable::?relay`; Banked call to: IRQEnable
    196            TM_IRQ(time); // Передаем управление менеджеру времени
   \   000017                ; Setup parameters for call to function TM_IRQ
   \   000017   EE           MOV       A,R6
   \   000018   FA           MOV       R2,A
   \   000019   EF           MOV       A,R7
   \   00001A   FB           MOV       R3,A
   \   00001B   12....       LCALL     `??TM_IRQ::?relay`; Banked call to: TM_IRQ
    197            STIF = 0; // Очищаем флаг прерывания
   \   00001E   C2C7         CLR       0xc0.7
    198          }
   \   000020   7F02         MOV       R7,#0x2
   \   000022   02....       LJMP      ?INTERRUPT_LEAVE_ESP
   \   000025                REQUIRE _A_IRCON
E:\Neocore\Hardware\STACK_CORE_SRC\buffer.c
      1          #include "debug.h"
      2          #include "macros.h"
      3          #include "frame.h"
      4          #include "stdbool.h"
      5          #include "cpu.h"

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant char __cli(void)
   \                     ??__cli_1:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   C2AF         CLR       0xa8.7
   \   000002   7901         MOV       R1,#0x1
   \   000004   02....       LJMP      ?BRET
   \   000007                REQUIRE _A_IEN0
      6          #include "list.h"

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant void INIT_LIST_HEAD(struct list_head *)
   \                     ??INIT_LIST_HEAD:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   EA           MOV       A,R2
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   EB           MOV       A,R3
   \   000008   F0           MOVX      @DPTR,A
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   EA           MOV       A,R2
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   EB           MOV       A,R3
   \   000013   F0           MOVX      @DPTR,A
   \   000014   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant bool __list_add_valid(struct list_head *, struct list_head *, struct list_head *)
   \                     ??__list_add_valid:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   D3           SETB      C
   \   000001   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant bool __list_del_entry_valid(struct list_head *)
   \                     ??__list_del_entry_valid:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   D3           SETB      C
   \   000001   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant void __list_add(struct list_head *, struct list_head *, struct list_head *)
   \                     ??__list_add:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
   \   00000D   90FFF3       MOV       DPTR,#-0xd
   \   000010   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F5..         MOV       ?V2,A
   \   000016   A3           INC       DPTR
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F5..         MOV       ?V3,A
   \   00001A                ; Setup parameters for call to function __list_add_valid
   \   00001A   C0..         PUSH      ?V2
   \   00001C   C0..         PUSH      ?V3
   \   00001E   AC..         MOV       R4,?V0
   \   000020   AD..         MOV       R5,?V1
   \   000022   EE           MOV       A,R6
   \   000023   FA           MOV       R2,A
   \   000024   EF           MOV       A,R7
   \   000025   FB           MOV       R3,A
   \   000026   12....       LCALL     `??__list_add_valid::?relay`; Banked call to: __list_add_valid
   \   000029   D0E0         POP       A
   \   00002B   D0E0         POP       A
   \   00002D   5030         JNC       ??__list_add_1
   \   00002F   85..82       MOV       DPL,?V2
   \   000032   85..83       MOV       DPH,?V3
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   EE           MOV       A,R6
   \   000038   F0           MOVX      @DPTR,A
   \   000039   A3           INC       DPTR
   \   00003A   EF           MOV       A,R7
   \   00003B   F0           MOVX      @DPTR,A
   \   00003C   8E82         MOV       DPL,R6
   \   00003E   8F83         MOV       DPH,R7
   \   000040   E5..         MOV       A,?V2
   \   000042   F0           MOVX      @DPTR,A
   \   000043   A3           INC       DPTR
   \   000044   E5..         MOV       A,?V3
   \   000046   F0           MOVX      @DPTR,A
   \   000047   8E82         MOV       DPL,R6
   \   000049   8F83         MOV       DPH,R7
   \   00004B   A3           INC       DPTR
   \   00004C   A3           INC       DPTR
   \   00004D   E5..         MOV       A,?V0
   \   00004F   F0           MOVX      @DPTR,A
   \   000050   A3           INC       DPTR
   \   000051   E5..         MOV       A,?V1
   \   000053   F0           MOVX      @DPTR,A
   \   000054   85..82       MOV       DPL,?V0
   \   000057   85..83       MOV       DPH,?V1
   \   00005A   EE           MOV       A,R6
   \   00005B   F0           MOVX      @DPTR,A
   \   00005C   A3           INC       DPTR
   \   00005D   EF           MOV       A,R7
   \   00005E   F0           MOVX      @DPTR,A
   \                     ??__list_add_1:
   \   00005F   7F04         MOV       R7,#0x4
   \   000061   02....       LJMP      ?BANKED_LEAVE_SP

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant void list_add(struct list_head *, struct list_head *)
   \                     ??list_add:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   \   00000D                ; Setup parameters for call to function __list_add
   \   00000D   8E82         MOV       DPL,R6
   \   00000F   8F83         MOV       DPH,R7
   \   000011   12....       LCALL     ?PUSH_ISTACK_X_TWO
   \   000014   EE           MOV       A,R6
   \   000015   FC           MOV       R4,A
   \   000016   EF           MOV       A,R7
   \   000017   FD           MOV       R5,A
   \   000018   AA..         MOV       R2,?V2
   \   00001A   AB..         MOV       R3,?V3
   \   00001C   12....       LCALL     `??__list_add::?relay`; Banked call to: __list_add
   \   00001F   D0E0         POP       A
   \   000021   D0E0         POP       A
   \   000023   7F04         MOV       R7,#0x4
   \   000025   02....       LJMP      ?BANKED_LEAVE_SP

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant void __list_del(struct list_head *, struct list_head *)
   \                     ??__list_del:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8C82         MOV       DPL,R4
   \   000002   8D83         MOV       DPH,R5
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   EA           MOV       A,R2
   \   000007   F0           MOVX      @DPTR,A
   \   000008   A3           INC       DPTR
   \   000009   EB           MOV       A,R3
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   8A82         MOV       DPL,R2
   \   00000D   8B83         MOV       DPH,R3
   \   00000F   EC           MOV       A,R4
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   ED           MOV       A,R5
   \   000013   F0           MOVX      @DPTR,A
   \   000014   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant void __list_del_entry(struct list_head *)
   \                     ??__list_del_entry:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
   \   000006   EA           MOV       A,R2
   \   000007   FE           MOV       R6,A
   \   000008   EB           MOV       A,R3
   \   000009   FF           MOV       R7,A
   \   00000A                ; Setup parameters for call to function __list_del_entry_valid
   \   00000A   EE           MOV       A,R6
   \   00000B   FA           MOV       R2,A
   \   00000C   EF           MOV       A,R7
   \   00000D   FB           MOV       R3,A
   \   00000E   12....       LCALL     `??__list_del_entry_valid::?relay`; Banked call to: __list_del_entry_valid
   \   000011   5017         JNC       ??__list_del_entry_1
   \   000013                ; Setup parameters for call to function __list_del
   \   000013   8E82         MOV       DPL,R6
   \   000015   8F83         MOV       DPH,R7
   \   000017   E0           MOVX      A,@DPTR
   \   000018   FC           MOV       R4,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   FD           MOV       R5,A
   \   00001C   8E82         MOV       DPL,R6
   \   00001E   8F83         MOV       DPH,R7
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   FA           MOV       R2,A
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \   000026   FB           MOV       R3,A
   \   000027   12....       LCALL     `??__list_del::?relay`; Banked call to: __list_del
   \                     ??__list_del_entry_1:
   \   00002A   D0E0         POP       A
   \   00002C   FF           MOV       R7,A
   \   00002D   D0E0         POP       A
   \   00002F   FE           MOV       R6,A
   \   000030   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant void list_del(struct list_head *)
   \                     ??list_del:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
   \   000006   EA           MOV       A,R2
   \   000007   FE           MOV       R6,A
   \   000008   EB           MOV       A,R3
   \   000009   FF           MOV       R7,A
   \   00000A                ; Setup parameters for call to function __list_del_entry
   \   00000A   EE           MOV       A,R6
   \   00000B   FA           MOV       R2,A
   \   00000C   EF           MOV       A,R7
   \   00000D   FB           MOV       R3,A
   \   00000E   12....       LCALL     `??__list_del_entry::?relay`; Banked call to: __list_del_entry
   \   000011   8E82         MOV       DPL,R6
   \   000013   8F83         MOV       DPH,R7
   \   000015   7401         MOV       A,#0x1
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   7401         MOV       A,#0x1
   \   00001B   F0           MOVX      @DPTR,A
   \   00001C   8E82         MOV       DPL,R6
   \   00001E   8F83         MOV       DPH,R7
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   7402         MOV       A,#0x2
   \   000024   F0           MOVX      @DPTR,A
   \   000025   A3           INC       DPTR
   \   000026   7402         MOV       A,#0x2
   \   000028   F0           MOVX      @DPTR,A
   \   000029   D0E0         POP       A
   \   00002B   FF           MOV       R7,A
   \   00002C   D0E0         POP       A
   \   00002E   FE           MOV       R6,A
   \   00002F   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant int list_is_last(struct list_head const *, struct list_head const *)
   \                     ??list_is_last:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F8           MOV       R0,A
   \   000006   A3           INC       DPTR
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F9           MOV       R1,A
   \   000009   EC           MOV       A,R4
   \   00000A   68           XRL       A,R0
   \   00000B   7002         JNZ       ??list_is_last_1
   \   00000D   ED           MOV       A,R5
   \   00000E   69           XRL       A,R1
   \                     ??list_is_last_1:
   \   00000F   7004         JNZ       ??list_is_last_2
   \   000011   D2F0         SETB      B.0
   \   000013   8002         SJMP      ??list_is_last_3
   \                     ??list_is_last_2:
   \   000015   C2F0         CLR       B.0
   \                     ??list_is_last_3:
   \   000017   A2F0         MOV       C,B.0
   \   000019   E4           CLR       A
   \   00001A   33           RLC       A
   \   00001B   FA           MOV       R2,A
   \   00001C   7B00         MOV       R3,#0x0
   \   00001E   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant int list_empty(struct list_head const *)
   \                     ??list_empty:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F8           MOV       R0,A
   \   000006   A3           INC       DPTR
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F9           MOV       R1,A
   \   000009   EA           MOV       A,R2
   \   00000A   68           XRL       A,R0
   \   00000B   7002         JNZ       ??list_empty_1
   \   00000D   EB           MOV       A,R3
   \   00000E   69           XRL       A,R1
   \                     ??list_empty_1:
   \   00000F   7004         JNZ       ??list_empty_2
   \   000011   D2F0         SETB      B.0
   \   000013   8002         SJMP      ??list_empty_3
   \                     ??list_empty_2:
   \   000015   C2F0         CLR       B.0
   \                     ??list_empty_3:
   \   000017   A2F0         MOV       C,B.0
   \   000019   E4           CLR       A
   \   00001A   33           RLC       A
   \   00001B   FA           MOV       R2,A
   \   00001C   7B00         MOV       R3,#0x0
   \   00001E   02....       LJMP      ?BRET
      7          
      8          #include "action_manager.h"
      9          static void SW_Init(void);
     10          static void IRQ_Init(void);

   \                                 In  segment XDATA_I, align 1, keep-with-next
     11          module_s BF_MODULE = {ALIAS(SW_Init),ALIAS(IRQ_Init)};
   \                     BF_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for BF_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     12          
     13          struct node {
     14            struct frame *frame;
     15            struct list_head list ;
     16          };
     17          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     18          static struct node NODE_LIST[MAX_TXRX_BUFF_SIZE];
   \                     ??NODE_LIST:
   \   000000                DS 120
   \   000078                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
     19          LIST_HEAD(TX_LIST_HEAD);
   \                     TX_LIST_HEAD:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for TX_LIST_HEAD>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
     20          LIST_HEAD(RX_LIST_HEAD);
   \                     RX_LIST_HEAD:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for RX_LIST_HEAD>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     21          static int TX_BUFF_FRAME_COUNT;
   \                     ??TX_BUFF_FRAME_COUNT:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     22          static int RX_BUFF_FRAME_COUNT;
   \                     ??RX_BUFF_FRAME_COUNT:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     23          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     24          static void IRQ_Init(void){};
   \                     ??IRQ_Init:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP      ?BRET
     25          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     26          static void SW_Init(void){
   \                     ??SW_Init:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
     27            TX_BUFF_FRAME_COUNT = 0;
   \   000006   90....       MOV       DPTR,#??TX_BUFF_FRAME_COUNT
   \   000009   7400         MOV       A,#0x0
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   A3           INC       DPTR
   \   00000D   7400         MOV       A,#0x0
   \   00000F   F0           MOVX      @DPTR,A
     28            RX_BUFF_FRAME_COUNT = 0;
   \   000010   90....       MOV       DPTR,#??RX_BUFF_FRAME_COUNT
   \   000013   7400         MOV       A,#0x0
   \   000015   F0           MOVX      @DPTR,A
   \   000016   A3           INC       DPTR
   \   000017   7400         MOV       A,#0x0
   \   000019   F0           MOVX      @DPTR,A
     29            INIT_LIST_HEAD(&TX_LIST_HEAD);
   \   00001A                ; Setup parameters for call to function INIT_LIST_HEAD
   \   00001A   7A..         MOV       R2,#TX_LIST_HEAD & 0xff
   \   00001C   7B..         MOV       R3,#(TX_LIST_HEAD >> 8) & 0xff
   \   00001E   12....       LCALL     `??INIT_LIST_HEAD::?relay`; Banked call to: INIT_LIST_HEAD
     30            INIT_LIST_HEAD(&RX_LIST_HEAD);
   \   000021                ; Setup parameters for call to function INIT_LIST_HEAD
   \   000021   7A..         MOV       R2,#RX_LIST_HEAD & 0xff
   \   000023   7B..         MOV       R3,#(RX_LIST_HEAD >> 8) & 0xff
   \   000025   12....       LCALL     `??INIT_LIST_HEAD::?relay`; Banked call to: INIT_LIST_HEAD
     31            
     32            for_each_type(struct node, NODE_LIST, node){
   \   000028   7E..         MOV       R6,#??NODE_LIST & 0xff
   \   00002A   7F..         MOV       R7,#(??NODE_LIST >> 8) & 0xff
   \                     ??SW_Init_10:
   \   00002C   C3           CLR       C
   \   00002D   EE           MOV       A,R6
   \   00002E   94..         SUBB      A,#(??NODE_LIST + 120) & 0xff
   \   000030   EF           MOV       A,R7
   \   000031   94..         SUBB      A,#((??NODE_LIST + 120) >> 8) & 0xff
   \   000033   501E         JNC       ??SW_Init_11
     33              node->frame = NULL;
   \   000035   8E82         MOV       DPL,R6
   \   000037   8F83         MOV       DPH,R7
   \   000039   7400         MOV       A,#0x0
   \   00003B   F0           MOVX      @DPTR,A
   \   00003C   A3           INC       DPTR
   \   00003D   7400         MOV       A,#0x0
   \   00003F   F0           MOVX      @DPTR,A
     34              INIT_LIST_HEAD(&node->list);
   \   000040                ; Setup parameters for call to function INIT_LIST_HEAD
   \   000040   EE           MOV       A,R6
   \   000041   2402         ADD       A,#0x2
   \   000043   FA           MOV       R2,A
   \   000044   E4           CLR       A
   \   000045   3F           ADDC      A,R7
   \   000046   FB           MOV       R3,A
   \   000047   12....       LCALL     `??INIT_LIST_HEAD::?relay`; Banked call to: INIT_LIST_HEAD
     35            }
   \   00004A   EE           MOV       A,R6
   \   00004B   2406         ADD       A,#0x6
   \   00004D   FE           MOV       R6,A
   \   00004E   50DC         JNC       ??SW_Init_10
   \   000050   0F           INC       R7
   \   000051   80D9         SJMP      ??SW_Init_10
     36          };
   \                     ??SW_Init_11:
   \   000053   D0E0         POP       A
   \   000055   FF           MOV       R7,A
   \   000056   D0E0         POP       A
   \   000058   FE           MOV       R6,A
   \   000059   02....       LJMP      ?BRET
     37          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     38          int BF_rx_busy(){
   \                     BF_rx_busy:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     39            return RX_BUFF_FRAME_COUNT;
   \   000000   90....       MOV       DPTR,#??RX_BUFF_FRAME_COUNT
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FA           MOV       R2,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   FB           MOV       R3,A
   \   000008   02....       LJMP      ?BRET
     40          };
     41          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     42          int BF_tx_busy(){
   \                     BF_tx_busy:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     43            return TX_BUFF_FRAME_COUNT;
   \   000000   90....       MOV       DPTR,#??TX_BUFF_FRAME_COUNT
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FA           MOV       R2,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   FB           MOV       R3,A
   \   000008   02....       LJMP      ?BRET
     44          }
     45          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     46          int BF_available(){
   \                     BF_available:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
     47            int summ = RX_BUFF_FRAME_COUNT + TX_BUFF_FRAME_COUNT;
   \   000006   90....       MOV       DPTR,#??RX_BUFF_FRAME_COUNT
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   F8           MOV       R0,A
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F9           MOV       R1,A
   \   00000E   90....       MOV       DPTR,#??TX_BUFF_FRAME_COUNT
   \   000011   E0           MOVX      A,@DPTR
   \   000012   28           ADD       A,R0
   \   000013   FE           MOV       R6,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   39           ADDC      A,R1
   \   000017   FF           MOV       R7,A
     48            ASSERT(summ <= MAX_TXRX_BUFF_SIZE);
   \   000018   C3           CLR       C
   \   000019   EE           MOV       A,R6
   \   00001A   9415         SUBB      A,#0x15
   \   00001C   EF           MOV       A,R7
   \   00001D   9400         SUBB      A,#0x0
   \   00001F   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000021   65D0         XRL       A,PSW
   \   000023   33           RLC       A
   \   000024   401F         JC        ??BF_available_0
   \   000026                ; Setup parameters for call to function printf
   \   000026   7430         MOV       A,#0x30
   \   000028   C0E0         PUSH      A
   \   00002A   7400         MOV       A,#0x0
   \   00002C   C0E0         PUSH      A
   \   00002E   74..         MOV       A,#`?<Constant "buffer.c">` & 0xff
   \   000030   C0E0         PUSH      A
   \   000032   74..         MOV       A,#(`?<Constant "buffer.c">` >> 8) & 0xff
   \   000034   C0E0         PUSH      A
   \   000036   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_2` & 0xff
   \   000038   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_2` >> 8) & 0xff
   \   00003A   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00003D   74FC         MOV       A,#-0x4
   \   00003F   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000042                ; Setup parameters for call to function DBG_CORE_HALT
   \   000042   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     49            return MAX_TXRX_BUFF_SIZE - summ;
   \                     ??BF_available_0:
   \   000045   7414         MOV       A,#0x14
   \   000047   C3           CLR       C
   \   000048   9E           SUBB      A,R6
   \   000049   FA           MOV       R2,A
   \   00004A   7400         MOV       A,#0x0
   \   00004C   9F           SUBB      A,R7
   \   00004D   FB           MOV       R3,A
   \   00004E   D0E0         POP       A
   \   000050   FF           MOV       R7,A
   \   000051   D0E0         POP       A
   \   000053   FE           MOV       R6,A
   \   000054   02....       LJMP      ?BRET
     50          }
     51          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     52          int BF_available_tx(){
   \                     BF_available_tx:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     53            int summ = MAX_TX_BUFF - TX_BUFF_FRAME_COUNT;
   \   000000   90....       MOV       DPTR,#??TX_BUFF_FRAME_COUNT
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F9           MOV       R1,A
   \   000008   740A         MOV       A,#0xa
   \   00000A   C3           CLR       C
   \   00000B   98           SUBB      A,R0
   \   00000C   FA           MOV       R2,A
   \   00000D   7400         MOV       A,#0x0
   \   00000F   99           SUBB      A,R1
   \   000010   FB           MOV       R3,A
     54            return summ;
   \   000011   02....       LJMP      ?BRET
     55          }
     56          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     57          int BF_available_rx(){
   \                     BF_available_rx:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     58            int summ = MAX_RX_BUFF - RX_BUFF_FRAME_COUNT;
   \   000000   90....       MOV       DPTR,#??RX_BUFF_FRAME_COUNT
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F9           MOV       R1,A
   \   000008   740A         MOV       A,#0xa
   \   00000A   C3           CLR       C
   \   00000B   98           SUBB      A,R0
   \   00000C   FA           MOV       R2,A
   \   00000D   7400         MOV       A,#0x0
   \   00000F   99           SUBB      A,R1
   \   000010   FB           MOV       R3,A
     59            return summ;
   \   000011   02....       LJMP      ?BRET
     60          }
     61          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     62          static inline struct node* find_free_node(void){
   \                     ??find_free_node:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
     63            for_each_type(struct node, NODE_LIST, node)
   \   000006   7E..         MOV       R6,#??NODE_LIST & 0xff
   \   000008   7F..         MOV       R7,#(??NODE_LIST >> 8) & 0xff
   \                     ??find_free_node_1:
   \   00000A   C3           CLR       C
   \   00000B   EE           MOV       A,R6
   \   00000C   94..         SUBB      A,#(??NODE_LIST + 120) & 0xff
   \   00000E   EF           MOV       A,R7
   \   00000F   94..         SUBB      A,#((??NODE_LIST + 120) >> 8) & 0xff
   \   000011   5026         JNC       ??find_free_node_2
     64              if (node->frame == NULL){
   \   000013   8E82         MOV       DPL,R6
   \   000015   8F83         MOV       DPH,R7
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F8           MOV       R0,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F9           MOV       R1,A
   \   00001C   E8           MOV       A,R0
   \   00001D   49           ORL       A,R1
   \   00001E   7010         JNZ       ??find_free_node_3
     65                INIT_LIST_HEAD(&node->list);
   \   000020                ; Setup parameters for call to function INIT_LIST_HEAD
   \   000020   EE           MOV       A,R6
   \   000021   2402         ADD       A,#0x2
   \   000023   FA           MOV       R2,A
   \   000024   E4           CLR       A
   \   000025   3F           ADDC      A,R7
   \   000026   FB           MOV       R3,A
   \   000027   12....       LCALL     `??INIT_LIST_HEAD::?relay`; Banked call to: INIT_LIST_HEAD
     66                return node;
   \   00002A   EE           MOV       A,R6
   \   00002B   FA           MOV       R2,A
   \   00002C   EF           MOV       A,R7
   \   00002D   FB           MOV       R3,A
   \   00002E   800D         SJMP      ??find_free_node_4
     67              }
   \                     ??find_free_node_3:
   \   000030   EE           MOV       A,R6
   \   000031   2406         ADD       A,#0x6
   \   000033   FE           MOV       R6,A
   \   000034   50D4         JNC       ??find_free_node_1
   \   000036   0F           INC       R7
   \   000037   80D1         SJMP      ??find_free_node_1
     68            return NULL;
   \                     ??find_free_node_2:
   \   000039   7A00         MOV       R2,#0x0
   \   00003B   7B00         MOV       R3,#0x0
   \                     ??find_free_node_4:
   \   00003D   D0E0         POP       A
   \   00003F   FF           MOV       R7,A
   \   000040   D0E0         POP       A
   \   000042   FE           MOV       R6,A
   \   000043   02....       LJMP      ?BRET
     69          };
     70          
     71          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     72          static inline bool _push(struct list_head *list, struct frame *frame){
   \                     ??_push:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
     73            ASSERT(frame != NULL);
   \   00000D   E5..         MOV       A,?V0
   \   00000F   45..         ORL       A,?V1
   \   000011   701F         JNZ       ??_push_1
   \   000013                ; Setup parameters for call to function printf
   \   000013   7449         MOV       A,#0x49
   \   000015   C0E0         PUSH      A
   \   000017   7400         MOV       A,#0x0
   \   000019   C0E0         PUSH      A
   \   00001B   74..         MOV       A,#`?<Constant "buffer.c">` & 0xff
   \   00001D   C0E0         PUSH      A
   \   00001F   74..         MOV       A,#(`?<Constant "buffer.c">` >> 8) & 0xff
   \   000021   C0E0         PUSH      A
   \   000023   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_2` & 0xff
   \   000025   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_2` >> 8) & 0xff
   \   000027   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00002A   74FC         MOV       A,#-0x4
   \   00002C   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002F                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002F   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     74            struct node *node = find_free_node();
   \                     ??_push_1:
   \   000032                ; Setup parameters for call to function find_free_node
   \   000032   12....       LCALL     `??find_free_node::?relay`; Banked call to: find_free_node
   \   000035   8A..         MOV       ?V4,R2
   \   000037   8B..         MOV       ?V5,R3
   \   000039   AE..         MOV       R6,?V4
   \   00003B   AF..         MOV       R7,?V5
     75            if (!node) // Нет свободных мест
   \   00003D   EE           MOV       A,R6
   \   00003E   4F           ORL       A,R7
   \   00003F   7003         JNZ       ??_push_2
     76              return false;
   \   000041   C3           CLR       C
   \   000042   801A         SJMP      ??_push_3
     77            node->frame = frame;
   \                     ??_push_2:
   \   000044   8E82         MOV       DPL,R6
   \   000046   8F83         MOV       DPH,R7
   \   000048   E5..         MOV       A,?V0
   \   00004A   F0           MOVX      @DPTR,A
   \   00004B   A3           INC       DPTR
   \   00004C   E5..         MOV       A,?V1
   \   00004E   F0           MOVX      @DPTR,A
     78            list_add(&node->list , list);
   \   00004F                ; Setup parameters for call to function list_add
   \   00004F   AC..         MOV       R4,?V2
   \   000051   AD..         MOV       R5,?V3
   \   000053   EE           MOV       A,R6
   \   000054   2402         ADD       A,#0x2
   \   000056   FA           MOV       R2,A
   \   000057   E4           CLR       A
   \   000058   3F           ADDC      A,R7
   \   000059   FB           MOV       R3,A
   \   00005A   12....       LCALL     `??list_add::?relay`; Banked call to: list_add
     79            return true;
   \   00005D   D3           SETB      C
   \                     ??_push_3:
   \   00005E   7F06         MOV       R7,#0x6
   \   000060   02....       LJMP      ?BANKED_LEAVE_SP
     80          };
     81          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     82          bool BF_push_tx(struct frame *frame){
   \                     BF_push_tx:
   \   000000                REQUIRE ?V0
   \   000000   7401         MOV       A,#0x1
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 4
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
     83            bool res = false;
   \   000009   C2..         CLR       ?VB.0
     84            ATOMIC_BLOCK_RESTORE{
   \   00000B   A2AF         MOV       C,0xa8.7
   \   00000D   E4           CLR       A
   \   00000E   33           RLC       A
   \   00000F   F5..         MOV       ?V0,A
   \   000011                ; Setup parameters for call to function __cli
   \   000011   12....       LCALL     `??__cli::?relay_1`; Banked call to: __cli
   \   000014   E9           MOV       A,R1
   \   000015   F8           MOV       R0,A
   \                     ??BF_push_tx_0:
   \   000016   E8           MOV       A,R0
   \   000017   6039         JZ        ??BF_push_tx_1
     85              if (TX_BUFF_FRAME_COUNT < MAX_TX_BUFF){
   \   000019   90....       MOV       DPTR,#??TX_BUFF_FRAME_COUNT
   \   00001C   C3           CLR       C
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   940A         SUBB      A,#0xa
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   9400         SUBB      A,#0x0
   \   000024   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000026   65D0         XRL       A,PSW
   \   000028   33           RLC       A
   \   000029   501D         JNC       ??BF_push_tx_2
     86                res = _push(&TX_LIST_HEAD, frame);
   \   00002B                ; Setup parameters for call to function _push
   \   00002B   EE           MOV       A,R6
   \   00002C   FC           MOV       R4,A
   \   00002D   EF           MOV       A,R7
   \   00002E   FD           MOV       R5,A
   \   00002F   7A..         MOV       R2,#TX_LIST_HEAD & 0xff
   \   000031   7B..         MOV       R3,#(TX_LIST_HEAD >> 8) & 0xff
   \   000033   12....       LCALL     `??_push::?relay`; Banked call to: _push
   \   000036   92..         MOV       ?VB.0,C
     87                if (res)
   \   000038   A2..         MOV       C,?VB.0
   \   00003A   500C         JNC       ??BF_push_tx_2
     88                  TX_BUFF_FRAME_COUNT++;
   \   00003C   90....       MOV       DPTR,#??TX_BUFF_FRAME_COUNT
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   2401         ADD       A,#0x1
   \   000042   F0           MOVX      @DPTR,A
   \   000043   A3           INC       DPTR
   \   000044   E0           MOVX      A,@DPTR
   \   000045   3400         ADDC      A,#0x0
   \   000047   F0           MOVX      @DPTR,A
     89              }
     90            };
   \                     ??BF_push_tx_2:
   \   000048   7800         MOV       R0,#0x0
   \   00004A   E5..         MOV       A,?V0
   \   00004C   A2E0         MOV       C,0xE0 /* A   */.0
   \   00004E   92AF         MOV       0xa8.7,C
   \   000050   80C4         SJMP      ??BF_push_tx_0
     91            return res;
   \                     ??BF_push_tx_1:
   \   000052   A2..         MOV       C,?VB.0
   \   000054   7F01         MOV       R7,#0x1
   \   000056   02....       LJMP      ?BANKED_LEAVE_SP
   \   000059                REQUIRE _A_IEN0
     92          };
     93          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     94          bool BF_push_rx(struct frame *frame){
   \                     BF_push_rx:
   \   000000                REQUIRE ?V0
   \   000000   7401         MOV       A,#0x1
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 4
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
     95            bool res = false;
   \   000009   C2..         CLR       ?VB.0
     96            ATOMIC_BLOCK_RESTORE{
   \   00000B   A2AF         MOV       C,0xa8.7
   \   00000D   E4           CLR       A
   \   00000E   33           RLC       A
   \   00000F   F5..         MOV       ?V0,A
   \   000011                ; Setup parameters for call to function __cli
   \   000011   12....       LCALL     `??__cli::?relay_1`; Banked call to: __cli
   \   000014   E9           MOV       A,R1
   \   000015   F8           MOV       R0,A
   \                     ??BF_push_rx_0:
   \   000016   E8           MOV       A,R0
   \   000017   6039         JZ        ??BF_push_rx_1
     97              if (RX_BUFF_FRAME_COUNT < MAX_RX_BUFF){
   \   000019   90....       MOV       DPTR,#??RX_BUFF_FRAME_COUNT
   \   00001C   C3           CLR       C
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   940A         SUBB      A,#0xa
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   9400         SUBB      A,#0x0
   \   000024   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000026   65D0         XRL       A,PSW
   \   000028   33           RLC       A
   \   000029   501D         JNC       ??BF_push_rx_2
     98                res = _push(&RX_LIST_HEAD, frame);
   \   00002B                ; Setup parameters for call to function _push
   \   00002B   EE           MOV       A,R6
   \   00002C   FC           MOV       R4,A
   \   00002D   EF           MOV       A,R7
   \   00002E   FD           MOV       R5,A
   \   00002F   7A..         MOV       R2,#RX_LIST_HEAD & 0xff
   \   000031   7B..         MOV       R3,#(RX_LIST_HEAD >> 8) & 0xff
   \   000033   12....       LCALL     `??_push::?relay`; Banked call to: _push
   \   000036   92..         MOV       ?VB.0,C
     99                if (res)
   \   000038   A2..         MOV       C,?VB.0
   \   00003A   500C         JNC       ??BF_push_rx_2
    100                  RX_BUFF_FRAME_COUNT++;
   \   00003C   90....       MOV       DPTR,#??RX_BUFF_FRAME_COUNT
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   2401         ADD       A,#0x1
   \   000042   F0           MOVX      @DPTR,A
   \   000043   A3           INC       DPTR
   \   000044   E0           MOVX      A,@DPTR
   \   000045   3400         ADDC      A,#0x0
   \   000047   F0           MOVX      @DPTR,A
    101              }
    102            };
   \                     ??BF_push_rx_2:
   \   000048   7800         MOV       R0,#0x0
   \   00004A   E5..         MOV       A,?V0
   \   00004C   A2E0         MOV       C,0xE0 /* A   */.0
   \   00004E   92AF         MOV       0xa8.7,C
   \   000050   80C4         SJMP      ??BF_push_rx_0
    103            return res;
   \                     ??BF_push_rx_1:
   \   000052   A2..         MOV       C,?VB.0
   \   000054   7F01         MOV       R7,#0x1
   \   000056   02....       LJMP      ?BANKED_LEAVE_SP
   \   000059                REQUIRE _A_IEN0
    104          };
    105          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    106          void* BF_cursor_rx(void){
   \                     BF_cursor_rx:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   7402         MOV       A,#0x2
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 5
   \   000005                ; Auto size: 0
    107            if (list_empty(&RX_LIST_HEAD)) 
   \   000005                ; Setup parameters for call to function list_empty
   \   000005   7A..         MOV       R2,#RX_LIST_HEAD & 0xff
   \   000007   7B..         MOV       R3,#(RX_LIST_HEAD >> 8) & 0xff
   \   000009   12....       LCALL     `??list_empty::?relay`; Banked call to: list_empty
   \   00000C   8A..         MOV       ?V0,R2
   \   00000E   8B..         MOV       ?V1,R3
   \   000010   E5..         MOV       A,?V0
   \   000012   45..         ORL       A,?V1
   \   000014   6006         JZ        ??BF_cursor_rx_0
    108              return NULL;
   \   000016   7A00         MOV       R2,#0x0
   \   000018   7B00         MOV       R3,#0x0
   \   00001A   802C         SJMP      ??BF_cursor_rx_1
    109            void *ret_val;
    110            ATOMIC_BLOCK_RESTORE{   
   \                     ??BF_cursor_rx_0:
   \   00001C   A2AF         MOV       C,0xa8.7
   \   00001E   E4           CLR       A
   \   00001F   33           RLC       A
   \   000020   F5..         MOV       ?V0,A
   \   000022                ; Setup parameters for call to function __cli
   \   000022   12....       LCALL     `??__cli::?relay_1`; Banked call to: __cli
   \   000025   E9           MOV       A,R1
   \   000026   F8           MOV       R0,A
   \                     ??BF_cursor_rx_2:
   \   000027   E8           MOV       A,R0
   \   000028   601A         JZ        ??BF_cursor_rx_3
    111              struct node *node = list_first_entry(&RX_LIST_HEAD, struct node, list);
   \   00002A   90....       MOV       DPTR,#RX_LIST_HEAD
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   24FE         ADD       A,#-0x2
   \   000030   F8           MOV       R0,A
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   34FF         ADDC      A,#-0x1
   \   000035   F9           MOV       R1,A
    112              ret_val =  node;
   \   000036   E8           MOV       A,R0
   \   000037   FE           MOV       R6,A
   \   000038   E9           MOV       A,R1
   \   000039   FF           MOV       R7,A
    113            }
   \   00003A   7800         MOV       R0,#0x0
   \   00003C   E5..         MOV       A,?V0
   \   00003E   A2E0         MOV       C,0xE0 /* A   */.0
   \   000040   92AF         MOV       0xa8.7,C
   \   000042   80E3         SJMP      ??BF_cursor_rx_2
    114            return ret_val;
   \                     ??BF_cursor_rx_3:
   \   000044   EE           MOV       A,R6
   \   000045   FA           MOV       R2,A
   \   000046   EF           MOV       A,R7
   \   000047   FB           MOV       R3,A
   \                     ??BF_cursor_rx_1:
   \   000048   7F02         MOV       R7,#0x2
   \   00004A   02....       LJMP      ?BANKED_LEAVE_SP
   \   00004D                REQUIRE _A_IEN0
    115          }
    116          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    117          void* BF_cursor_tx(void){
   \                     BF_cursor_tx:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   7402         MOV       A,#0x2
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 5
   \   000005                ; Auto size: 0
    118            if (list_empty(&TX_LIST_HEAD)) 
   \   000005                ; Setup parameters for call to function list_empty
   \   000005   7A..         MOV       R2,#TX_LIST_HEAD & 0xff
   \   000007   7B..         MOV       R3,#(TX_LIST_HEAD >> 8) & 0xff
   \   000009   12....       LCALL     `??list_empty::?relay`; Banked call to: list_empty
   \   00000C   8A..         MOV       ?V0,R2
   \   00000E   8B..         MOV       ?V1,R3
   \   000010   E5..         MOV       A,?V0
   \   000012   45..         ORL       A,?V1
   \   000014   6006         JZ        ??BF_cursor_tx_0
    119              return NULL;
   \   000016   7A00         MOV       R2,#0x0
   \   000018   7B00         MOV       R3,#0x0
   \   00001A   802C         SJMP      ??BF_cursor_tx_1
    120            void *ret_val;
    121            ATOMIC_BLOCK_RESTORE{   
   \                     ??BF_cursor_tx_0:
   \   00001C   A2AF         MOV       C,0xa8.7
   \   00001E   E4           CLR       A
   \   00001F   33           RLC       A
   \   000020   F5..         MOV       ?V0,A
   \   000022                ; Setup parameters for call to function __cli
   \   000022   12....       LCALL     `??__cli::?relay_1`; Banked call to: __cli
   \   000025   E9           MOV       A,R1
   \   000026   F8           MOV       R0,A
   \                     ??BF_cursor_tx_2:
   \   000027   E8           MOV       A,R0
   \   000028   601A         JZ        ??BF_cursor_tx_3
    122              struct node *node = list_first_entry(&TX_LIST_HEAD, struct node, list);
   \   00002A   90....       MOV       DPTR,#TX_LIST_HEAD
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   24FE         ADD       A,#-0x2
   \   000030   F8           MOV       R0,A
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   34FF         ADDC      A,#-0x1
   \   000035   F9           MOV       R1,A
    123              ret_val =  node;
   \   000036   E8           MOV       A,R0
   \   000037   FE           MOV       R6,A
   \   000038   E9           MOV       A,R1
   \   000039   FF           MOV       R7,A
    124            }
   \   00003A   7800         MOV       R0,#0x0
   \   00003C   E5..         MOV       A,?V0
   \   00003E   A2E0         MOV       C,0xE0 /* A   */.0
   \   000040   92AF         MOV       0xa8.7,C
   \   000042   80E3         SJMP      ??BF_cursor_tx_2
    125            return ret_val;
   \                     ??BF_cursor_tx_3:
   \   000044   EE           MOV       A,R6
   \   000045   FA           MOV       R2,A
   \   000046   EF           MOV       A,R7
   \   000047   FB           MOV       R3,A
   \                     ??BF_cursor_tx_1:
   \   000048   7F02         MOV       R7,#0x2
   \   00004A   02....       LJMP      ?BANKED_LEAVE_SP
   \   00004D                REQUIRE _A_IEN0
    126          }  
    127          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    128          void* BF_cursor_next(void* cursor){
   \                     BF_cursor_next:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 50
   \   000005   7432         MOV       A,#0x32
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   8A..         MOV       ?V6,R2
   \   00000C   8B..         MOV       ?V7,R3
    129            if (!cursor)
   \   00000E   E5..         MOV       A,?V6
   \   000010   45..         ORL       A,?V7
   \   000012   7007         JNZ       ??BF_cursor_next_0
    130              return NULL;
   \   000014   7A00         MOV       R2,#0x0
   \   000016   7B00         MOV       R3,#0x0
   \   000018   02....       LJMP      ??BF_cursor_next_1 & 0xFFFF
    131            void *ret_val;
    132            ATOMIC_BLOCK_RESTORE{  
   \                     ??BF_cursor_next_0:
   \   00001B   A2AF         MOV       C,0xa8.7
   \   00001D   E4           CLR       A
   \   00001E   33           RLC       A
   \   00001F   F5..         MOV       ?V2,A
   \   000021                ; Setup parameters for call to function __cli
   \   000021   12....       LCALL     `??__cli::?relay_1`; Banked call to: __cli
   \   000024   E9           MOV       A,R1
   \   000025   F8           MOV       R0,A
   \                     ??BF_cursor_next_2:
   \   000026   E8           MOV       A,R0
   \   000027   7003         JNZ       $+5
   \   000029   02....       LJMP      ??BF_cursor_next_3 & 0xFFFF
    133              TRY{
   \   00002C   90FFCD       MOV       DPTR,#-0x33
   \   00002F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000032   7408         MOV       A,#0x8
   \   000034                REQUIRE ?V7
   \   000034   12....       LCALL     ?SETJMP_XDATA
   \   000037   8A..         MOV       ?V4,R2
   \   000039   8B..         MOV       ?V5,R3
   \   00003B   78..         MOV       R0,#?V4
   \   00003D   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for BF_cursor_next>_0`:
   \   000040   0000         DW        0
   \   000042   01           DB        1
   \   000043   ....         DW        ??BF_cursor_next_4
   \   000045   ....         DW        ??BF_cursor_next_5
   \   000047   ....         DW        ??BF_cursor_next_6
    134                struct node *node = (struct node*)(cursor);
   \                     ??BF_cursor_next_5:
   \   000049   AE..         MOV       R6,?V6
   \   00004B   AF..         MOV       R7,?V7
    135              
    136                // Убедимся что это не конец списков
    137                if (list_is_last(&node->list, &TX_LIST_HEAD))
   \   00004D                ; Setup parameters for call to function list_is_last
   \   00004D   7C..         MOV       R4,#TX_LIST_HEAD & 0xff
   \   00004F   7D..         MOV       R5,#(TX_LIST_HEAD >> 8) & 0xff
   \   000051   EE           MOV       A,R6
   \   000052   2402         ADD       A,#0x2
   \   000054   FA           MOV       R2,A
   \   000055   E4           CLR       A
   \   000056   3F           ADDC      A,R7
   \   000057   FB           MOV       R3,A
   \   000058   12....       LCALL     `??list_is_last::?relay`; Banked call to: list_is_last
   \   00005B   8A..         MOV       ?V4,R2
   \   00005D   8B..         MOV       ?V5,R3
   \   00005F   E5..         MOV       A,?V4
   \   000061   45..         ORL       A,?V5
   \   000063   600F         JZ        ??BF_cursor_next_7
    138                  THROW(1);
   \   000065   7A01         MOV       R2,#0x1
   \   000067   7B00         MOV       R3,#0x0
   \   000069   90FFCD       MOV       DPTR,#-0x33
   \   00006C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00006F   7408         MOV       A,#0x8
   \   000071                REQUIRE ?V7
   \   000071   02....       LJMP      ?LONGJMP_XDATA
    139             
    140                if (list_is_last(&node->list, &RX_LIST_HEAD))
   \                     ??BF_cursor_next_7:
   \   000074                ; Setup parameters for call to function list_is_last
   \   000074   7C..         MOV       R4,#RX_LIST_HEAD & 0xff
   \   000076   7D..         MOV       R5,#(RX_LIST_HEAD >> 8) & 0xff
   \   000078   EE           MOV       A,R6
   \   000079   2402         ADD       A,#0x2
   \   00007B   FA           MOV       R2,A
   \   00007C   E4           CLR       A
   \   00007D   3F           ADDC      A,R7
   \   00007E   FB           MOV       R3,A
   \   00007F   12....       LCALL     `??list_is_last::?relay`; Banked call to: list_is_last
   \   000082   8A..         MOV       ?V4,R2
   \   000084   8B..         MOV       ?V5,R3
   \   000086   E5..         MOV       A,?V4
   \   000088   45..         ORL       A,?V5
   \   00008A   600F         JZ        ??BF_cursor_next_8
    141                  THROW(1); 
   \   00008C   7A01         MOV       R2,#0x1
   \   00008E   7B00         MOV       R3,#0x0
   \   000090   90FFCD       MOV       DPTR,#-0x33
   \   000093   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000096   7408         MOV       A,#0x8
   \   000098                REQUIRE ?V7
   \   000098   02....       LJMP      ?LONGJMP_XDATA
    142              
    143                struct node *next = list_next_entry(node, struct node, list);
   \                     ??BF_cursor_next_8:
   \   00009B   8E82         MOV       DPL,R6
   \   00009D   8F83         MOV       DPH,R7
   \   00009F   A3           INC       DPTR
   \   0000A0   A3           INC       DPTR
   \   0000A1   E0           MOVX      A,@DPTR
   \   0000A2   24FE         ADD       A,#-0x2
   \   0000A4   F8           MOV       R0,A
   \   0000A5   A3           INC       DPTR
   \   0000A6   E0           MOVX      A,@DPTR
   \   0000A7   34FF         ADDC      A,#-0x1
   \   0000A9   F9           MOV       R1,A
    144                ret_val = next;
   \   0000AA   88..         MOV       ?V0,R0
   \   0000AC   89..         MOV       ?V1,R1
    145              }
    146              CATCH(1){
   \   0000AE   8006         SJMP      ??BF_cursor_next_4
    147                ret_val = NULL;
   \                     ??BF_cursor_next_6:
   \   0000B0   75..00       MOV       ?V0,#0x0
   \   0000B3   75..00       MOV       ?V1,#0x0
    148              } 
    149              ETRY;
    150            };
   \                     ??BF_cursor_next_4:
   \   0000B6   7800         MOV       R0,#0x0
   \   0000B8   E5..         MOV       A,?V2
   \   0000BA   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000BC   92AF         MOV       0xa8.7,C
   \   0000BE   02....       LJMP      ??BF_cursor_next_2 & 0xFFFF
    151            return ret_val;
   \                     ??BF_cursor_next_3:
   \   0000C1   AA..         MOV       R2,?V0
   \   0000C3   AB..         MOV       R3,?V1
   \                     ??BF_cursor_next_1:
   \   0000C5   74CE         MOV       A,#-0x32
   \   0000C7   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000CA   7F08         MOV       R7,#0x8
   \   0000CC   02....       LJMP      ?BANKED_LEAVE_SP
   \   0000CF                REQUIRE _A_IEN0
    152          }
    153          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    154          bool BF_remove_tx(void *cursor){
   \                     BF_remove_tx:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   7403         MOV       A,#0x3
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 6
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
    155            if (!cursor)
   \   000009   E5..         MOV       A,?V0
   \   00000B   45..         ORL       A,?V1
   \   00000D   7003         JNZ       ??BF_remove_tx_0
    156              return false;
   \   00000F   C3           CLR       C
   \   000010   803E         SJMP      ??BF_remove_tx_1
    157            ATOMIC_BLOCK_RESTORE{
   \                     ??BF_remove_tx_0:
   \   000012   A2AF         MOV       C,0xa8.7
   \   000014   E4           CLR       A
   \   000015   33           RLC       A
   \   000016   F5..         MOV       ?V2,A
   \   000018                ; Setup parameters for call to function __cli
   \   000018   12....       LCALL     `??__cli::?relay_1`; Banked call to: __cli
   \   00001B   E9           MOV       A,R1
   \   00001C   F8           MOV       R0,A
   \                     ??BF_remove_tx_2:
   \   00001D   E8           MOV       A,R0
   \   00001E   602F         JZ        ??BF_remove_tx_3
    158              struct node *node = (struct node*)(cursor);    
   \   000020   AE..         MOV       R6,?V0
   \   000022   AF..         MOV       R7,?V1
    159              node->frame = NULL;
   \   000024   8E82         MOV       DPL,R6
   \   000026   8F83         MOV       DPH,R7
   \   000028   7400         MOV       A,#0x0
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   A3           INC       DPTR
   \   00002C   7400         MOV       A,#0x0
   \   00002E   F0           MOVX      @DPTR,A
    160              list_del(&node->list);    
   \   00002F                ; Setup parameters for call to function list_del
   \   00002F   EE           MOV       A,R6
   \   000030   2402         ADD       A,#0x2
   \   000032   FA           MOV       R2,A
   \   000033   E4           CLR       A
   \   000034   3F           ADDC      A,R7
   \   000035   FB           MOV       R3,A
   \   000036   12....       LCALL     `??list_del::?relay`; Banked call to: list_del
    161              TX_BUFF_FRAME_COUNT--; 
   \   000039   90....       MOV       DPTR,#??TX_BUFF_FRAME_COUNT
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   24FF         ADD       A,#-0x1
   \   00003F   F0           MOVX      @DPTR,A
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   34FF         ADDC      A,#-0x1
   \   000044   F0           MOVX      @DPTR,A
    162            };  
   \   000045   7800         MOV       R0,#0x0
   \   000047   E5..         MOV       A,?V2
   \   000049   A2E0         MOV       C,0xE0 /* A   */.0
   \   00004B   92AF         MOV       0xa8.7,C
   \   00004D   80CE         SJMP      ??BF_remove_tx_2
    163            return true;
   \                     ??BF_remove_tx_3:
   \   00004F   D3           SETB      C
   \                     ??BF_remove_tx_1:
   \   000050   7F03         MOV       R7,#0x3
   \   000052   02....       LJMP      ?BANKED_LEAVE_SP
   \   000055                REQUIRE _A_IEN0
    164          }
    165          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    166          bool BF_remove_rx(void *cursor){
   \                     BF_remove_rx:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   7403         MOV       A,#0x3
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 6
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
    167            if (!cursor)
   \   000009   E5..         MOV       A,?V0
   \   00000B   45..         ORL       A,?V1
   \   00000D   7003         JNZ       ??BF_remove_rx_0
    168              return false;
   \   00000F   C3           CLR       C
   \   000010   803E         SJMP      ??BF_remove_rx_1
    169            ATOMIC_BLOCK_RESTORE{
   \                     ??BF_remove_rx_0:
   \   000012   A2AF         MOV       C,0xa8.7
   \   000014   E4           CLR       A
   \   000015   33           RLC       A
   \   000016   F5..         MOV       ?V2,A
   \   000018                ; Setup parameters for call to function __cli
   \   000018   12....       LCALL     `??__cli::?relay_1`; Banked call to: __cli
   \   00001B   E9           MOV       A,R1
   \   00001C   F8           MOV       R0,A
   \                     ??BF_remove_rx_2:
   \   00001D   E8           MOV       A,R0
   \   00001E   602F         JZ        ??BF_remove_rx_3
    170              struct node *node = (struct node*)(cursor);    
   \   000020   AE..         MOV       R6,?V0
   \   000022   AF..         MOV       R7,?V1
    171              node->frame = NULL;
   \   000024   8E82         MOV       DPL,R6
   \   000026   8F83         MOV       DPH,R7
   \   000028   7400         MOV       A,#0x0
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   A3           INC       DPTR
   \   00002C   7400         MOV       A,#0x0
   \   00002E   F0           MOVX      @DPTR,A
    172              list_del(&node->list);    
   \   00002F                ; Setup parameters for call to function list_del
   \   00002F   EE           MOV       A,R6
   \   000030   2402         ADD       A,#0x2
   \   000032   FA           MOV       R2,A
   \   000033   E4           CLR       A
   \   000034   3F           ADDC      A,R7
   \   000035   FB           MOV       R3,A
   \   000036   12....       LCALL     `??list_del::?relay`; Banked call to: list_del
    173              RX_BUFF_FRAME_COUNT--; 
   \   000039   90....       MOV       DPTR,#??RX_BUFF_FRAME_COUNT
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   24FF         ADD       A,#-0x1
   \   00003F   F0           MOVX      @DPTR,A
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   34FF         ADDC      A,#-0x1
   \   000044   F0           MOVX      @DPTR,A
    174            };  
   \   000045   7800         MOV       R0,#0x0
   \   000047   E5..         MOV       A,?V2
   \   000049   A2E0         MOV       C,0xE0 /* A   */.0
   \   00004B   92AF         MOV       0xa8.7,C
   \   00004D   80CE         SJMP      ??BF_remove_rx_2
    175            return true;
   \                     ??BF_remove_rx_3:
   \   00004F   D3           SETB      C
   \                     ??BF_remove_rx_1:
   \   000050   7F03         MOV       R7,#0x3
   \   000052   02....       LJMP      ?BANKED_LEAVE_SP
   \   000055                REQUIRE _A_IEN0
    176          }
    177          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    178          struct frame* BF_content(void* cursor){
   \                     BF_content:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   EA           MOV       A,R2
   \   000001   F8           MOV       R0,A
   \   000002   EB           MOV       A,R3
   \   000003   F9           MOV       R1,A
    179            if (!cursor)
   \   000004   E8           MOV       A,R0
   \   000005   49           ORL       A,R1
   \   000006   7006         JNZ       ??BF_content_0
    180              return NULL;
   \   000008   7A00         MOV       R2,#0x0
   \   00000A   7B00         MOV       R3,#0x0
   \   00000C   8009         SJMP      ??BF_content_1
    181            struct node *node = (struct node*)(cursor);
   \                     ??BF_content_0:
   \   00000E   8882         MOV       DPL,R0
   \   000010   8983         MOV       DPH,R1
    182            return node->frame;
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FA           MOV       R2,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FB           MOV       R3,A
   \                     ??BF_content_1:
   \   000017   02....       LJMP      ?BRET
    183          }
E:\Neocore\Hardware\STACK_CORE_SRC\coder.c
      1          #include "coder.h"
      2          #include "ioCC2530.h"
      3          #include "string.h"
      4          #include "ustimer.h" // Для профилирования, Отладка
      5          #include "dma.h"
      6          #include "action_manager.h"
      7          #include "model.h"
      8          #include "mem_utils.h"
      9          
     10          static void HW_Init(void);

   \                                 In  segment XDATA_I, align 1, keep-with-next
     11          module_s CODER_MODULE = {ALIAS(HW_Init)};
   \                     CODER_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for CODER_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     12          
     13          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     14          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     15          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     16          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     17          
     18          #define BV(n)                   (1 << (n))
     19          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     20          
     21          // Режимы шифрования
     22          #define AES_MODE_CBC            0x00
     23          #define AES_MODE_CFB            0x10
     24          #define AES_MODE_OFB            0x20
     25          #define AES_MODE_CTR            0x30
     26          #define AES_MODE_ECB            0x40
     27          #define AES_MODE_CBCMAC         0x50
     28          
     29          // Операции 
     30          #define AES_ENCRYPT             0x00
     31          #define AES_DECRYPT             0x02
     32          #define AES_LOAD_KEY            0x04
     33          #define AES_LOAD_IV             0x06
     34          
     35          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     36          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     37          
     38          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     39          
     40          
     41          // Приватные функции
     42          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     43                                                 uint8_t f, uint8_t lm);
     44          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     45          
     46          /**
     47          @brief Локальный буфер для работы режима CCM
     48          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     49           16 длина дополнения нулями
     50          */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     51          static uint8_t buf[128+18+16]; 
   \                     ??buf:
   \   000000                DS 162
   \   0000A2                REQUIRE __INIT_XDATA_Z
     52          
     53          
     54          typedef struct //!< Структура блока B0 для режима CCM
     55          {
     56            struct 
     57            {
     58              uint8_t L:3;
     59              uint8_t M:3;
     60              uint8_t A_Data:1;
     61            } flag;
     62            uint16_t nonce[9];
     63            uint8_t L_M[6];
     64          } __attribute__((packed)) B0_s;
     65          
     66          typedef struct //!< Структура блока A0 для режима CCM
     67          {
     68            struct 
     69            {
     70              uint8_t L:3;
     71            } flag;
     72            uint8_t nonce[11];
     73            uint8_t ctr;
     74          } __attribute__((packed)) A0_s;
     75          
     76          
     77          
     78          /**
     79          @brief Иницилизация модуля
     80          @detail Модуль использует DMA каналы 0 и 1
     81          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     82          void HW_Init(void)
   \                     ??HW_Init_1:
     83          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 84
   \   000000   7454         MOV       A,#0x54
   \   000002   12....       LCALL     ?ALLOC_EXT_STACK8
     84            char STREAM_KEY[16] = DEFAULT_STREAM_KEY;
   \   000005   90....       MOV       DPTR,#`?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,`
   \   000008   C082         PUSH      DPL
   \   00000A   C083         PUSH      DPH
   \   00000C   90FFA9       MOV       DPTR,#-0x57
   \   00000F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000012   AC82         MOV       R4,DPL
   \   000014   AD83         MOV       R5,DPH
   \   000016   D083         POP       DPH
   \   000018   D082         POP       DPL
   \   00001A   7410         MOV       A,#0x10
   \   00001C   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
     85            char STREAM_IV[16] = DEFAULT_STREAM_IV;
   \   00001F   90....       MOV       DPTR,#`?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_1`
   \   000022   C082         PUSH      DPL
   \   000024   C083         PUSH      DPH
   \   000026   90FFB9       MOV       DPTR,#-0x47
   \   000029   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00002C   AC82         MOV       R4,DPL
   \   00002E   AD83         MOV       R5,DPH
   \   000030   D083         POP       DPH
   \   000032   D082         POP       DPL
   \   000034   7410         MOV       A,#0x10
   \   000036   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
     86            char CCM_KEY[16] = DEFAULT_CCM_KEY;
   \   000039   90....       MOV       DPTR,#`?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_2`
   \   00003C   C082         PUSH      DPL
   \   00003E   C083         PUSH      DPH
   \   000040   90FFC9       MOV       DPTR,#-0x37
   \   000043   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000046   AC82         MOV       R4,DPL
   \   000048   AD83         MOV       R5,DPH
   \   00004A   D083         POP       DPH
   \   00004C   D082         POP       DPL
   \   00004E   7410         MOV       A,#0x10
   \   000050   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
     87            char CCM_IV[16] = DEFAULT_CCM_IV;
   \   000053   90....       MOV       DPTR,#`?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_3`
   \   000056   C082         PUSH      DPL
   \   000058   C083         PUSH      DPH
   \   00005A   90FFD9       MOV       DPTR,#-0x27
   \   00005D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000060   AC82         MOV       R4,DPL
   \   000062   AD83         MOV       R5,DPH
   \   000064   D083         POP       DPH
   \   000066   D082         POP       DPL
   \   000068   7410         MOV       A,#0x10
   \   00006A   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
     88            MEMCPY(MODEL.AES.STREAM_KEY, STREAM_KEY, 16);
   \   00006D   90....       MOV       DPTR,#`?<Constant {(char *)MODEL.AES.STREAM_KEY, (cha`
   \   000070   C082         PUSH      DPL
   \   000072   C083         PUSH      DPH
   \   000074   90FFE9       MOV       DPTR,#-0x17
   \   000077   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00007A   AC82         MOV       R4,DPL
   \   00007C   AD83         MOV       R5,DPH
   \   00007E   D083         POP       DPH
   \   000080   D082         POP       DPL
   \   000082   7405         MOV       A,#0x5
   \   000084   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   000087   90FFAB       MOV       DPTR,#-0x55
   \   00008A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00008D   A882         MOV       R0,DPL
   \   00008F   A983         MOV       R1,DPH
   \   000091   90FFED       MOV       DPTR,#-0x13
   \   000094   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000097   E8           MOV       A,R0
   \   000098   F0           MOVX      @DPTR,A
   \   000099   A3           INC       DPTR
   \   00009A   E9           MOV       A,R1
   \   00009B   F0           MOVX      @DPTR,A
   \   00009C                ; Setup parameters for call to function MEM_memcpy
   \   00009C   90FFEB       MOV       DPTR,#-0x15
   \   00009F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A2   AA82         MOV       R2,DPL
   \   0000A4   AB83         MOV       R3,DPH
   \   0000A6   12....       LCALL     `??MEM_memcpy::?relay`; Banked call to: MEM_memcpy
     89            MEMCPY(MODEL.AES.STREAM_IV, STREAM_IV, 16);
   \   0000A9   90....       MOV       DPTR,#`?<Constant {(char *)MODEL.AES.STREAM_IV, (char`
   \   0000AC   C082         PUSH      DPL
   \   0000AE   C083         PUSH      DPH
   \   0000B0   90FFEE       MOV       DPTR,#-0x12
   \   0000B3   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000B6   AC82         MOV       R4,DPL
   \   0000B8   AD83         MOV       R5,DPH
   \   0000BA   D083         POP       DPH
   \   0000BC   D082         POP       DPL
   \   0000BE   7405         MOV       A,#0x5
   \   0000C0   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   0000C3   90FFBB       MOV       DPTR,#-0x45
   \   0000C6   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000C9   A882         MOV       R0,DPL
   \   0000CB   A983         MOV       R1,DPH
   \   0000CD   90FFF2       MOV       DPTR,#-0xe
   \   0000D0   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000D3   E8           MOV       A,R0
   \   0000D4   F0           MOVX      @DPTR,A
   \   0000D5   A3           INC       DPTR
   \   0000D6   E9           MOV       A,R1
   \   0000D7   F0           MOVX      @DPTR,A
   \   0000D8                ; Setup parameters for call to function MEM_memcpy
   \   0000D8   90FFF0       MOV       DPTR,#-0x10
   \   0000DB   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000DE   AA82         MOV       R2,DPL
   \   0000E0   AB83         MOV       R3,DPH
   \   0000E2   12....       LCALL     `??MEM_memcpy::?relay`; Banked call to: MEM_memcpy
     90            MEMCPY(MODEL.AES.CCM_KEY, CCM_KEY, 16);
   \   0000E5   90....       MOV       DPTR,#`?<Constant {(char *)MODEL.AES.CCM_KEY, (char *`
   \   0000E8   C082         PUSH      DPL
   \   0000EA   C083         PUSH      DPH
   \   0000EC   90FFF3       MOV       DPTR,#-0xd
   \   0000EF   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000F2   AC82         MOV       R4,DPL
   \   0000F4   AD83         MOV       R5,DPH
   \   0000F6   D083         POP       DPH
   \   0000F8   D082         POP       DPL
   \   0000FA   7405         MOV       A,#0x5
   \   0000FC   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   0000FF   90FFCB       MOV       DPTR,#-0x35
   \   000102   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000105   A882         MOV       R0,DPL
   \   000107   A983         MOV       R1,DPH
   \   000109   90FFF7       MOV       DPTR,#-0x9
   \   00010C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00010F   E8           MOV       A,R0
   \   000110   F0           MOVX      @DPTR,A
   \   000111   A3           INC       DPTR
   \   000112   E9           MOV       A,R1
   \   000113   F0           MOVX      @DPTR,A
   \   000114                ; Setup parameters for call to function MEM_memcpy
   \   000114   90FFF5       MOV       DPTR,#-0xb
   \   000117   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00011A   AA82         MOV       R2,DPL
   \   00011C   AB83         MOV       R3,DPH
   \   00011E   12....       LCALL     `??MEM_memcpy::?relay`; Banked call to: MEM_memcpy
     91            MEMCPY(MODEL.AES.CCM_IV, CCM_IV, 16);
   \   000121   90....       MOV       DPTR,#`?<Constant {(char *)MODEL.AES.CCM_IV, (char *)`
   \   000124   C082         PUSH      DPL
   \   000126   C083         PUSH      DPH
   \   000128   90FFF8       MOV       DPTR,#-0x8
   \   00012B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00012E   AC82         MOV       R4,DPL
   \   000130   AD83         MOV       R5,DPH
   \   000132   D083         POP       DPH
   \   000134   D082         POP       DPL
   \   000136   7405         MOV       A,#0x5
   \   000138   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   00013B   90FFDB       MOV       DPTR,#-0x25
   \   00013E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000141   A882         MOV       R0,DPL
   \   000143   A983         MOV       R1,DPH
   \   000145   90FFFC       MOV       DPTR,#-0x4
   \   000148   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00014B   E8           MOV       A,R0
   \   00014C   F0           MOVX      @DPTR,A
   \   00014D   A3           INC       DPTR
   \   00014E   E9           MOV       A,R1
   \   00014F   F0           MOVX      @DPTR,A
   \   000150                ; Setup parameters for call to function MEM_memcpy
   \   000150   90FFFA       MOV       DPTR,#-0x6
   \   000153   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000156   AA82         MOV       R2,DPL
   \   000158   AB83         MOV       R3,DPH
   \   00015A   12....       LCALL     `??MEM_memcpy::?relay`; Banked call to: MEM_memcpy
     92            
     93            //DMA_AES_s DMA_CH[0]; //!< DMA на запись будет DMA[0]
     94            //DMA_AES_s DMA_CH[1]; //!< DMA на чтение DMA_CH[1]
     95            
     96            ST_DEF(DMA_CH[0], DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
   \   00015D   90....       MOV       DPTR,#DMA_CH + 2
   \   000160   7470         MOV       A,#0x70
   \   000162   F0           MOVX      @DPTR,A
     97            ST_DEF(DMA_CH[0], DSTADDRL, 0xB1); //  
   \   000163   90....       MOV       DPTR,#DMA_CH + 3
   \   000166   74B1         MOV       A,#-0x4f
   \   000168   F0           MOVX      @DPTR,A
     98            ST_DEF(DMA_CH[0], PRIORITY, 0x00); // Низкий приоритет
   \   000169   90....       MOV       DPTR,#DMA_CH + 7
   \   00016C   E0           MOVX      A,@DPTR
   \   00016D   54FC         ANL       A,#0xfc
   \   00016F   F0           MOVX      @DPTR,A
     99            ST_DEF(DMA_CH[0], M8, 0x00); // Используем 8 бит для счетика длинны
   \   000170   90....       MOV       DPTR,#DMA_CH + 7
   \   000173   E0           MOVX      A,@DPTR
   \   000174   C2E2         CLR       0xE0 /* A   */.2
   \   000176   F0           MOVX      @DPTR,A
    100            ST_DEF(DMA_CH[0], IRQMASK, 0x00); // Запрещаем генерировать перывания
   \   000177   90....       MOV       DPTR,#DMA_CH + 7
   \   00017A   E0           MOVX      A,@DPTR
   \   00017B   C2E3         CLR       0xE0 /* A   */.3
   \   00017D   F0           MOVX      @DPTR,A
    101            ST_DEF(DMA_CH[0], DESTINC, 0x00); // Не увеличиваем адресс назначения
   \   00017E   90....       MOV       DPTR,#DMA_CH + 7
   \   000181   E0           MOVX      A,@DPTR
   \   000182   54CF         ANL       A,#0xcf
   \   000184   F0           MOVX      @DPTR,A
    102            ST_DEF(DMA_CH[0], SRCINC, 0x01); // Увеличиваем адресс источника
   \   000185   90....       MOV       DPTR,#DMA_CH + 7
   \   000188   E0           MOVX      A,@DPTR
   \   000189   543F         ANL       A,#0x3f
   \   00018B   4440         ORL       A,#0x40
   \   00018D   90....       MOV       DPTR,#DMA_CH + 7
   \   000190   F0           MOVX      @DPTR,A
    103            ST_DEF(DMA_CH[0], TRIG, ENC_DW); // Тригер по загрузке
   \   000191   90....       MOV       DPTR,#DMA_CH + 6
   \   000194   E0           MOVX      A,@DPTR
   \   000195   54E0         ANL       A,#0xe0
   \   000197   441D         ORL       A,#0x1d
   \   000199   90....       MOV       DPTR,#DMA_CH + 6
   \   00019C   F0           MOVX      @DPTR,A
    104            ST_DEF(DMA_CH[0], WORDSIZE, 0x00); // Копируем по 1 байту
   \   00019D   90....       MOV       DPTR,#DMA_CH + 6
   \   0001A0   E0           MOVX      A,@DPTR
   \   0001A1   C2E7         CLR       0xE0 /* A   */.7
   \   0001A3   F0           MOVX      @DPTR,A
    105            ST_DEF(DMA_CH[0], TMODE, 0x01); //  Блочное копирование по тригеру
   \   0001A4   90....       MOV       DPTR,#DMA_CH + 6
   \   0001A7   E0           MOVX      A,@DPTR
   \   0001A8   549F         ANL       A,#0x9f
   \   0001AA   4420         ORL       A,#0x20
   \   0001AC   90....       MOV       DPTR,#DMA_CH + 6
   \   0001AF   F0           MOVX      @DPTR,A
    106            ST_DEF(DMA_CH[0], VLEN, 0x00); //  Количество байт определяет поле LEN  
   \   0001B0   90....       MOV       DPTR,#DMA_CH + 4
   \   0001B3   E0           MOVX      A,@DPTR
   \   0001B4   541F         ANL       A,#0x1f
   \   0001B6   F0           MOVX      @DPTR,A
    107            ST_DEF(DMA_CH[0], LENH, 0x00); 
   \   0001B7   90....       MOV       DPTR,#DMA_CH + 4
   \   0001BA   E0           MOVX      A,@DPTR
   \   0001BB   54E0         ANL       A,#0xe0
   \   0001BD   F0           MOVX      @DPTR,A
    108            
    109            ST_DEF(DMA_CH[1], SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
   \   0001BE   90....       MOV       DPTR,#DMA_CH + 8
   \   0001C1   7470         MOV       A,#0x70
   \   0001C3   F0           MOVX      @DPTR,A
    110            ST_DEF(DMA_CH[1], SRCADDRL, 0xB2);  
   \   0001C4   90....       MOV       DPTR,#DMA_CH + 9
   \   0001C7   74B2         MOV       A,#-0x4e
   \   0001C9   F0           MOVX      @DPTR,A
    111            ST_DEF(DMA_CH[1], PRIORITY, 0x00); // Низкий приоритет
   \   0001CA   90....       MOV       DPTR,#DMA_CH + 15
   \   0001CD   E0           MOVX      A,@DPTR
   \   0001CE   54FC         ANL       A,#0xfc
   \   0001D0   F0           MOVX      @DPTR,A
    112            ST_DEF(DMA_CH[1], M8, 0x00); // Используем 8 бит для счетика длинны
   \   0001D1   90....       MOV       DPTR,#DMA_CH + 15
   \   0001D4   E0           MOVX      A,@DPTR
   \   0001D5   C2E2         CLR       0xE0 /* A   */.2
   \   0001D7   F0           MOVX      @DPTR,A
    113            ST_DEF(DMA_CH[1], IRQMASK, 0x00); // Запрещаем генерировать перывания
   \   0001D8   90....       MOV       DPTR,#DMA_CH + 15
   \   0001DB   E0           MOVX      A,@DPTR
   \   0001DC   C2E3         CLR       0xE0 /* A   */.3
   \   0001DE   F0           MOVX      @DPTR,A
    114            ST_DEF(DMA_CH[1], DESTINC, 0x01); // Увеличиваем адресс назначения
   \   0001DF   90....       MOV       DPTR,#DMA_CH + 15
   \   0001E2   E0           MOVX      A,@DPTR
   \   0001E3   54CF         ANL       A,#0xcf
   \   0001E5   4410         ORL       A,#0x10
   \   0001E7   90....       MOV       DPTR,#DMA_CH + 15
   \   0001EA   F0           MOVX      @DPTR,A
    115            ST_DEF(DMA_CH[1], SRCINC, 0x00); // Не увеличиваем адресс источника
   \   0001EB   90....       MOV       DPTR,#DMA_CH + 15
   \   0001EE   E0           MOVX      A,@DPTR
   \   0001EF   543F         ANL       A,#0x3f
   \   0001F1   F0           MOVX      @DPTR,A
    116            ST_DEF(DMA_CH[1], TRIG, ENC_UP); // Тригер по выгрузке
   \   0001F2   90....       MOV       DPTR,#DMA_CH + 14
   \   0001F5   E0           MOVX      A,@DPTR
   \   0001F6   54E0         ANL       A,#0xe0
   \   0001F8   441E         ORL       A,#0x1e
   \   0001FA   90....       MOV       DPTR,#DMA_CH + 14
   \   0001FD   F0           MOVX      @DPTR,A
    117            ST_DEF(DMA_CH[1], WORDSIZE, 0x00); // Копируем по 1 байту
   \   0001FE   90....       MOV       DPTR,#DMA_CH + 14
   \   000201   E0           MOVX      A,@DPTR
   \   000202   C2E7         CLR       0xE0 /* A   */.7
   \   000204   F0           MOVX      @DPTR,A
    118            ST_DEF(DMA_CH[1], TMODE, 0x01); //  Блочное копирование по тригеру
   \   000205   90....       MOV       DPTR,#DMA_CH + 14
   \   000208   E0           MOVX      A,@DPTR
   \   000209   549F         ANL       A,#0x9f
   \   00020B   4420         ORL       A,#0x20
   \   00020D   90....       MOV       DPTR,#DMA_CH + 14
   \   000210   F0           MOVX      @DPTR,A
    119            ST_DEF(DMA_CH[1], VLEN, 0x00); //  Количество байт определяет поле LEN  
   \   000211   90....       MOV       DPTR,#DMA_CH + 12
   \   000214   E0           MOVX      A,@DPTR
   \   000215   541F         ANL       A,#0x1f
   \   000217   F0           MOVX      @DPTR,A
    120            ST_DEF(DMA_CH[1], LENH, 0x00); 
   \   000218   90....       MOV       DPTR,#DMA_CH + 12
   \   00021B   E0           MOVX      A,@DPTR
   \   00021C   54E0         ANL       A,#0xe0
   \   00021E   F0           MOVX      @DPTR,A
    121          }
   \   00021F   74AC         MOV       A,#-0x54
   \   000221   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000224   02....       LJMP      ?BRET

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {(char *)MODEL.AES.STREAM_KEY, (cha`:
   \   000000   ....         DW MODEL + 13H
   \   000002   0000         DW 0H
   \   000004   10           DB 16

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {(char *)MODEL.AES.STREAM_IV, (char`:
   \   000000   ....         DW MODEL + 23H
   \   000002   0000         DW 0H
   \   000004   10           DB 16

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {(char *)MODEL.AES.CCM_KEY, (char *`:
   \   000000   ....         DW MODEL + 33H
   \   000002   0000         DW 0H
   \   000004   10           DB 16

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {(char *)MODEL.AES.CCM_IV, (char *)`:
   \   000000   ....         DW MODEL + 43H
   \   000002   0000         DW 0H
   \   000004   10           DB 16
    122          
    123          /**
    124          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    125          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    126          @param[in] src Указатель на данные подлежащии шифрованию
    127          @param[in] dst Указтель куда будут помещены зашифрованные данные
    128          @param[in] key Указатье на ключ. 16 байт
    129          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    130          @param[in] len Длинна данных
    131          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    132          void AES_StreamCoder(bool enc_mode, char *src, char *dst, uint8_t len)
   \                     AES_StreamCoder:
    133          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 24
   \   000005   7418         MOV       A,#0x18
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   90FFF7       MOV       DPTR,#-0x9
   \   00000D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   90FFF9       MOV       DPTR,#-0x7
   \   000018   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00001B   EC           MOV       A,R4
   \   00001C   F0           MOVX      @DPTR,A
   \   00001D   A3           INC       DPTR
   \   00001E   ED           MOV       A,R5
   \   00001F   F0           MOVX      @DPTR,A
   \   000020   A2F0         MOV       C,B.0
   \   000022   92..         MOV       ?VB.0,C
   \   000024   89..         MOV       ?V4,R1
    134            // Установим метод кодироваения
    135            AES_SET_MODE(STREAM_ENC_MODE);
   \   000026   53B38F       ANL       0xb3,#0x8f
   \   000029   43B320       ORL       0xb3,#0x20
    136            uint8_t *key = (uint8_t*)MODEL.AES.STREAM_KEY;  
   \   00002C   90FFFB       MOV       DPTR,#-0x5
   \   00002F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000032   74..         MOV       A,#(MODEL + 19) & 0xff
   \   000034   F0           MOVX      @DPTR,A
   \   000035   A3           INC       DPTR
   \   000036   74..         MOV       A,#((MODEL + 19) >> 8) & 0xff
   \   000038   F0           MOVX      @DPTR,A
    137            uint8_t *iv = (uint8_t*)MODEL.AES.STREAM_IV; 
   \   000039   90FFFD       MOV       DPTR,#-0x3
   \   00003C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00003F   74..         MOV       A,#(MODEL + 35) & 0xff
   \   000041   F0           MOVX      @DPTR,A
   \   000042   A3           INC       DPTR
   \   000043   74..         MOV       A,#((MODEL + 35) >> 8) & 0xff
   \   000045   F0           MOVX      @DPTR,A
    138            // Загружаем ключ
    139            AES_SET_OPERATION(AES_LOAD_KEY);
   \   000046   E5B3         MOV       A,0xb3
   \   000048   54F8         ANL       A,#0xf8
   \   00004A   4404         ORL       A,#0x4
   \   00004C   F5B3         MOV       0xb3,A
    140            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
   \   00004E   90FFFB       MOV       DPTR,#-0x5
   \   000051   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000054   E0           MOVX      A,@DPTR
   \   000055   F8           MOV       R0,A
   \   000056   A3           INC       DPTR
   \   000057   E0           MOVX      A,@DPTR
   \   000058   F9           MOV       R1,A
   \   000059   E8           MOV       A,R0
   \   00005A   90....       MOV       DPTR,#DMA_CH + 1
   \   00005D   F0           MOVX      @DPTR,A
    141            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
   \   00005E   90FFFB       MOV       DPTR,#-0x5
   \   000061   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000064   E0           MOVX      A,@DPTR
   \   000065   F8           MOV       R0,A
   \   000066   A3           INC       DPTR
   \   000067   E0           MOVX      A,@DPTR
   \   000068   F9           MOV       R1,A
   \   000069   E4           CLR       A
   \   00006A   C9           XCH       A,R1
   \   00006B   F8           MOV       R0,A
   \   00006C   E8           MOV       A,R0
   \   00006D   90....       MOV       DPTR,#DMA_CH
   \   000070   F0           MOVX      @DPTR,A
    142            ST_DEF(DMA_CH[0], LENL, 16);
   \   000071   90....       MOV       DPTR,#DMA_CH + 5
   \   000074   7410         MOV       A,#0x10
   \   000076   F0           MOVX      @DPTR,A
    143            DMAARM |= 0x01;
   \   000077   43D601       ORL       0xd6,#0x1
    144            while(!AES_RDY());
   \                     ??AES_StreamCoder_0:
   \   00007A   E5B3         MOV       A,0xb3
   \   00007C   A2E3         MOV       C,0xE0 /* A   */.3
   \   00007E   50FA         JNC       ??AES_StreamCoder_0
    145            AES_START();
   \   000080   43B301       ORL       0xb3,#0x1
    146            while (DMAARM&0x01);
   \                     ??AES_StreamCoder_1:
   \   000083   E5D6         MOV       A,0xd6
   \   000085   A2E0         MOV       C,0xE0 /* A   */.0
   \   000087   40FA         JC        ??AES_StreamCoder_1
    147          
    148            // Загружаем IV
    149            AES_SET_OPERATION(AES_LOAD_IV);
   \   000089   E5B3         MOV       A,0xb3
   \   00008B   54F8         ANL       A,#0xf8
   \   00008D   4406         ORL       A,#0x6
   \   00008F   F5B3         MOV       0xb3,A
    150            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
   \   000091   90FFFD       MOV       DPTR,#-0x3
   \   000094   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000097   E0           MOVX      A,@DPTR
   \   000098   F8           MOV       R0,A
   \   000099   A3           INC       DPTR
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   F9           MOV       R1,A
   \   00009C   E8           MOV       A,R0
   \   00009D   90....       MOV       DPTR,#DMA_CH + 1
   \   0000A0   F0           MOVX      @DPTR,A
    151            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
   \   0000A1   90FFFD       MOV       DPTR,#-0x3
   \   0000A4   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A7   E0           MOVX      A,@DPTR
   \   0000A8   F8           MOV       R0,A
   \   0000A9   A3           INC       DPTR
   \   0000AA   E0           MOVX      A,@DPTR
   \   0000AB   F9           MOV       R1,A
   \   0000AC   E4           CLR       A
   \   0000AD   C9           XCH       A,R1
   \   0000AE   F8           MOV       R0,A
   \   0000AF   E8           MOV       A,R0
   \   0000B0   90....       MOV       DPTR,#DMA_CH
   \   0000B3   F0           MOVX      @DPTR,A
    152            ST_DEF(DMA_CH[0], LENL, 16);
   \   0000B4   90....       MOV       DPTR,#DMA_CH + 5
   \   0000B7   7410         MOV       A,#0x10
   \   0000B9   F0           MOVX      @DPTR,A
    153            DMAARM |= 0x01;
   \   0000BA   43D601       ORL       0xd6,#0x1
    154            while(!AES_RDY());
   \                     ??AES_StreamCoder_2:
   \   0000BD   E5B3         MOV       A,0xb3
   \   0000BF   A2E3         MOV       C,0xE0 /* A   */.3
   \   0000C1   50FA         JNC       ??AES_StreamCoder_2
    155            AES_START();
   \   0000C3   43B301       ORL       0xb3,#0x1
    156            while (DMAARM&0x01);
   \                     ??AES_StreamCoder_3:
   \   0000C6   E5D6         MOV       A,0xd6
   \   0000C8   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000CA   40FA         JC        ??AES_StreamCoder_3
    157          
    158            // Установим необходимую операцию AES
    159            if (enc_mode) 
   \   0000CC   A2..         MOV       C,?VB.0
   \   0000CE   5005         JNC       ??AES_StreamCoder_4
    160              AES_SET_OPERATION(AES_ENCRYPT)
   \   0000D0   53B3F8       ANL       0xb3,#0xf8
   \   0000D3   8008         SJMP      ??AES_StreamCoder_5
    161            else 
    162              AES_SET_OPERATION(AES_DECRYPT)
   \                     ??AES_StreamCoder_4:
   \   0000D5   E5B3         MOV       A,0xb3
   \   0000D7   54F8         ANL       A,#0xf8
   \   0000D9   4402         ORL       A,#0x2
   \   0000DB   F5B3         MOV       0xb3,A
    163            
    164            switch(STREAM_ENC_MODE) 
    165            {
    166            case AES_MODE_ECB: // ECB, CBC не реализованы
    167            case AES_MODE_CBC:
    168              break;
    169            case AES_MODE_CFB:
    170            case AES_MODE_OFB:
    171            case AES_MODE_CTR:
    172              {
    173                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    174                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
   \                     ??AES_StreamCoder_5:
   \   0000DD   75F010       MOV       B,#0x10
   \   0000E0   E5..         MOV       A,?V4
   \   0000E2   84           DIV       AB
   \   0000E3   F5..         MOV       ?V3,A
    175                uint8_t ptr, sub_ptr; // Смещение
    176                char *download, *upload;
    177                
    178                // Для этих типов шифрования длина блоков по 4 байта
    179                ST_DEF(DMA_CH[0], LENL, 4);
   \   0000E5   90....       MOV       DPTR,#DMA_CH + 5
   \   0000E8   7404         MOV       A,#0x4
   \   0000EA   F0           MOVX      @DPTR,A
    180                ST_DEF(DMA_CH[1], LENL, 4);
   \   0000EB   90....       MOV       DPTR,#DMA_CH + 13
   \   0000EE   7404         MOV       A,#0x4
   \   0000F0   F0           MOVX      @DPTR,A
    181                
    182                // Шифруем все целые блоки
    183                for (uint8_t block = 0; block < nbrBlocks; block ++)
   \   0000F1   7A00         MOV       R2,#0x0
   \                     ??AES_StreamCoder_6:
   \   0000F3   EA           MOV       A,R2
   \   0000F4   C3           CLR       C
   \   0000F5   95..         SUBB      A,?V3
   \   0000F7   507F         JNC       ??AES_StreamCoder_7
    184                {
    185                  ptr = 16 * block;
   \   0000F9   75F010       MOV       B,#0x10
   \   0000FC   EA           MOV       A,R2
   \   0000FD   A4           MUL       AB
   \   0000FE   FE           MOV       R6,A
    186                  while(!AES_RDY());
   \                     ??AES_StreamCoder_8:
   \   0000FF   E5B3         MOV       A,0xb3
   \   000101   A2E3         MOV       C,0xE0 /* A   */.3
   \   000103   50FA         JNC       ??AES_StreamCoder_8
    187                  AES_START();
   \   000105   43B301       ORL       0xb3,#0x1
    188                  for (uint8_t j = 0; j < 4; j++)
   \   000108   7B00         MOV       R3,#0x0
   \                     ??AES_StreamCoder_9:
   \   00010A   EB           MOV       A,R3
   \   00010B   C3           CLR       C
   \   00010C   9404         SUBB      A,#0x4
   \   00010E   5064         JNC       ??AES_StreamCoder_10
    189                  {
    190                    sub_ptr = ptr + 4*j;
   \   000110   75F004       MOV       B,#0x4
   \   000113   EB           MOV       A,R3
   \   000114   A4           MUL       AB
   \   000115   2E           ADD       A,R6
   \   000116   FF           MOV       R7,A
    191                    download = &src[sub_ptr];
   \   000117   EF           MOV       A,R7
   \   000118   F8           MOV       R0,A
   \   000119   7900         MOV       R1,#0x0
   \   00011B   90FFF7       MOV       DPTR,#-0x9
   \   00011E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000121   E0           MOVX      A,@DPTR
   \   000122   28           ADD       A,R0
   \   000123   F8           MOV       R0,A
   \   000124   A3           INC       DPTR
   \   000125   E0           MOVX      A,@DPTR
   \   000126   39           ADDC      A,R1
   \   000127   F9           MOV       R1,A
   \   000128   88..         MOV       ?V0,R0
   \   00012A   89..         MOV       ?V1,R1
    192                    upload = &dst[sub_ptr];
   \   00012C   EF           MOV       A,R7
   \   00012D   F8           MOV       R0,A
   \   00012E   7900         MOV       R1,#0x0
   \   000130   90FFF9       MOV       DPTR,#-0x7
   \   000133   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000136   E0           MOVX      A,@DPTR
   \   000137   28           ADD       A,R0
   \   000138   F8           MOV       R0,A
   \   000139   A3           INC       DPTR
   \   00013A   E0           MOVX      A,@DPTR
   \   00013B   39           ADDC      A,R1
   \   00013C   F9           MOV       R1,A
   \   00013D   88..         MOV       ?V6,R0
   \   00013F   89..         MOV       ?V7,R1
    193                    // Указываем адресс DMA откуда читать данные
    194                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
   \   000141   E5..         MOV       A,?V0
   \   000143   90....       MOV       DPTR,#DMA_CH + 1
   \   000146   F0           MOVX      @DPTR,A
    195                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
   \   000147   A8..         MOV       R0,?V0
   \   000149   A9..         MOV       R1,?V1
   \   00014B   E4           CLR       A
   \   00014C   C9           XCH       A,R1
   \   00014D   F8           MOV       R0,A
   \   00014E   E8           MOV       A,R0
   \   00014F   90....       MOV       DPTR,#DMA_CH
   \   000152   F0           MOVX      @DPTR,A
    196                    // Указываем адрес DMA куда записывать данные          
    197                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
   \   000153   E5..         MOV       A,?V6
   \   000155   90....       MOV       DPTR,#DMA_CH + 11
   \   000158   F0           MOVX      @DPTR,A
    198                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
   \   000159   A8..         MOV       R0,?V6
   \   00015B   A9..         MOV       R1,?V7
   \   00015D   E4           CLR       A
   \   00015E   C9           XCH       A,R1
   \   00015F   F8           MOV       R0,A
   \   000160   E8           MOV       A,R0
   \   000161   90....       MOV       DPTR,#DMA_CH + 10
   \   000164   F0           MOVX      @DPTR,A
    199                    // Активируем DMA
    200                    DMAARM |= 0x03;  
   \   000165   43D603       ORL       0xd6,#0x3
    201                    DMAREQ |= 0x01;
   \   000168   43D701       ORL       0xd7,#0x1
    202                    while (DMAARM&0x03);          
   \                     ??AES_StreamCoder_11:
   \   00016B   E5D6         MOV       A,0xd6
   \   00016D   5403         ANL       A,#0x3
   \   00016F   70FA         JNZ       ??AES_StreamCoder_11
    203                  }
   \   000171   0B           INC       R3
   \   000172   8096         SJMP      ??AES_StreamCoder_9
    204                }     
   \                     ??AES_StreamCoder_10:
   \   000174   0A           INC       R2
   \   000175   02....       LJMP      ??AES_StreamCoder_6 & 0xFFFF
    205                // Шифруем последний блок
    206                uint8_t block_len = len % 16; // Размер последнего блока
   \                     ??AES_StreamCoder_7:
   \   000178   E5..         MOV       A,?V4
   \   00017A   75F010       MOV       B,#0x10
   \   00017D   84           DIV       AB
   \   00017E   E5F0         MOV       A,B
   \   000180   F5..         MOV       ?V2,A
    207                
    208                // Завершаем работу если блок пустой
    209                if (!block_len)
   \   000182   E5..         MOV       A,?V2
   \   000184   7003         JNZ       $+5
   \   000186   02....       LJMP      ??AES_StreamCoder_12 & 0xFFFF
    210                  return;
    211                
    212                char padding_block[16]; // Блок заполненый нулями
    213                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
   \   000189   75F010       MOV       B,#0x10
   \   00018C   E5..         MOV       A,?V3
   \   00018E   A4           MUL       AB
   \   00018F   FE           MOV       R6,A
    214                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
   \   000190                ; Setup parameters for call to function memset
   \   000190   7410         MOV       A,#0x10
   \   000192   C0E0         PUSH      A
   \   000194   7400         MOV       A,#0x0
   \   000196   C0E0         PUSH      A
   \   000198   7C00         MOV       R4,#0x0
   \   00019A   7D00         MOV       R5,#0x0
   \   00019C   90FFE5       MOV       DPTR,#-0x1b
   \   00019F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001A2   AA82         MOV       R2,DPL
   \   0001A4   AB83         MOV       R3,DPH
   \   0001A6   12....       LCALL     `??memset::?relay`; Banked call to: memset
   \   0001A9   D0E0         POP       A
   \   0001AB   D0E0         POP       A
    215                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
   \   0001AD                ; Setup parameters for call to function memcpy
   \   0001AD   E5..         MOV       A,?V2
   \   0001AF   F582         MOV       DPL,A
   \   0001B1   758300       MOV       DPH,#0x0
   \   0001B4   C082         PUSH      DPL
   \   0001B6   C083         PUSH      DPH
   \   0001B8   EE           MOV       A,R6
   \   0001B9   F8           MOV       R0,A
   \   0001BA   7900         MOV       R1,#0x0
   \   0001BC   90FFF5       MOV       DPTR,#-0xb
   \   0001BF   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001C2   E0           MOVX      A,@DPTR
   \   0001C3   28           ADD       A,R0
   \   0001C4   FC           MOV       R4,A
   \   0001C5   A3           INC       DPTR
   \   0001C6   E0           MOVX      A,@DPTR
   \   0001C7   39           ADDC      A,R1
   \   0001C8   FD           MOV       R5,A
   \   0001C9   90FFE5       MOV       DPTR,#-0x1b
   \   0001CC   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001CF   AA82         MOV       R2,DPL
   \   0001D1   AB83         MOV       R3,DPH
   \   0001D3   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   0001D6   D0E0         POP       A
   \   0001D8   D0E0         POP       A
    216                
    217                while(!AES_RDY());
   \                     ??AES_StreamCoder_13:
   \   0001DA   E5B3         MOV       A,0xb3
   \   0001DC   A2E3         MOV       C,0xE0 /* A   */.3
   \   0001DE   50FA         JNC       ??AES_StreamCoder_13
    218                AES_START();
   \   0001E0   43B301       ORL       0xb3,#0x1
    219                for (uint8_t j = 0; j < 4; j++)
   \   0001E3   7A00         MOV       R2,#0x0
   \                     ??AES_StreamCoder_14:
   \   0001E5   EA           MOV       A,R2
   \   0001E6   C3           CLR       C
   \   0001E7   9404         SUBB      A,#0x4
   \   0001E9   504F         JNC       ??AES_StreamCoder_15
    220                  {
    221                    sub_ptr = 4*j;
   \   0001EB   75F004       MOV       B,#0x4
   \   0001EE   EA           MOV       A,R2
   \   0001EF   A4           MUL       AB
   \   0001F0   FF           MOV       R7,A
    222                    download = &padding_block[sub_ptr];
   \   0001F1   EF           MOV       A,R7
   \   0001F2   F8           MOV       R0,A
   \   0001F3   7900         MOV       R1,#0x0
   \   0001F5   90FFE7       MOV       DPTR,#-0x19
   \   0001F8   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001FB   E582         MOV       A,DPL
   \   0001FD   28           ADD       A,R0
   \   0001FE   F8           MOV       R0,A
   \   0001FF   E583         MOV       A,DPH
   \   000201   39           ADDC      A,R1
   \   000202   F9           MOV       R1,A
   \   000203   88..         MOV       ?V0,R0
   \   000205   89..         MOV       ?V1,R1
    223                    // Указываем адресс DMA откуда читать данные
    224                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
   \   000207   E5..         MOV       A,?V0
   \   000209   90....       MOV       DPTR,#DMA_CH + 1
   \   00020C   F0           MOVX      @DPTR,A
    225                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
   \   00020D   A8..         MOV       R0,?V0
   \   00020F   A9..         MOV       R1,?V1
   \   000211   E4           CLR       A
   \   000212   C9           XCH       A,R1
   \   000213   F8           MOV       R0,A
   \   000214   E8           MOV       A,R0
   \   000215   90....       MOV       DPTR,#DMA_CH
   \   000218   F0           MOVX      @DPTR,A
    226                    // Указываем аддрес DMA куда записывать данные          
    227                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
   \   000219   E5..         MOV       A,?V0
   \   00021B   90....       MOV       DPTR,#DMA_CH + 11
   \   00021E   F0           MOVX      @DPTR,A
    228                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
   \   00021F   A8..         MOV       R0,?V0
   \   000221   A9..         MOV       R1,?V1
   \   000223   E4           CLR       A
   \   000224   C9           XCH       A,R1
   \   000225   F8           MOV       R0,A
   \   000226   E8           MOV       A,R0
   \   000227   90....       MOV       DPTR,#DMA_CH + 10
   \   00022A   F0           MOVX      @DPTR,A
    229                    // Активируем DMA
    230                    DMAARM |= 0x03;  
   \   00022B   43D603       ORL       0xd6,#0x3
    231                    DMAREQ |= 0x01;
   \   00022E   43D701       ORL       0xd7,#0x1
    232                    while (DMAARM&0x03);
   \                     ??AES_StreamCoder_16:
   \   000231   E5D6         MOV       A,0xd6
   \   000233   5403         ANL       A,#0x3
   \   000235   70FA         JNZ       ??AES_StreamCoder_16
    233                  }
   \   000237   0A           INC       R2
   \   000238   80AB         SJMP      ??AES_StreamCoder_14
    234                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
   \                     ??AES_StreamCoder_15:
   \   00023A                ; Setup parameters for call to function memcpy
   \   00023A   E5..         MOV       A,?V2
   \   00023C   F582         MOV       DPL,A
   \   00023E   758300       MOV       DPH,#0x0
   \   000241   C082         PUSH      DPL
   \   000243   C083         PUSH      DPH
   \   000245   90FFE5       MOV       DPTR,#-0x1b
   \   000248   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00024B   AC82         MOV       R4,DPL
   \   00024D   AD83         MOV       R5,DPH
   \   00024F   EE           MOV       A,R6
   \   000250   F8           MOV       R0,A
   \   000251   7900         MOV       R1,#0x0
   \   000253   90FFF7       MOV       DPTR,#-0x9
   \   000256   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000259   E0           MOVX      A,@DPTR
   \   00025A   28           ADD       A,R0
   \   00025B   FA           MOV       R2,A
   \   00025C   A3           INC       DPTR
   \   00025D   E0           MOVX      A,@DPTR
   \   00025E   39           ADDC      A,R1
   \   00025F   FB           MOV       R3,A
   \   000260   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   000263   D0E0         POP       A
   \   000265   D0E0         POP       A
    235                
    236              } //CASE
    237              
    238              break;
    239            } 
    240          }
   \                     ??AES_StreamCoder_12:
   \   000267   74E8         MOV       A,#-0x18
   \   000269   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00026C   7F08         MOV       R7,#0x8
   \   00026E   02....       LJMP      ?BANKED_LEAVE_SP
   \   000271                REQUIRE ENCCS
   \   000271                REQUIRE DMAARM
   \   000271                REQUIRE DMAREQ
    241          
    242          /**
    243          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    244          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    245          @param[in] src Указатель на данные подлежащии шифрованию
    246          @param[in] dst Указтель куда будут помещены зашифрованные данные
    247          @param[in] key Указатье на ключ. 16 байт
    248          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    249          @param[in] len Длинна данных
    250          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    251          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
   \                     ??CTR_enc_decrypt:
    252                                   uint8_t *iv, uint8_t len)
    253          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 20
   \   000005   7414         MOV       A,#0x14
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   90FFFB       MOV       DPTR,#-0x5
   \   00000D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   90FFFD       MOV       DPTR,#-0x3
   \   000018   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00001B   EC           MOV       A,R4
   \   00001C   F0           MOVX      @DPTR,A
   \   00001D   A3           INC       DPTR
   \   00001E   ED           MOV       A,R5
   \   00001F   F0           MOVX      @DPTR,A
   \   000020   A2F0         MOV       C,B.0
   \   000022   92..         MOV       ?VB.0,C
   \   000024   89..         MOV       ?V4,R1
    254            // Установим метод кодироваения
    255            AES_SET_MODE(AES_MODE_CTR);
   \   000026   53B38F       ANL       0xb3,#0x8f
   \   000029   43B330       ORL       0xb3,#0x30
    256            
    257            // Загружаем ключ
    258            AES_SET_OPERATION(AES_LOAD_KEY);
   \   00002C   E5B3         MOV       A,0xb3
   \   00002E   54F8         ANL       A,#0xf8
   \   000030   4404         ORL       A,#0x4
   \   000032   F5B3         MOV       0xb3,A
    259            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
   \   000034   90FFDB       MOV       DPTR,#-0x25
   \   000037   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   F8           MOV       R0,A
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   F9           MOV       R1,A
   \   00003F   E8           MOV       A,R0
   \   000040   90....       MOV       DPTR,#DMA_CH + 1
   \   000043   F0           MOVX      @DPTR,A
    260            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
   \   000044   90FFDB       MOV       DPTR,#-0x25
   \   000047   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00004A   E0           MOVX      A,@DPTR
   \   00004B   F8           MOV       R0,A
   \   00004C   A3           INC       DPTR
   \   00004D   E0           MOVX      A,@DPTR
   \   00004E   F9           MOV       R1,A
   \   00004F   E4           CLR       A
   \   000050   C9           XCH       A,R1
   \   000051   F8           MOV       R0,A
   \   000052   E8           MOV       A,R0
   \   000053   90....       MOV       DPTR,#DMA_CH
   \   000056   F0           MOVX      @DPTR,A
    261            ST_DEF(DMA_CH[0], LENL, 16);
   \   000057   90....       MOV       DPTR,#DMA_CH + 5
   \   00005A   7410         MOV       A,#0x10
   \   00005C   F0           MOVX      @DPTR,A
    262            DMAARM |= 0x01;
   \   00005D   43D601       ORL       0xd6,#0x1
    263            while(!AES_RDY());
   \                     ??CTR_enc_decrypt_1:
   \   000060   E5B3         MOV       A,0xb3
   \   000062   A2E3         MOV       C,0xE0 /* A   */.3
   \   000064   50FA         JNC       ??CTR_enc_decrypt_1
    264            AES_START();
   \   000066   43B301       ORL       0xb3,#0x1
    265            while (DMAARM&0x01);
   \                     ??CTR_enc_decrypt_2:
   \   000069   E5D6         MOV       A,0xd6
   \   00006B   A2E0         MOV       C,0xE0 /* A   */.0
   \   00006D   40FA         JC        ??CTR_enc_decrypt_2
    266          
    267            // Загружаем IV
    268            AES_SET_OPERATION(AES_LOAD_IV);
   \   00006F   E5B3         MOV       A,0xb3
   \   000071   54F8         ANL       A,#0xf8
   \   000073   4406         ORL       A,#0x6
   \   000075   F5B3         MOV       0xb3,A
    269            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
   \   000077   90FFD9       MOV       DPTR,#-0x27
   \   00007A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   F8           MOV       R0,A
   \   00007F   A3           INC       DPTR
   \   000080   E0           MOVX      A,@DPTR
   \   000081   F9           MOV       R1,A
   \   000082   E8           MOV       A,R0
   \   000083   90....       MOV       DPTR,#DMA_CH + 1
   \   000086   F0           MOVX      @DPTR,A
    270            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
   \   000087   90FFD9       MOV       DPTR,#-0x27
   \   00008A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00008D   E0           MOVX      A,@DPTR
   \   00008E   F8           MOV       R0,A
   \   00008F   A3           INC       DPTR
   \   000090   E0           MOVX      A,@DPTR
   \   000091   F9           MOV       R1,A
   \   000092   E4           CLR       A
   \   000093   C9           XCH       A,R1
   \   000094   F8           MOV       R0,A
   \   000095   E8           MOV       A,R0
   \   000096   90....       MOV       DPTR,#DMA_CH
   \   000099   F0           MOVX      @DPTR,A
    271            ST_DEF(DMA_CH[0], LENL, 16);
   \   00009A   90....       MOV       DPTR,#DMA_CH + 5
   \   00009D   7410         MOV       A,#0x10
   \   00009F   F0           MOVX      @DPTR,A
    272            DMAARM |= 0x01;
   \   0000A0   43D601       ORL       0xd6,#0x1
    273            while(!AES_RDY());
   \                     ??CTR_enc_decrypt_3:
   \   0000A3   E5B3         MOV       A,0xb3
   \   0000A5   A2E3         MOV       C,0xE0 /* A   */.3
   \   0000A7   50FA         JNC       ??CTR_enc_decrypt_3
    274            AES_START();
   \   0000A9   43B301       ORL       0xb3,#0x1
    275            while (DMAARM&0x01);
   \                     ??CTR_enc_decrypt_4:
   \   0000AC   E5D6         MOV       A,0xd6
   \   0000AE   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000B0   40FA         JC        ??CTR_enc_decrypt_4
    276          
    277            // Установим необходимую операцию AES
    278            if (enc_mode) 
   \   0000B2   A2..         MOV       C,?VB.0
   \   0000B4   5005         JNC       ??CTR_enc_decrypt_5
    279              AES_SET_OPERATION(AES_ENCRYPT)
   \   0000B6   53B3F8       ANL       0xb3,#0xf8
   \   0000B9   8008         SJMP      ??CTR_enc_decrypt_6
    280            else 
    281              AES_SET_OPERATION(AES_DECRYPT)
   \                     ??CTR_enc_decrypt_5:
   \   0000BB   E5B3         MOV       A,0xb3
   \   0000BD   54F8         ANL       A,#0xf8
   \   0000BF   4402         ORL       A,#0x2
   \   0000C1   F5B3         MOV       0xb3,A
    282            
    283            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    284            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
   \                     ??CTR_enc_decrypt_6:
   \   0000C3   75F010       MOV       B,#0x10
   \   0000C6   E5..         MOV       A,?V4
   \   0000C8   84           DIV       AB
   \   0000C9   F5..         MOV       ?V3,A
    285            uint8_t ptr, sub_ptr; // Смещение
    286            uint8_t *download, *upload;
    287                
    288            // Для этих типов шифрования длина блоков по 4 байта
    289            ST_DEF(DMA_CH[0], LENL, 4);
   \   0000CB   90....       MOV       DPTR,#DMA_CH + 5
   \   0000CE   7404         MOV       A,#0x4
   \   0000D0   F0           MOVX      @DPTR,A
    290            ST_DEF(DMA_CH[1], LENL, 4);
   \   0000D1   90....       MOV       DPTR,#DMA_CH + 13
   \   0000D4   7404         MOV       A,#0x4
   \   0000D6   F0           MOVX      @DPTR,A
    291                
    292            // Шифруем все целые блоки
    293            for (uint8_t block = 0; block < nbrBlocks; block ++)
   \   0000D7   7A00         MOV       R2,#0x0
   \                     ??CTR_enc_decrypt_7:
   \   0000D9   EA           MOV       A,R2
   \   0000DA   C3           CLR       C
   \   0000DB   95..         SUBB      A,?V3
   \   0000DD   507F         JNC       ??CTR_enc_decrypt_8
    294              {
    295                ptr = 16 * block;
   \   0000DF   75F010       MOV       B,#0x10
   \   0000E2   EA           MOV       A,R2
   \   0000E3   A4           MUL       AB
   \   0000E4   FE           MOV       R6,A
    296                while(!AES_RDY());
   \                     ??CTR_enc_decrypt_9:
   \   0000E5   E5B3         MOV       A,0xb3
   \   0000E7   A2E3         MOV       C,0xE0 /* A   */.3
   \   0000E9   50FA         JNC       ??CTR_enc_decrypt_9
    297                AES_START();
   \   0000EB   43B301       ORL       0xb3,#0x1
    298                for (uint8_t j = 0; j < 4; j++)
   \   0000EE   7B00         MOV       R3,#0x0
   \                     ??CTR_enc_decrypt_10:
   \   0000F0   EB           MOV       A,R3
   \   0000F1   C3           CLR       C
   \   0000F2   9404         SUBB      A,#0x4
   \   0000F4   5064         JNC       ??CTR_enc_decrypt_11
    299                  {
    300                    sub_ptr = ptr + 4*j;
   \   0000F6   75F004       MOV       B,#0x4
   \   0000F9   EB           MOV       A,R3
   \   0000FA   A4           MUL       AB
   \   0000FB   2E           ADD       A,R6
   \   0000FC   FF           MOV       R7,A
    301                    download = &src[sub_ptr];
   \   0000FD   EF           MOV       A,R7
   \   0000FE   F8           MOV       R0,A
   \   0000FF   7900         MOV       R1,#0x0
   \   000101   90FFFB       MOV       DPTR,#-0x5
   \   000104   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000107   E0           MOVX      A,@DPTR
   \   000108   28           ADD       A,R0
   \   000109   F8           MOV       R0,A
   \   00010A   A3           INC       DPTR
   \   00010B   E0           MOVX      A,@DPTR
   \   00010C   39           ADDC      A,R1
   \   00010D   F9           MOV       R1,A
   \   00010E   88..         MOV       ?V0,R0
   \   000110   89..         MOV       ?V1,R1
    302                    upload = &dst[sub_ptr];
   \   000112   EF           MOV       A,R7
   \   000113   F8           MOV       R0,A
   \   000114   7900         MOV       R1,#0x0
   \   000116   90FFFD       MOV       DPTR,#-0x3
   \   000119   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00011C   E0           MOVX      A,@DPTR
   \   00011D   28           ADD       A,R0
   \   00011E   F8           MOV       R0,A
   \   00011F   A3           INC       DPTR
   \   000120   E0           MOVX      A,@DPTR
   \   000121   39           ADDC      A,R1
   \   000122   F9           MOV       R1,A
   \   000123   88..         MOV       ?V6,R0
   \   000125   89..         MOV       ?V7,R1
    303                    // Указываем адресс DMA откуда читать данные
    304                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
   \   000127   E5..         MOV       A,?V0
   \   000129   90....       MOV       DPTR,#DMA_CH + 1
   \   00012C   F0           MOVX      @DPTR,A
    305                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
   \   00012D   A8..         MOV       R0,?V0
   \   00012F   A9..         MOV       R1,?V1
   \   000131   E4           CLR       A
   \   000132   C9           XCH       A,R1
   \   000133   F8           MOV       R0,A
   \   000134   E8           MOV       A,R0
   \   000135   90....       MOV       DPTR,#DMA_CH
   \   000138   F0           MOVX      @DPTR,A
    306                    // Указываем адрес DMA куда записывать данные          
    307                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
   \   000139   E5..         MOV       A,?V6
   \   00013B   90....       MOV       DPTR,#DMA_CH + 11
   \   00013E   F0           MOVX      @DPTR,A
    308                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
   \   00013F   A8..         MOV       R0,?V6
   \   000141   A9..         MOV       R1,?V7
   \   000143   E4           CLR       A
   \   000144   C9           XCH       A,R1
   \   000145   F8           MOV       R0,A
   \   000146   E8           MOV       A,R0
   \   000147   90....       MOV       DPTR,#DMA_CH + 10
   \   00014A   F0           MOVX      @DPTR,A
    309                    // Активируем DMA
    310                    DMAARM |= 0x03;  
   \   00014B   43D603       ORL       0xd6,#0x3
    311                    DMAREQ |= 0x01;
   \   00014E   43D701       ORL       0xd7,#0x1
    312                    while (DMAARM&0x03);          
   \                     ??CTR_enc_decrypt_12:
   \   000151   E5D6         MOV       A,0xd6
   \   000153   5403         ANL       A,#0x3
   \   000155   70FA         JNZ       ??CTR_enc_decrypt_12
    313                  }
   \   000157   0B           INC       R3
   \   000158   8096         SJMP      ??CTR_enc_decrypt_10
    314              }     
   \                     ??CTR_enc_decrypt_11:
   \   00015A   0A           INC       R2
   \   00015B   02....       LJMP      ??CTR_enc_decrypt_7 & 0xFFFF
    315              // Шифруем последний блок
    316              uint8_t block_len = len % 16; // Размер последнего блока
   \                     ??CTR_enc_decrypt_8:
   \   00015E   E5..         MOV       A,?V4
   \   000160   75F010       MOV       B,#0x10
   \   000163   84           DIV       AB
   \   000164   E5F0         MOV       A,B
   \   000166   F5..         MOV       ?V2,A
    317                
    318              // Завершаем работу если блок пустой
    319              if (!block_len)
   \   000168   E5..         MOV       A,?V2
   \   00016A   7003         JNZ       $+5
   \   00016C   02....       LJMP      ??CTR_enc_decrypt_13 & 0xFFFF
    320                return;
    321                
    322              uint8_t padding_block[16]; // Блок заполненый нулями
    323              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
   \   00016F   75F010       MOV       B,#0x10
   \   000172   E5..         MOV       A,?V3
   \   000174   A4           MUL       AB
   \   000175   FE           MOV       R6,A
    324              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
   \   000176                ; Setup parameters for call to function memset
   \   000176   7410         MOV       A,#0x10
   \   000178   C0E0         PUSH      A
   \   00017A   7400         MOV       A,#0x0
   \   00017C   C0E0         PUSH      A
   \   00017E   7C00         MOV       R4,#0x0
   \   000180   7D00         MOV       R5,#0x0
   \   000182   90FFE9       MOV       DPTR,#-0x17
   \   000185   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000188   AA82         MOV       R2,DPL
   \   00018A   AB83         MOV       R3,DPH
   \   00018C   12....       LCALL     `??memset::?relay`; Banked call to: memset
   \   00018F   D0E0         POP       A
   \   000191   D0E0         POP       A
    325              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
   \   000193                ; Setup parameters for call to function memcpy
   \   000193   E5..         MOV       A,?V2
   \   000195   F582         MOV       DPL,A
   \   000197   758300       MOV       DPH,#0x0
   \   00019A   C082         PUSH      DPL
   \   00019C   C083         PUSH      DPH
   \   00019E   EE           MOV       A,R6
   \   00019F   F8           MOV       R0,A
   \   0001A0   7900         MOV       R1,#0x0
   \   0001A2   90FFF9       MOV       DPTR,#-0x7
   \   0001A5   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001A8   E0           MOVX      A,@DPTR
   \   0001A9   28           ADD       A,R0
   \   0001AA   FC           MOV       R4,A
   \   0001AB   A3           INC       DPTR
   \   0001AC   E0           MOVX      A,@DPTR
   \   0001AD   39           ADDC      A,R1
   \   0001AE   FD           MOV       R5,A
   \   0001AF   90FFE9       MOV       DPTR,#-0x17
   \   0001B2   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001B5   AA82         MOV       R2,DPL
   \   0001B7   AB83         MOV       R3,DPH
   \   0001B9   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   0001BC   D0E0         POP       A
   \   0001BE   D0E0         POP       A
    326              
    327              while(!AES_RDY());
   \                     ??CTR_enc_decrypt_14:
   \   0001C0   E5B3         MOV       A,0xb3
   \   0001C2   A2E3         MOV       C,0xE0 /* A   */.3
   \   0001C4   50FA         JNC       ??CTR_enc_decrypt_14
    328              AES_START();
   \   0001C6   43B301       ORL       0xb3,#0x1
    329              for (uint8_t j = 0; j < 4; j++)
   \   0001C9   7A00         MOV       R2,#0x0
   \                     ??CTR_enc_decrypt_15:
   \   0001CB   EA           MOV       A,R2
   \   0001CC   C3           CLR       C
   \   0001CD   9404         SUBB      A,#0x4
   \   0001CF   504F         JNC       ??CTR_enc_decrypt_16
    330                {
    331                  sub_ptr = 4*j;
   \   0001D1   75F004       MOV       B,#0x4
   \   0001D4   EA           MOV       A,R2
   \   0001D5   A4           MUL       AB
   \   0001D6   FF           MOV       R7,A
    332                  download = &padding_block[sub_ptr];
   \   0001D7   EF           MOV       A,R7
   \   0001D8   F8           MOV       R0,A
   \   0001D9   7900         MOV       R1,#0x0
   \   0001DB   90FFEB       MOV       DPTR,#-0x15
   \   0001DE   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001E1   E582         MOV       A,DPL
   \   0001E3   28           ADD       A,R0
   \   0001E4   F8           MOV       R0,A
   \   0001E5   E583         MOV       A,DPH
   \   0001E7   39           ADDC      A,R1
   \   0001E8   F9           MOV       R1,A
   \   0001E9   88..         MOV       ?V0,R0
   \   0001EB   89..         MOV       ?V1,R1
    333                  // Указываем адресс DMA откуда читать данные
    334                  ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
   \   0001ED   E5..         MOV       A,?V0
   \   0001EF   90....       MOV       DPTR,#DMA_CH + 1
   \   0001F2   F0           MOVX      @DPTR,A
    335                  ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
   \   0001F3   A8..         MOV       R0,?V0
   \   0001F5   A9..         MOV       R1,?V1
   \   0001F7   E4           CLR       A
   \   0001F8   C9           XCH       A,R1
   \   0001F9   F8           MOV       R0,A
   \   0001FA   E8           MOV       A,R0
   \   0001FB   90....       MOV       DPTR,#DMA_CH
   \   0001FE   F0           MOVX      @DPTR,A
    336                  // Указываем аддрес DMA куда записывать данные          
    337                  ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
   \   0001FF   E5..         MOV       A,?V0
   \   000201   90....       MOV       DPTR,#DMA_CH + 11
   \   000204   F0           MOVX      @DPTR,A
    338                  ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
   \   000205   A8..         MOV       R0,?V0
   \   000207   A9..         MOV       R1,?V1
   \   000209   E4           CLR       A
   \   00020A   C9           XCH       A,R1
   \   00020B   F8           MOV       R0,A
   \   00020C   E8           MOV       A,R0
   \   00020D   90....       MOV       DPTR,#DMA_CH + 10
   \   000210   F0           MOVX      @DPTR,A
    339                  // Активируем DMA
    340                  DMAARM |= 0x03;  
   \   000211   43D603       ORL       0xd6,#0x3
    341                  DMAREQ |= 0x01;
   \   000214   43D701       ORL       0xd7,#0x1
    342                  while (DMAARM&0x03);
   \                     ??CTR_enc_decrypt_17:
   \   000217   E5D6         MOV       A,0xd6
   \   000219   5403         ANL       A,#0x3
   \   00021B   70FA         JNZ       ??CTR_enc_decrypt_17
    343                }
   \   00021D   0A           INC       R2
   \   00021E   80AB         SJMP      ??CTR_enc_decrypt_15
    344              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
   \                     ??CTR_enc_decrypt_16:
   \   000220                ; Setup parameters for call to function memcpy
   \   000220   E5..         MOV       A,?V2
   \   000222   F582         MOV       DPL,A
   \   000224   758300       MOV       DPH,#0x0
   \   000227   C082         PUSH      DPL
   \   000229   C083         PUSH      DPH
   \   00022B   90FFE9       MOV       DPTR,#-0x17
   \   00022E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000231   AC82         MOV       R4,DPL
   \   000233   AD83         MOV       R5,DPH
   \   000235   EE           MOV       A,R6
   \   000236   F8           MOV       R0,A
   \   000237   7900         MOV       R1,#0x0
   \   000239   90FFFB       MOV       DPTR,#-0x5
   \   00023C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00023F   E0           MOVX      A,@DPTR
   \   000240   28           ADD       A,R0
   \   000241   FA           MOV       R2,A
   \   000242   A3           INC       DPTR
   \   000243   E0           MOVX      A,@DPTR
   \   000244   39           ADDC      A,R1
   \   000245   FB           MOV       R3,A
   \   000246   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   000249   D0E0         POP       A
   \   00024B   D0E0         POP       A
    345          }
   \                     ??CTR_enc_decrypt_13:
   \   00024D   74EC         MOV       A,#-0x14
   \   00024F   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000252   7F08         MOV       R7,#0x8
   \   000254   02....       LJMP      ?BANKED_LEAVE_SP
   \   000257                REQUIRE ENCCS
   \   000257                REQUIRE DMAARM
   \   000257                REQUIRE DMAREQ
    346          
    347          /**
    348          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    349          @param[in] len улинна последовательности для вычисления MAC
    350          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    351          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    352          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
   \                     ??CBCMAC_buf_encrypt:
    353          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 32
   \   000005   7420         MOV       A,#0x20
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   89..         MOV       ?V1,R1
   \   00000C   8A..         MOV       ?V4,R2
   \   00000E   8B..         MOV       ?V5,R3
   \   000010   8C..         MOV       ?V2,R4
   \   000012   8D..         MOV       ?V3,R5
    354            uint8_t IV[16];
    355            
    356            // Заполняем вектор нулями
    357            memset(IV, 0x00, sizeof(IV));
   \   000014                ; Setup parameters for call to function memset
   \   000014   7410         MOV       A,#0x10
   \   000016   C0E0         PUSH      A
   \   000018   7400         MOV       A,#0x0
   \   00001A   C0E0         PUSH      A
   \   00001C   7C00         MOV       R4,#0x0
   \   00001E   7D00         MOV       R5,#0x0
   \   000020   90FFDD       MOV       DPTR,#-0x23
   \   000023   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000026   AA82         MOV       R2,DPL
   \   000028   AB83         MOV       R3,DPH
   \   00002A   12....       LCALL     `??memset::?relay`; Banked call to: memset
   \   00002D   D0E0         POP       A
   \   00002F   D0E0         POP       A
    358            
    359            // Установим метод кодироваения
    360            AES_SET_MODE(AES_MODE_CBCMAC);  
   \   000031   53B38F       ANL       0xb3,#0x8f
   \   000034   43B350       ORL       0xb3,#0x50
    361            
    362            { // Сворачиваем код для улучшения чтения
    363            // Загружаем ключ
    364            AES_SET_OPERATION(AES_LOAD_KEY);
   \   000037   E5B3         MOV       A,0xb3
   \   000039   54F8         ANL       A,#0xf8
   \   00003B   4404         ORL       A,#0x4
   \   00003D   F5B3         MOV       0xb3,A
    365            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
   \   00003F   E5..         MOV       A,?V4
   \   000041   90....       MOV       DPTR,#DMA_CH + 1
   \   000044   F0           MOVX      @DPTR,A
    366            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
   \   000045   A8..         MOV       R0,?V4
   \   000047   A9..         MOV       R1,?V5
   \   000049   E4           CLR       A
   \   00004A   C9           XCH       A,R1
   \   00004B   F8           MOV       R0,A
   \   00004C   E8           MOV       A,R0
   \   00004D   90....       MOV       DPTR,#DMA_CH
   \   000050   F0           MOVX      @DPTR,A
    367            ST_DEF(DMA_CH[0], LENL, 16);
   \   000051   90....       MOV       DPTR,#DMA_CH + 5
   \   000054   7410         MOV       A,#0x10
   \   000056   F0           MOVX      @DPTR,A
    368            DMAARM |= 0x01;
   \   000057   43D601       ORL       0xd6,#0x1
    369            while(!AES_RDY());
   \                     ??CBCMAC_buf_encrypt_1:
   \   00005A   E5B3         MOV       A,0xb3
   \   00005C   A2E3         MOV       C,0xE0 /* A   */.3
   \   00005E   50FA         JNC       ??CBCMAC_buf_encrypt_1
    370            AES_START();
   \   000060   43B301       ORL       0xb3,#0x1
    371            while (DMAARM&0x01);
   \                     ??CBCMAC_buf_encrypt_2:
   \   000063   E5D6         MOV       A,0xd6
   \   000065   A2E0         MOV       C,0xE0 /* A   */.0
   \   000067   40FA         JC        ??CBCMAC_buf_encrypt_2
    372          
    373            // Загружаем IV
    374            AES_SET_OPERATION(AES_LOAD_IV);
   \   000069   E5B3         MOV       A,0xb3
   \   00006B   54F8         ANL       A,#0xf8
   \   00006D   4406         ORL       A,#0x6
   \   00006F   F5B3         MOV       0xb3,A
    375            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(IV));
   \   000071   90FFDF       MOV       DPTR,#-0x21
   \   000074   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000077   E582         MOV       A,DPL
   \   000079   90....       MOV       DPTR,#DMA_CH + 1
   \   00007C   F0           MOVX      @DPTR,A
    376            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(IV));
   \   00007D   90FFDF       MOV       DPTR,#-0x21
   \   000080   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000083   E4           CLR       A
   \   000084   C583         XCH       A,DPH
   \   000086   F582         MOV       DPL,A
   \   000088   E582         MOV       A,DPL
   \   00008A   90....       MOV       DPTR,#DMA_CH
   \   00008D   F0           MOVX      @DPTR,A
    377            ST_DEF(DMA_CH[0], LENL, 16);
   \   00008E   90....       MOV       DPTR,#DMA_CH + 5
   \   000091   7410         MOV       A,#0x10
   \   000093   F0           MOVX      @DPTR,A
    378            DMAARM |= 0x01;
   \   000094   43D601       ORL       0xd6,#0x1
    379            while(!AES_RDY());
   \                     ??CBCMAC_buf_encrypt_3:
   \   000097   E5B3         MOV       A,0xb3
   \   000099   A2E3         MOV       C,0xE0 /* A   */.3
   \   00009B   50FA         JNC       ??CBCMAC_buf_encrypt_3
    380            AES_START();
   \   00009D   43B301       ORL       0xb3,#0x1
    381            while (DMAARM&0x01);
   \                     ??CBCMAC_buf_encrypt_4:
   \   0000A0   E5D6         MOV       A,0xd6
   \   0000A2   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000A4   40FA         JC        ??CBCMAC_buf_encrypt_4
    382            };
    383            
    384            // Устанавливаем операцию шифрования
    385            AES_SET_OPERATION(AES_ENCRYPT);
   \   0000A6   53B3F8       ANL       0xb3,#0xf8
    386            
    387            // Загрузка блоками по 128 бит
    388            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
   \   0000A9   75F010       MOV       B,#0x10
   \   0000AC   E5..         MOV       A,?V1
   \   0000AE   84           DIV       AB
   \   0000AF   F5..         MOV       ?V0,A
    389            uint8_t block_len = len % 16; // Размер последнего блока
   \   0000B1   E5..         MOV       A,?V1
   \   0000B3   75F010       MOV       B,#0x10
   \   0000B6   84           DIV       AB
   \   0000B7   E5F0         MOV       A,B
   \   0000B9   FF           MOV       R7,A
    390            uint8_t ptr; // Смещение
    391                
    392            // Для этого типа шифрования длина блоков по 16 байт
    393            ST_DEF(DMA_CH[0], LENL, 16);
   \   0000BA   90....       MOV       DPTR,#DMA_CH + 5
   \   0000BD   7410         MOV       A,#0x10
   \   0000BF   F0           MOVX      @DPTR,A
    394            // Устанавливаем куда будем выгружать вычисленный MAC
    395            ST_DEF(DMA_CH[1], DSTADDRL, LADDR(mac));
   \   0000C0   E5..         MOV       A,?V2
   \   0000C2   90....       MOV       DPTR,#DMA_CH + 11
   \   0000C5   F0           MOVX      @DPTR,A
    396            ST_DEF(DMA_CH[1], DSTADDRH, HADDR(mac));
   \   0000C6   A8..         MOV       R0,?V2
   \   0000C8   A9..         MOV       R1,?V3
   \   0000CA   E4           CLR       A
   \   0000CB   C9           XCH       A,R1
   \   0000CC   F8           MOV       R0,A
   \   0000CD   E8           MOV       A,R0
   \   0000CE   90....       MOV       DPTR,#DMA_CH + 10
   \   0000D1   F0           MOVX      @DPTR,A
    397            ST_DEF(DMA_CH[1], LENL, 16);
   \   0000D2   90....       MOV       DPTR,#DMA_CH + 13
   \   0000D5   7410         MOV       A,#0x10
   \   0000D7   F0           MOVX      @DPTR,A
    398            
    399            // Шифруем все целые блоки
    400            for (uint8_t block = 0; block < nbrBlocks; block ++)
   \   0000D8   7A00         MOV       R2,#0x0
   \                     ??CBCMAC_buf_encrypt_5:
   \   0000DA   EA           MOV       A,R2
   \   0000DB   C3           CLR       C
   \   0000DC   95..         SUBB      A,?V0
   \   0000DE   5078         JNC       ??CBCMAC_buf_encrypt_6
    401              {
    402                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    403                // кратного 16 байтам.
    404                if (!block_len && (block == nbrBlocks - 1))
   \   0000E0   EF           MOV       A,R7
   \   0000E1   701F         JNZ       ??CBCMAC_buf_encrypt_7
   \   0000E3   EA           MOV       A,R2
   \   0000E4   FC           MOV       R4,A
   \   0000E5   7D00         MOV       R5,#0x0
   \   0000E7   E5..         MOV       A,?V0
   \   0000E9   F8           MOV       R0,A
   \   0000EA   7900         MOV       R1,#0x0
   \   0000EC   E8           MOV       A,R0
   \   0000ED   24FF         ADD       A,#-0x1
   \   0000EF   F8           MOV       R0,A
   \   0000F0   E9           MOV       A,R1
   \   0000F1   34FF         ADDC      A,#-0x1
   \   0000F3   F9           MOV       R1,A
   \   0000F4   E8           MOV       A,R0
   \   0000F5   6C           XRL       A,R4
   \   0000F6   7002         JNZ       ??CBCMAC_buf_encrypt_8
   \   0000F8   E9           MOV       A,R1
   \   0000F9   6D           XRL       A,R5
   \                     ??CBCMAC_buf_encrypt_8:
   \   0000FA   7006         JNZ       ??CBCMAC_buf_encrypt_7
    405                  AES_SET_MODE(AES_MODE_CBC);
   \   0000FC   53B38F       ANL       0xb3,#0x8f
   \   0000FF   85B3B3       MOV       0xb3,0xb3
    406                    
    407                ptr = 16 * block;
   \                     ??CBCMAC_buf_encrypt_7:
   \   000102   75F010       MOV       B,#0x10
   \   000105   EA           MOV       A,R2
   \   000106   A4           MUL       AB
   \   000107   FE           MOV       R6,A
    408                while(!AES_RDY());
   \                     ??CBCMAC_buf_encrypt_9:
   \   000108   E5B3         MOV       A,0xb3
   \   00010A   A2E3         MOV       C,0xE0 /* A   */.3
   \   00010C   50FA         JNC       ??CBCMAC_buf_encrypt_9
    409                AES_START();
   \   00010E   43B301       ORL       0xb3,#0x1
    410                // Указываем адресс DMA откуда читать данные
    411                ST_DEF(DMA_CH[0], SRCADDRL, LADDR(buf[ptr]));
   \   000111   EE           MOV       A,R6
   \   000112   F8           MOV       R0,A
   \   000113   7900         MOV       R1,#0x0
   \   000115   74..         MOV       A,#??buf & 0xff
   \   000117   28           ADD       A,R0
   \   000118   F582         MOV       DPL,A
   \   00011A   74..         MOV       A,#(??buf >> 8) & 0xff
   \   00011C   39           ADDC      A,R1
   \   00011D   F583         MOV       DPH,A
   \   00011F   E0           MOVX      A,@DPTR
   \   000120   90....       MOV       DPTR,#DMA_CH + 1
   \   000123   F0           MOVX      @DPTR,A
    412                ST_DEF(DMA_CH[0], SRCADDRH, HADDR(buf[ptr]));
   \   000124   90....       MOV       DPTR,#DMA_CH
   \   000127   7400         MOV       A,#0x0
   \   000129   F0           MOVX      @DPTR,A
    413                // Активируем DMA
    414                DMAARM |= 0x01;  
   \   00012A   43D601       ORL       0xd6,#0x1
    415                // Активируем выгрузку только последнего блока
    416                if (!block_len && (block == nbrBlocks - 1))
   \   00012D   EF           MOV       A,R7
   \   00012E   701C         JNZ       ??CBCMAC_buf_encrypt_10
   \   000130   EA           MOV       A,R2
   \   000131   FC           MOV       R4,A
   \   000132   7D00         MOV       R5,#0x0
   \   000134   E5..         MOV       A,?V0
   \   000136   F8           MOV       R0,A
   \   000137   7900         MOV       R1,#0x0
   \   000139   E8           MOV       A,R0
   \   00013A   24FF         ADD       A,#-0x1
   \   00013C   F8           MOV       R0,A
   \   00013D   E9           MOV       A,R1
   \   00013E   34FF         ADDC      A,#-0x1
   \   000140   F9           MOV       R1,A
   \   000141   E8           MOV       A,R0
   \   000142   6C           XRL       A,R4
   \   000143   7002         JNZ       ??CBCMAC_buf_encrypt_11
   \   000145   E9           MOV       A,R1
   \   000146   6D           XRL       A,R5
   \                     ??CBCMAC_buf_encrypt_11:
   \   000147   7003         JNZ       ??CBCMAC_buf_encrypt_10
    417                  DMAARM |= 0x03;
   \   000149   43D603       ORL       0xd6,#0x3
    418                
    419                DMAREQ |= 0x01;
   \                     ??CBCMAC_buf_encrypt_10:
   \   00014C   43D701       ORL       0xd7,#0x1
    420                while (DMAARM&0x03);          
   \                     ??CBCMAC_buf_encrypt_12:
   \   00014F   E5D6         MOV       A,0xd6
   \   000151   5403         ANL       A,#0x3
   \   000153   70FA         JNZ       ??CBCMAC_buf_encrypt_12
    421               }
   \   000155   0A           INC       R2
   \   000156   8082         SJMP      ??CBCMAC_buf_encrypt_5
    422                 
    423            // Шифруем последний блок в режиме CBC
    424            AES_SET_MODE(AES_MODE_CBC);
   \                     ??CBCMAC_buf_encrypt_6:
   \   000158   53B38F       ANL       0xb3,#0x8f
   \   00015B   85B3B3       MOV       0xb3,0xb3
    425                    
    426            // Завершаем работу если блок пустой
    427            if (!block_len)
   \   00015E   EF           MOV       A,R7
   \   00015F   607D         JZ        ??CBCMAC_buf_encrypt_13
    428              return;
    429                
    430            uint8_t padding_block[16]; // Блок заполненый нулями
    431            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
   \   000161   75F010       MOV       B,#0x10
   \   000164   E5..         MOV       A,?V0
   \   000166   A4           MUL       AB
   \   000167   FE           MOV       R6,A
    432            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
   \   000168                ; Setup parameters for call to function memset
   \   000168   7410         MOV       A,#0x10
   \   00016A   C0E0         PUSH      A
   \   00016C   7400         MOV       A,#0x0
   \   00016E   C0E0         PUSH      A
   \   000170   7C00         MOV       R4,#0x0
   \   000172   7D00         MOV       R5,#0x0
   \   000174   90FFED       MOV       DPTR,#-0x13
   \   000177   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00017A   AA82         MOV       R2,DPL
   \   00017C   AB83         MOV       R3,DPH
   \   00017E   12....       LCALL     `??memset::?relay`; Banked call to: memset
   \   000181   D0E0         POP       A
   \   000183   D0E0         POP       A
    433            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
   \   000185                ; Setup parameters for call to function memcpy
   \   000185   EF           MOV       A,R7
   \   000186   F582         MOV       DPL,A
   \   000188   758300       MOV       DPH,#0x0
   \   00018B   C082         PUSH      DPL
   \   00018D   C083         PUSH      DPH
   \   00018F   EE           MOV       A,R6
   \   000190   F8           MOV       R0,A
   \   000191   7900         MOV       R1,#0x0
   \   000193   74..         MOV       A,#??buf & 0xff
   \   000195   28           ADD       A,R0
   \   000196   FC           MOV       R4,A
   \   000197   74..         MOV       A,#(??buf >> 8) & 0xff
   \   000199   39           ADDC      A,R1
   \   00019A   FD           MOV       R5,A
   \   00019B   90FFED       MOV       DPTR,#-0x13
   \   00019E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001A1   AA82         MOV       R2,DPL
   \   0001A3   AB83         MOV       R3,DPH
   \   0001A5   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   0001A8   D0E0         POP       A
   \   0001AA   D0E0         POP       A
    434                
    435            while(!AES_RDY());
   \                     ??CBCMAC_buf_encrypt_14:
   \   0001AC   E5B3         MOV       A,0xb3
   \   0001AE   A2E3         MOV       C,0xE0 /* A   */.3
   \   0001B0   50FA         JNC       ??CBCMAC_buf_encrypt_14
    436            AES_START();
   \   0001B2   43B301       ORL       0xb3,#0x1
    437            // Указываем адресс DMA откуда читать данные
    438            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(padding_block));
   \   0001B5   90FFEF       MOV       DPTR,#-0x11
   \   0001B8   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001BB   E582         MOV       A,DPL
   \   0001BD   90....       MOV       DPTR,#DMA_CH + 1
   \   0001C0   F0           MOVX      @DPTR,A
    439            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(padding_block));
   \   0001C1   90FFEF       MOV       DPTR,#-0x11
   \   0001C4   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001C7   E4           CLR       A
   \   0001C8   C583         XCH       A,DPH
   \   0001CA   F582         MOV       DPL,A
   \   0001CC   E582         MOV       A,DPL
   \   0001CE   90....       MOV       DPTR,#DMA_CH
   \   0001D1   F0           MOVX      @DPTR,A
    440            // Активируем DMA и выгрузку MAC
    441            DMAARM |= 0x03;  
   \   0001D2   43D603       ORL       0xd6,#0x3
    442            DMAREQ |= 0x01;
   \   0001D5   43D701       ORL       0xd7,#0x1
    443            while (DMAARM&0x03);
   \                     ??CBCMAC_buf_encrypt_15:
   \   0001D8   E5D6         MOV       A,0xd6
   \   0001DA   5403         ANL       A,#0x3
   \   0001DC   70FA         JNZ       ??CBCMAC_buf_encrypt_15
    444          }
   \                     ??CBCMAC_buf_encrypt_13:
   \   0001DE   74E0         MOV       A,#-0x20
   \   0001E0   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001E3   7F06         MOV       R7,#0x6
   \   0001E5   02....       LJMP      ?BANKED_LEAVE_SP
   \   0001E8                REQUIRE ENCCS
   \   0001E8                REQUIRE DMAARM
   \   0001E8                REQUIRE DMAREQ
    445          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    446          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
   \                     ??generateAuthData:
    447                                                 uint8_t f, uint8_t lm)
    448          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   \   000009   8C..         MOV       ?V4,R4
   \   00000B   8D..         MOV       ?V5,R5
   \   00000D   E9           MOV       A,R1
   \   00000E   FF           MOV       R7,A
   \   00000F   90FFF2       MOV       DPTR,#-0xe
   \   000012   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FE           MOV       R6,A
   \   000017   90FFF1       MOV       DPTR,#-0xf
   \   00001A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   F5..         MOV       ?V0,A
    449            memcpy(buf, nonce,16);
   \   000020                ; Setup parameters for call to function memcpy
   \   000020   7410         MOV       A,#0x10
   \   000022   C0E0         PUSH      A
   \   000024   7400         MOV       A,#0x0
   \   000026   C0E0         PUSH      A
   \   000028   AC..         MOV       R4,?V4
   \   00002A   AD..         MOV       R5,?V5
   \   00002C   7A..         MOV       R2,#??buf & 0xff
   \   00002E   7B..         MOV       R3,#(??buf >> 8) & 0xff
   \   000030   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   000033   D0E0         POP       A
   \   000035   D0E0         POP       A
    450            
    451            // Буфер от 0 до 15 байта специальный блок B0
    452            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    453            buf[0]=  0x01;  
   \   000037   90....       MOV       DPTR,#??buf
   \   00003A   7401         MOV       A,#0x1
   \   00003C   F0           MOVX      @DPTR,A
    454            // Если есть данные для авторизации установим A_Data 
    455            if (f > 0)
   \   00003D   EE           MOV       A,R6
   \   00003E   6007         JZ        ??generateAuthData_1
    456              buf[0] |= 0x40;
   \   000040   90....       MOV       DPTR,#??buf
   \   000043   E0           MOVX      A,@DPTR
   \   000044   D2E6         SETB      0xE0 /* A   */.6
   \   000046   F0           MOVX      @DPTR,A
    457            
    458            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
   \                     ??generateAuthData_1:
   \   000047   E5..         MOV       A,?V0
   \   000049   F8           MOV       R0,A
   \   00004A   7900         MOV       R1,#0x0
   \   00004C   E8           MOV       A,R0
   \   00004D   24FE         ADD       A,#-0x2
   \   00004F   F8           MOV       R0,A
   \   000050   E9           MOV       A,R1
   \   000051   34FF         ADDC      A,#-0x1
   \   000053   F9           MOV       R1,A
   \   000054   7A02         MOV       R2,#0x2
   \   000056   7B00         MOV       R3,#0x0
   \   000058   12....       LCALL     ?S_DIV_MOD
   \   00005B   E8           MOV       A,R0
   \   00005C   33           RLC       A
   \   00005D   33           RLC       A
   \   00005E   33           RLC       A
   \   00005F   54F8         ANL       A,#0xf8
   \   000061   F8           MOV       R0,A
   \   000062   90....       MOV       DPTR,#??buf
   \   000065   E0           MOVX      A,@DPTR
   \   000066   48           ORL       A,R0
   \   000067   F0           MOVX      @DPTR,A
    459            
    460            // Устанавливаем длинну сообщения
    461            buf[14] = 0x00;
   \   000068   90....       MOV       DPTR,#??buf + 14
   \   00006B   7400         MOV       A,#0x0
   \   00006D   F0           MOVX      @DPTR,A
    462            buf[15] = c;
   \   00006E   EF           MOV       A,R7
   \   00006F   90....       MOV       DPTR,#??buf + 15
   \   000072   F0           MOVX      @DPTR,A
    463            
    464            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    465            buf[16]= 0;
   \   000073   90....       MOV       DPTR,#??buf + 16
   \   000076   7400         MOV       A,#0x0
   \   000078   F0           MOVX      @DPTR,A
    466            buf[17]= f;
   \   000079   EE           MOV       A,R6
   \   00007A   90....       MOV       DPTR,#??buf + 17
   \   00007D   F0           MOVX      @DPTR,A
    467            
    468            // Копируем данные авторизации в буфер
    469            memcpy(&buf[18], src, f);
   \   00007E                ; Setup parameters for call to function memcpy
   \   00007E   EE           MOV       A,R6
   \   00007F   F582         MOV       DPL,A
   \   000081   758300       MOV       DPH,#0x0
   \   000084   C082         PUSH      DPL
   \   000086   C083         PUSH      DPH
   \   000088   AC..         MOV       R4,?V2
   \   00008A   AD..         MOV       R5,?V3
   \   00008C   7A..         MOV       R2,#(??buf + 18) & 0xff
   \   00008E   7B..         MOV       R3,#((??buf + 18) >> 8) & 0xff
   \   000090   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   000093   D0E0         POP       A
   \   000095   D0E0         POP       A
    470            
    471            // Смещение на следующий байт после данных авторизации.
    472            // Данные авторизации занимают положение в буфере [18, 18+f]
    473            uint8_t ptr_end= 18 + f;
   \   000097   7412         MOV       A,#0x12
   \   000099   2E           ADD       A,R6
   \   00009A   F5..         MOV       ?V1,A
    474            // Заполняем нулями до границы 16 байт  
    475            while (ptr_end & 0x0f)
   \                     ??generateAuthData_2:
   \   00009C   740F         MOV       A,#0xf
   \   00009E   55..         ANL       A,?V1
   \   0000A0   6016         JZ        ??generateAuthData_3
    476              buf[ptr_end++] = 0x00;
   \   0000A2   E5..         MOV       A,?V1
   \   0000A4   F8           MOV       R0,A
   \   0000A5   7900         MOV       R1,#0x0
   \   0000A7   74..         MOV       A,#??buf & 0xff
   \   0000A9   28           ADD       A,R0
   \   0000AA   F582         MOV       DPL,A
   \   0000AC   74..         MOV       A,#(??buf >> 8) & 0xff
   \   0000AE   39           ADDC      A,R1
   \   0000AF   F583         MOV       DPH,A
   \   0000B1   7400         MOV       A,#0x0
   \   0000B3   F0           MOVX      @DPTR,A
   \   0000B4   05..         INC       ?V1
   \   0000B6   80E4         SJMP      ??generateAuthData_2
    477            
    478            // Копируем данные для шифрования в буфер после нулей
    479            memcpy(&buf[ptr_end], &src[f], c);
   \                     ??generateAuthData_3:
   \   0000B8                ; Setup parameters for call to function memcpy
   \   0000B8   EF           MOV       A,R7
   \   0000B9   F582         MOV       DPL,A
   \   0000BB   758300       MOV       DPH,#0x0
   \   0000BE   C082         PUSH      DPL
   \   0000C0   C083         PUSH      DPH
   \   0000C2   EE           MOV       A,R6
   \   0000C3   F8           MOV       R0,A
   \   0000C4   7900         MOV       R1,#0x0
   \   0000C6   E5..         MOV       A,?V2
   \   0000C8   28           ADD       A,R0
   \   0000C9   FC           MOV       R4,A
   \   0000CA   E5..         MOV       A,?V3
   \   0000CC   39           ADDC      A,R1
   \   0000CD   FD           MOV       R5,A
   \   0000CE   E5..         MOV       A,?V1
   \   0000D0   F8           MOV       R0,A
   \   0000D1   7900         MOV       R1,#0x0
   \   0000D3   74..         MOV       A,#??buf & 0xff
   \   0000D5   28           ADD       A,R0
   \   0000D6   FA           MOV       R2,A
   \   0000D7   74..         MOV       A,#(??buf >> 8) & 0xff
   \   0000D9   39           ADDC      A,R1
   \   0000DA   FB           MOV       R3,A
   \   0000DB   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   0000DE   D0E0         POP       A
   \   0000E0   D0E0         POP       A
    480            
    481            // Возвращаем размер данных в буфере
    482            return ptr_end+c;
   \   0000E2   E5..         MOV       A,?V1
   \   0000E4   2F           ADD       A,R7
   \   0000E5   F9           MOV       R1,A
   \   0000E6   7F06         MOV       R7,#0x6
   \   0000E8   02....       LJMP      ?BANKED_LEAVE_SP
    483          };
    484          
    485          /**
    486          @brief Шифрует/дешифрует данные с проверкой MIC
    487          @param[in] src Указатель на данные подлежащии шифрованию
    488          @param[in] len Размер данных
    489          @param[in] с Количество байт для шифрования
    490          @param[in] f Количество байт для авторизации
    491          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    492          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    493          @param[in] len Длинна данных
    494          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    495          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    496          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m, uint8_t *MIC)
   \                     AES_CCMEncrypt:
    497          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 34
   \   000005   7422         MOV       A,#0x22
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   8A..         MOV       ?V6,R2
   \   00000C   8B..         MOV       ?V7,R3
   \   00000E   89..         MOV       ?V0,R1
   \   000010   8C..         MOV       ?V2,R4
   \   000012   8D..         MOV       ?V3,R5
    498            uint8_t *key = (uint8_t*)MODEL.AES.CCM_KEY;  
   \   000014   75....       MOV       ?V4,#(MODEL + 51) & 0xff
   \   000017   75....       MOV       ?V5,#((MODEL + 51) >> 8) & 0xff
    499            uint8_t *nonce = (uint8_t*)MODEL.AES.CCM_IV; 
   \   00001A   90FFFD       MOV       DPTR,#-0x3
   \   00001D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000020   74..         MOV       A,#(MODEL + 67) & 0xff
   \   000022   F0           MOVX      @DPTR,A
   \   000023   A3           INC       DPTR
   \   000024   74..         MOV       A,#((MODEL + 67) >> 8) & 0xff
   \   000026   F0           MOVX      @DPTR,A
    500            uint8_t lm = MIC_2_MICLEN(m);
   \   000027   7401         MOV       A,#0x1
   \   000029   C0E0         PUSH      A
   \   00002B   7403         MOV       A,#0x3
   \   00002D   55..         ANL       A,?V3
   \   00002F   2401         ADD       A,#0x1
   \   000031   F8           MOV       R0,A
   \   000032   D0E0         POP       A
   \   000034   B80002       CJNE      R0,#0x0,??AES_CCMEncrypt_0
   \   000037   8004         SJMP      ??AES_CCMEncrypt_1
   \                     ??AES_CCMEncrypt_0:
   \   000039   C3           CLR       C
   \   00003A   33           RLC       A
   \   00003B   D8FC         DJNZ      R0,??AES_CCMEncrypt_0
   \                     ??AES_CCMEncrypt_1:
   \   00003D   54FC         ANL       A,#0xfc
   \   00003F   F5..         MOV       ?V1,A
    501            
    502            // Генерируем данные для авторизации
    503            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
   \   000041                ; Setup parameters for call to function generateAuthData
   \   000041   E5..         MOV       A,?V1
   \   000043   C0E0         PUSH      A
   \   000045   E5..         MOV       A,?V2
   \   000047   C0E0         PUSH      A
   \   000049   A9..         MOV       R1,?V0
   \   00004B   90FFFB       MOV       DPTR,#-0x5
   \   00004E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000051   E0           MOVX      A,@DPTR
   \   000052   FC           MOV       R4,A
   \   000053   A3           INC       DPTR
   \   000054   E0           MOVX      A,@DPTR
   \   000055   FD           MOV       R5,A
   \   000056   AA..         MOV       R2,?V6
   \   000058   AB..         MOV       R3,?V7
   \   00005A   12....       LCALL     `??generateAuthData::?relay`; Banked call to: generateAuthData
   \   00005D   D0E0         POP       A
   \   00005F   D0E0         POP       A
   \   000061   E9           MOV       A,R1
   \   000062   FE           MOV       R6,A
    504            
    505            uint8_t mac[16]; // Сюда пишем мак
    506            CBCMAC_buf_encrypt(dlen, key, mac);
   \   000063                ; Setup parameters for call to function CBCMAC_buf_encrypt
   \   000063   90FFDD       MOV       DPTR,#-0x23
   \   000066   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000069   AC82         MOV       R4,DPL
   \   00006B   AD83         MOV       R5,DPH
   \   00006D   AA..         MOV       R2,?V4
   \   00006F   AB..         MOV       R3,?V5
   \   000071   EE           MOV       A,R6
   \   000072   F9           MOV       R1,A
   \   000073   12....       LCALL     `??CBCMAC_buf_encrypt::?relay`; Banked call to: CBCMAC_buf_encrypt
    507            
    508            // Шифруем MAC
    509            uint8_t CTR_IV[16];
    510            memcpy(CTR_IV, nonce, 16);
   \   000076                ; Setup parameters for call to function memcpy
   \   000076   7410         MOV       A,#0x10
   \   000078   C0E0         PUSH      A
   \   00007A   7400         MOV       A,#0x0
   \   00007C   C0E0         PUSH      A
   \   00007E   90FFFB       MOV       DPTR,#-0x5
   \   000081   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000084   E0           MOVX      A,@DPTR
   \   000085   FC           MOV       R4,A
   \   000086   A3           INC       DPTR
   \   000087   E0           MOVX      A,@DPTR
   \   000088   FD           MOV       R5,A
   \   000089   90FFEB       MOV       DPTR,#-0x15
   \   00008C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00008F   AA82         MOV       R2,DPL
   \   000091   AB83         MOV       R3,DPH
   \   000093   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   000096   D0E0         POP       A
   \   000098   D0E0         POP       A
    511            CTR_IV[0] = 0x01; // Флаг режима CTR
   \   00009A   90FFED       MOV       DPTR,#-0x13
   \   00009D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A0   7401         MOV       A,#0x1
   \   0000A2   F0           MOVX      @DPTR,A
    512            CTR_IV[15] = 0;   // Значение счетчика
   \   0000A3   90FFFC       MOV       DPTR,#-0x4
   \   0000A6   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A9   7400         MOV       A,#0x0
   \   0000AB   F0           MOVX      @DPTR,A
    513            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
   \   0000AC                ; Setup parameters for call to function CTR_enc_decrypt
   \   0000AC   90FFED       MOV       DPTR,#-0x13
   \   0000AF   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000B2   C082         PUSH      DPL
   \   0000B4   C083         PUSH      DPH
   \   0000B6   C0..         PUSH      ?V4
   \   0000B8   C0..         PUSH      ?V5
   \   0000BA   7910         MOV       R1,#0x10
   \   0000BC   90FFD9       MOV       DPTR,#-0x27
   \   0000BF   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000C2   AC82         MOV       R4,DPL
   \   0000C4   AD83         MOV       R5,DPH
   \   0000C6   90FFD9       MOV       DPTR,#-0x27
   \   0000C9   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000CC   AA82         MOV       R2,DPL
   \   0000CE   AB83         MOV       R3,DPH
   \   0000D0   D2F0         SETB      B.0
   \   0000D2   12....       LCALL     `??CTR_enc_decrypt::?relay`; Banked call to: CTR_enc_decrypt
   \   0000D5   74FC         MOV       A,#-0x4
   \   0000D7   12....       LCALL     ?DEALLOC_EXT_STACK8
    514            
    515            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    516            // dlen-c, dlen
    517            uint8_t ds = dlen - c; // Начало данных для шифрования
   \   0000DA   EE           MOV       A,R6
   \   0000DB   C3           CLR       C
   \   0000DC   95..         SUBB      A,?V0
   \   0000DE   FF           MOV       R7,A
    518            
    519            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    520            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
   \   0000DF                ; Setup parameters for call to function memset
   \   0000DF   EE           MOV       A,R6
   \   0000E0   F8           MOV       R0,A
   \   0000E1   7900         MOV       R1,#0x0
   \   0000E3   7410         MOV       A,#0x10
   \   0000E5   C3           CLR       C
   \   0000E6   98           SUBB      A,R0
   \   0000E7   F8           MOV       R0,A
   \   0000E8   7400         MOV       A,#0x0
   \   0000EA   99           SUBB      A,R1
   \   0000EB   F9           MOV       R1,A
   \   0000EC   E8           MOV       A,R0
   \   0000ED   540F         ANL       A,#0xf
   \   0000EF   F8           MOV       R0,A
   \   0000F0   E9           MOV       A,R1
   \   0000F1   5400         ANL       A,#0x0
   \   0000F3   F9           MOV       R1,A
   \   0000F4   E8           MOV       A,R0
   \   0000F5   C0E0         PUSH      A
   \   0000F7   E9           MOV       A,R1
   \   0000F8   C0E0         PUSH      A
   \   0000FA   7C00         MOV       R4,#0x0
   \   0000FC   7D00         MOV       R5,#0x0
   \   0000FE   EE           MOV       A,R6
   \   0000FF   F8           MOV       R0,A
   \   000100   7900         MOV       R1,#0x0
   \   000102   74..         MOV       A,#??buf & 0xff
   \   000104   28           ADD       A,R0
   \   000105   FA           MOV       R2,A
   \   000106   74..         MOV       A,#(??buf >> 8) & 0xff
   \   000108   39           ADDC      A,R1
   \   000109   FB           MOV       R3,A
   \   00010A   12....       LCALL     `??memset::?relay`; Banked call to: memset
   \   00010D   D0E0         POP       A
   \   00010F   D0E0         POP       A
    521            CTR_IV[15] = 1; // Счетчик CTR
   \   000111   90FFFC       MOV       DPTR,#-0x4
   \   000114   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000117   7401         MOV       A,#0x1
   \   000119   F0           MOVX      @DPTR,A
    522            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
   \   00011A                ; Setup parameters for call to function CTR_enc_decrypt
   \   00011A   90FFED       MOV       DPTR,#-0x13
   \   00011D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000120   C082         PUSH      DPL
   \   000122   C083         PUSH      DPH
   \   000124   C0..         PUSH      ?V4
   \   000126   C0..         PUSH      ?V5
   \   000128   A9..         MOV       R1,?V0
   \   00012A   EF           MOV       A,R7
   \   00012B   FA           MOV       R2,A
   \   00012C   7B00         MOV       R3,#0x0
   \   00012E   74..         MOV       A,#??buf & 0xff
   \   000130   2A           ADD       A,R2
   \   000131   FC           MOV       R4,A
   \   000132   74..         MOV       A,#(??buf >> 8) & 0xff
   \   000134   3B           ADDC      A,R3
   \   000135   FD           MOV       R5,A
   \   000136   EF           MOV       A,R7
   \   000137   FA           MOV       R2,A
   \   000138   7B00         MOV       R3,#0x0
   \   00013A   74..         MOV       A,#??buf & 0xff
   \   00013C   2A           ADD       A,R2
   \   00013D   FA           MOV       R2,A
   \   00013E   74..         MOV       A,#(??buf >> 8) & 0xff
   \   000140   3B           ADDC      A,R3
   \   000141   FB           MOV       R3,A
   \   000142   D2F0         SETB      B.0
   \   000144   12....       LCALL     `??CTR_enc_decrypt::?relay`; Banked call to: CTR_enc_decrypt
   \   000147   74FC         MOV       A,#-0x4
   \   000149   12....       LCALL     ?DEALLOC_EXT_STACK8
    523            
    524            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    525            // src[f, f+c] это шифрованные данные.
    526            memcpy(&src[f], &buf[ds], c); 
   \   00014C                ; Setup parameters for call to function memcpy
   \   00014C   E5..         MOV       A,?V0
   \   00014E   F582         MOV       DPL,A
   \   000150   758300       MOV       DPH,#0x0
   \   000153   C082         PUSH      DPL
   \   000155   C083         PUSH      DPH
   \   000157   EF           MOV       A,R7
   \   000158   F8           MOV       R0,A
   \   000159   7900         MOV       R1,#0x0
   \   00015B   74..         MOV       A,#??buf & 0xff
   \   00015D   28           ADD       A,R0
   \   00015E   FC           MOV       R4,A
   \   00015F   74..         MOV       A,#(??buf >> 8) & 0xff
   \   000161   39           ADDC      A,R1
   \   000162   FD           MOV       R5,A
   \   000163   E5..         MOV       A,?V2
   \   000165   F8           MOV       R0,A
   \   000166   7900         MOV       R1,#0x0
   \   000168   E5..         MOV       A,?V6
   \   00016A   28           ADD       A,R0
   \   00016B   FA           MOV       R2,A
   \   00016C   E5..         MOV       A,?V7
   \   00016E   39           ADDC      A,R1
   \   00016F   FB           MOV       R3,A
   \   000170   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   000173   D0E0         POP       A
   \   000175   D0E0         POP       A
    527            memcpy(MIC, mac, lm);
   \   000177                ; Setup parameters for call to function memcpy
   \   000177   E5..         MOV       A,?V1
   \   000179   F582         MOV       DPL,A
   \   00017B   758300       MOV       DPH,#0x0
   \   00017E   C082         PUSH      DPL
   \   000180   C083         PUSH      DPH
   \   000182   90FFDB       MOV       DPTR,#-0x25
   \   000185   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000188   AC82         MOV       R4,DPL
   \   00018A   AD83         MOV       R5,DPH
   \   00018C   90FFCB       MOV       DPTR,#-0x35
   \   00018F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000192   E0           MOVX      A,@DPTR
   \   000193   FA           MOV       R2,A
   \   000194   A3           INC       DPTR
   \   000195   E0           MOVX      A,@DPTR
   \   000196   FB           MOV       R3,A
   \   000197   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   00019A   D0E0         POP       A
   \   00019C   D0E0         POP       A
    528            
    529            //https://github.com/zhaohengyi/CC2530Example/blob/
    530            //master/source/components/radios/cc2530/hal_rf_security.c
    531          }
   \   00019E   74DE         MOV       A,#-0x22
   \   0001A0   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001A3   7F08         MOV       R7,#0x8
   \   0001A5   02....       LJMP      ?BANKED_LEAVE_SP
    532          
    533          /**
    534          @brief Дешифрует данные с проверкой MIC
    535          @param[in] src Указатель на данные подлежащии шифрованию
    536          @param[in] len Размер данных
    537          @param[in] с Количество байт для шифрования
    538          @param[in] f Количество байт для авторизации
    539          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    540          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    541          @param[in] len Длинна данных
    542          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    543          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    544          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m, uint8_t *MIC)
   \                     AES_CCMDecrypt:
    545          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 50
   \   000005   7432         MOV       A,#0x32
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   8A..         MOV       ?V6,R2
   \   00000C   8B..         MOV       ?V7,R3
   \   00000E   E9           MOV       A,R1
   \   00000F   FF           MOV       R7,A
   \   000010   8C..         MOV       ?V2,R4
   \   000012   8D..         MOV       ?V3,R5
    546            uint8_t *key = (uint8_t*)MODEL.AES.CCM_KEY;  
   \   000014   75....       MOV       ?V4,#(MODEL + 51) & 0xff
   \   000017   75....       MOV       ?V5,#((MODEL + 51) >> 8) & 0xff
    547            uint8_t *nonce = (uint8_t*)MODEL.AES.CCM_IV;  
   \   00001A   90FFFD       MOV       DPTR,#-0x3
   \   00001D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000020   74..         MOV       A,#(MODEL + 67) & 0xff
   \   000022   F0           MOVX      @DPTR,A
   \   000023   A3           INC       DPTR
   \   000024   74..         MOV       A,#((MODEL + 67) >> 8) & 0xff
   \   000026   F0           MOVX      @DPTR,A
    548            uint8_t lm = MIC_2_MICLEN(m);
   \   000027   7401         MOV       A,#0x1
   \   000029   C0E0         PUSH      A
   \   00002B   7403         MOV       A,#0x3
   \   00002D   55..         ANL       A,?V3
   \   00002F   2401         ADD       A,#0x1
   \   000031   F8           MOV       R0,A
   \   000032   D0E0         POP       A
   \   000034   B80002       CJNE      R0,#0x0,??AES_CCMDecrypt_0
   \   000037   8004         SJMP      ??AES_CCMDecrypt_1
   \                     ??AES_CCMDecrypt_0:
   \   000039   C3           CLR       C
   \   00003A   33           RLC       A
   \   00003B   D8FC         DJNZ      R0,??AES_CCMDecrypt_0
   \                     ??AES_CCMDecrypt_1:
   \   00003D   54FC         ANL       A,#0xfc
   \   00003F   F5..         MOV       ?V1,A
    549            
    550            // Расшифровываем MAC
    551            uint8_t mac[16]; // Расшифрованый мак
    552            uint8_t CTR_IV[16];
    553            memcpy(CTR_IV, nonce, 16);
   \   000041                ; Setup parameters for call to function memcpy
   \   000041   7410         MOV       A,#0x10
   \   000043   C0E0         PUSH      A
   \   000045   7400         MOV       A,#0x0
   \   000047   C0E0         PUSH      A
   \   000049   90FFFB       MOV       DPTR,#-0x5
   \   00004C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   FC           MOV       R4,A
   \   000051   A3           INC       DPTR
   \   000052   E0           MOVX      A,@DPTR
   \   000053   FD           MOV       R5,A
   \   000054   90FFEB       MOV       DPTR,#-0x15
   \   000057   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00005A   AA82         MOV       R2,DPL
   \   00005C   AB83         MOV       R3,DPH
   \   00005E   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   000061   D0E0         POP       A
   \   000063   D0E0         POP       A
    554            CTR_IV[0] = 0x01; // Флаг режима CTR
   \   000065   90FFED       MOV       DPTR,#-0x13
   \   000068   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00006B   7401         MOV       A,#0x1
   \   00006D   F0           MOVX      @DPTR,A
    555            CTR_IV[15] = 0;   // Значение счетчика
   \   00006E   90FFFC       MOV       DPTR,#-0x4
   \   000071   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000074   7400         MOV       A,#0x0
   \   000076   F0           MOVX      @DPTR,A
    556            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
   \   000077                ; Setup parameters for call to function CTR_enc_decrypt
   \   000077   90FFED       MOV       DPTR,#-0x13
   \   00007A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00007D   C082         PUSH      DPL
   \   00007F   C083         PUSH      DPH
   \   000081   C0..         PUSH      ?V4
   \   000083   C0..         PUSH      ?V5
   \   000085   A9..         MOV       R1,?V1
   \   000087   90FFC9       MOV       DPTR,#-0x37
   \   00008A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00008D   AC82         MOV       R4,DPL
   \   00008F   AD83         MOV       R5,DPH
   \   000091   90FFB9       MOV       DPTR,#-0x47
   \   000094   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000097   E0           MOVX      A,@DPTR
   \   000098   FA           MOV       R2,A
   \   000099   A3           INC       DPTR
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   FB           MOV       R3,A
   \   00009C   C2F0         CLR       B.0
   \   00009E   12....       LCALL     `??CTR_enc_decrypt::?relay`; Banked call to: CTR_enc_decrypt
   \   0000A1   74FC         MOV       A,#-0x4
   \   0000A3   12....       LCALL     ?DEALLOC_EXT_STACK8
    557            
    558            // Генерируем данные для авторизации
    559            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
   \   0000A6                ; Setup parameters for call to function generateAuthData
   \   0000A6   E5..         MOV       A,?V1
   \   0000A8   C0E0         PUSH      A
   \   0000AA   E5..         MOV       A,?V2
   \   0000AC   C0E0         PUSH      A
   \   0000AE   EF           MOV       A,R7
   \   0000AF   F9           MOV       R1,A
   \   0000B0   90FFFB       MOV       DPTR,#-0x5
   \   0000B3   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000B6   E0           MOVX      A,@DPTR
   \   0000B7   FC           MOV       R4,A
   \   0000B8   A3           INC       DPTR
   \   0000B9   E0           MOVX      A,@DPTR
   \   0000BA   FD           MOV       R5,A
   \   0000BB   AA..         MOV       R2,?V6
   \   0000BD   AB..         MOV       R3,?V7
   \   0000BF   12....       LCALL     `??generateAuthData::?relay`; Banked call to: generateAuthData
   \   0000C2   D0E0         POP       A
   \   0000C4   D0E0         POP       A
   \   0000C6   E9           MOV       A,R1
   \   0000C7   FE           MOV       R6,A
    560            
    561            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    562            // dlen-c, dlen
    563            uint8_t ds = dlen - c; // Начало данных для дешифрования
   \   0000C8   EE           MOV       A,R6
   \   0000C9   C3           CLR       C
   \   0000CA   9F           SUBB      A,R7
   \   0000CB   F5..         MOV       ?V0,A
    564            
    565            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    566            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
   \   0000CD                ; Setup parameters for call to function memset
   \   0000CD   EE           MOV       A,R6
   \   0000CE   F8           MOV       R0,A
   \   0000CF   7900         MOV       R1,#0x0
   \   0000D1   7410         MOV       A,#0x10
   \   0000D3   C3           CLR       C
   \   0000D4   98           SUBB      A,R0
   \   0000D5   F8           MOV       R0,A
   \   0000D6   7400         MOV       A,#0x0
   \   0000D8   99           SUBB      A,R1
   \   0000D9   F9           MOV       R1,A
   \   0000DA   E8           MOV       A,R0
   \   0000DB   540F         ANL       A,#0xf
   \   0000DD   F8           MOV       R0,A
   \   0000DE   E9           MOV       A,R1
   \   0000DF   5400         ANL       A,#0x0
   \   0000E1   F9           MOV       R1,A
   \   0000E2   E8           MOV       A,R0
   \   0000E3   C0E0         PUSH      A
   \   0000E5   E9           MOV       A,R1
   \   0000E6   C0E0         PUSH      A
   \   0000E8   7C00         MOV       R4,#0x0
   \   0000EA   7D00         MOV       R5,#0x0
   \   0000EC   EE           MOV       A,R6
   \   0000ED   F8           MOV       R0,A
   \   0000EE   7900         MOV       R1,#0x0
   \   0000F0   74..         MOV       A,#??buf & 0xff
   \   0000F2   28           ADD       A,R0
   \   0000F3   FA           MOV       R2,A
   \   0000F4   74..         MOV       A,#(??buf >> 8) & 0xff
   \   0000F6   39           ADDC      A,R1
   \   0000F7   FB           MOV       R3,A
   \   0000F8   12....       LCALL     `??memset::?relay`; Banked call to: memset
   \   0000FB   D0E0         POP       A
   \   0000FD   D0E0         POP       A
    567            CTR_IV[15] = 1; // Счетчик CTR
   \   0000FF   90FFFC       MOV       DPTR,#-0x4
   \   000102   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000105   7401         MOV       A,#0x1
   \   000107   F0           MOVX      @DPTR,A
    568            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
   \   000108                ; Setup parameters for call to function CTR_enc_decrypt
   \   000108   90FFED       MOV       DPTR,#-0x13
   \   00010B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00010E   C082         PUSH      DPL
   \   000110   C083         PUSH      DPH
   \   000112   C0..         PUSH      ?V4
   \   000114   C0..         PUSH      ?V5
   \   000116   EF           MOV       A,R7
   \   000117   F9           MOV       R1,A
   \   000118   E5..         MOV       A,?V0
   \   00011A   FA           MOV       R2,A
   \   00011B   7B00         MOV       R3,#0x0
   \   00011D   74..         MOV       A,#??buf & 0xff
   \   00011F   2A           ADD       A,R2
   \   000120   FC           MOV       R4,A
   \   000121   74..         MOV       A,#(??buf >> 8) & 0xff
   \   000123   3B           ADDC      A,R3
   \   000124   FD           MOV       R5,A
   \   000125   E5..         MOV       A,?V0
   \   000127   FA           MOV       R2,A
   \   000128   7B00         MOV       R3,#0x0
   \   00012A   74..         MOV       A,#??buf & 0xff
   \   00012C   2A           ADD       A,R2
   \   00012D   FA           MOV       R2,A
   \   00012E   74..         MOV       A,#(??buf >> 8) & 0xff
   \   000130   3B           ADDC      A,R3
   \   000131   FB           MOV       R3,A
   \   000132   C2F0         CLR       B.0
   \   000134   12....       LCALL     `??CTR_enc_decrypt::?relay`; Banked call to: CTR_enc_decrypt
   \   000137   74FC         MOV       A,#-0x4
   \   000139   12....       LCALL     ?DEALLOC_EXT_STACK8
    569            
    570            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    571            CBCMAC_buf_encrypt(dlen, key, new_mac);
   \   00013C                ; Setup parameters for call to function CBCMAC_buf_encrypt
   \   00013C   90FFDD       MOV       DPTR,#-0x23
   \   00013F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000142   AC82         MOV       R4,DPL
   \   000144   AD83         MOV       R5,DPH
   \   000146   AA..         MOV       R2,?V4
   \   000148   AB..         MOV       R3,?V5
   \   00014A   EE           MOV       A,R6
   \   00014B   F9           MOV       R1,A
   \   00014C   12....       LCALL     `??CBCMAC_buf_encrypt::?relay`; Banked call to: CBCMAC_buf_encrypt
    572            
    573            // Проверяем что маки совпадают, значит дешифровано верно
    574            bool mac_equal = true;
   \   00014F   D2..         SETB      ?VB.0
    575            for (uint8_t i = 0 ; i < lm ; i++)
   \   000151   7A00         MOV       R2,#0x0
   \   000153   EA           MOV       A,R2
   \   000154   C3           CLR       C
   \   000155   95..         SUBB      A,?V1
   \   000157   5030         JNC       ??AES_CCMDecrypt_2
    576            {
    577              if (mac[i] != new_mac[i])
   \   000159   EA           MOV       A,R2
   \   00015A   F8           MOV       R0,A
   \   00015B   7900         MOV       R1,#0x0
   \   00015D   90FFCD       MOV       DPTR,#-0x33
   \   000160   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000163   E582         MOV       A,DPL
   \   000165   28           ADD       A,R0
   \   000166   F582         MOV       DPL,A
   \   000168   E583         MOV       A,DPH
   \   00016A   39           ADDC      A,R1
   \   00016B   F583         MOV       DPH,A
   \   00016D   E0           MOVX      A,@DPTR
   \   00016E   FB           MOV       R3,A
   \   00016F   EA           MOV       A,R2
   \   000170   F8           MOV       R0,A
   \   000171   7900         MOV       R1,#0x0
   \   000173   90FFDD       MOV       DPTR,#-0x23
   \   000176   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000179   E582         MOV       A,DPL
   \   00017B   28           ADD       A,R0
   \   00017C   F582         MOV       DPL,A
   \   00017E   E583         MOV       A,DPH
   \   000180   39           ADDC      A,R1
   \   000181   F583         MOV       DPH,A
   \   000183   E0           MOVX      A,@DPTR
   \   000184   6B           XRL       A,R3
   \   000185   6002         JZ        ??AES_CCMDecrypt_2
    578              mac_equal = false;
   \   000187   C2..         CLR       ?VB.0
    579              break;
    580            }
    581            
    582            // Выходим если MACи не совпали  
    583            if (!mac_equal)
   \                     ??AES_CCMDecrypt_2:
   \   000189   A2..         MOV       C,?VB.0
   \   00018B   4003         JC        ??AES_CCMDecrypt_3
    584              return false;
   \   00018D   C3           CLR       C
   \   00018E   802C         SJMP      ??AES_CCMDecrypt_4
    585            
    586            // Копируем  расшифрованные данные
    587            memcpy(&src[f], &buf[ds], c); 
   \                     ??AES_CCMDecrypt_3:
   \   000190                ; Setup parameters for call to function memcpy
   \   000190   EF           MOV       A,R7
   \   000191   F582         MOV       DPL,A
   \   000193   758300       MOV       DPH,#0x0
   \   000196   C082         PUSH      DPL
   \   000198   C083         PUSH      DPH
   \   00019A   E5..         MOV       A,?V0
   \   00019C   F8           MOV       R0,A
   \   00019D   7900         MOV       R1,#0x0
   \   00019F   74..         MOV       A,#??buf & 0xff
   \   0001A1   28           ADD       A,R0
   \   0001A2   FC           MOV       R4,A
   \   0001A3   74..         MOV       A,#(??buf >> 8) & 0xff
   \   0001A5   39           ADDC      A,R1
   \   0001A6   FD           MOV       R5,A
   \   0001A7   E5..         MOV       A,?V2
   \   0001A9   F8           MOV       R0,A
   \   0001AA   7900         MOV       R1,#0x0
   \   0001AC   E5..         MOV       A,?V6
   \   0001AE   28           ADD       A,R0
   \   0001AF   FA           MOV       R2,A
   \   0001B0   E5..         MOV       A,?V7
   \   0001B2   39           ADDC      A,R1
   \   0001B3   FB           MOV       R3,A
   \   0001B4   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   0001B7   D0E0         POP       A
   \   0001B9   D0E0         POP       A
    588            return true;
   \   0001BB   D3           SETB      C
   \                     ??AES_CCMDecrypt_4:
   \   0001BC   74CE         MOV       A,#-0x32
   \   0001BE   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001C1   7F08         MOV       R7,#0x8
   \   0001C3   02....       LJMP      ?BANKED_LEAVE_SP
    589          }
E:\Neocore\Hardware\STACK_CORE_SRC\cpu.c
      1          #include "action_manager.h"
      2          #include "ioCC2530.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          static void HW_Init(void);   
      9           

   \                                 In  segment XDATA_I, align 1, keep-with-next
     10          module_s CPU_MODULE = {ALIAS(HW_Init)};
   \                     CPU_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for CPU_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     11          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     12          static void HW_Init(void){
   \                     ??HW_Init_2:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     13            /* Сбрасываем бит OSC32K, будет выбран 32.768 кварц */
     14            CLKCONCMD &= ~(1<<7); 
   \   000000   53C67F       ANL       0xc6,#0x7f
     15            /* Ждем пока бит не станет 0 */
     16            while (CLKCONSTA & (1<<7)); 
   \                     ??HW_Init_8:
   \   000003   E59E         MOV       A,0x9e
   \   000005   A2E7         MOV       C,0xE0 /* A   */.7
   \   000007   40FA         JC        ??HW_Init_8
     17            /* Переходим на 32 Мгц */
     18            CLKCONCMD = 0;// (1<<3);
   \   000009   75C600       MOV       0xc6,#0x0
     19            while (CLKCONSTA&(1<<6));
   \                     ??HW_Init_9:
   \   00000C   E59E         MOV       A,0x9e
   \   00000E   A2E6         MOV       C,0xE0 /* A   */.6
   \   000010   40FA         JC        ??HW_Init_9
     20            EA = 1;
   \   000012   D2AF         SETB      0xa8.7
     21          };  
   \   000014   02....       LJMP      ?BRET
   \   000017                REQUIRE CLKCONCMD
   \   000017                REQUIRE CLKCONSTA
   \   000017                REQUIRE _A_IEN0
E:\Neocore\Hardware\STACK_CORE_SRC\debug.c
      1          #include "debug.h"
      2          #include "action_manager.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          static void HW_Init(void);  
      9          static void uart_init(void);
     10           

   \                                 In  segment XDATA_I, align 1, keep-with-next
     11          module_s DBG_MODULE = {ALIAS(HW_Init)};
   \                     DBG_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for DBG_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     12          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     13          static void HW_Init(void){
   \                     ??HW_Init_3:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     14          #ifndef DEBUG
     15            return;
     16          #endif
     17          #ifdef PRINT_TO_TERMINAL  
     18            uart_init();
   \   000000                ; Setup parameters for call to function uart_init
   \   000000   12....       LCALL     `??uart_init::?relay`; Banked call to: uart_init
     19          #endif
     20          #ifdef SIG_DEBUG
     21            P1DIR |=0x01;
   \   000003   43FE01       ORL       0xfe,#0x1
     22            P1_0 |= 0x01;  
   \   000006   D290         SETB      0x90.0
     23          #endif
     24          };  
   \   000008   02....       LJMP      ?BRET
   \   00000B                REQUIRE P1DIR
   \   00000B                REQUIRE _A_P1
     25          
     26          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     27          void DBG_CORE_HALT(void){
   \                     DBG_CORE_HALT:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     28            while(1);
   \                     ??DBG_CORE_HALT_0:
   \   000000   80FE         SJMP      ??DBG_CORE_HALT_0
     29          }
     30          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     31          void DBG_CORE_FAULT(void){
   \                     DBG_CORE_FAULT:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     32            while(1);
   \                     ??DBG_CORE_FAULT_0:
   \   000000   80FE         SJMP      ??DBG_CORE_FAULT_0
     33          }
     34          
     35          // Настройка порта uart для отладки

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     36          static void uart_init(void){
   \                     ??uart_init:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     37            // Выбор расположения UART на выводах
     38            char U0CFG = 0; // 0={TX=P0_3, RX=P0_2
   \   000000   7800         MOV       R0,#0x0
     39            PERCFG |= (U0CFG<<0); 
   \   000002   E8           MOV       A,R0
   \   000003   42F1         ORL       0xf1,A
     40            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     41            U0CSR = (1<<7); // Выбираем режим uart  
   \   000005   758680       MOV       0x86,#-0x80
     42            // Настройка скорости передачи данных на 2М  
     43            U0BAUD = 0;  // табличные значения из pdf
   \   000008   75C200       MOV       0xc2,#0x0
     44            U0GCR =  16;
   \   00000B   75C510       MOV       0xc5,#0x10
     45            // Включаем альтернативные функции выводов
     46            P0SEL = (1<<2)|(1<<3);
   \   00000E   75F30C       MOV       0xf3,#0xc
     47            U0CSR |= (1<<6);
   \   000011   438640       ORL       0x86,#0x40
     48          }
   \   000014   02....       LJMP      ?BRET
   \   000017                REQUIRE PERCFG
   \   000017                REQUIRE U0CSR
   \   000017                REQUIRE U0BAUD
   \   000017                REQUIRE U0GCR
   \   000017                REQUIRE P0SEL
     49          
     50          #ifdef PRINT_TO_TERMINAL 
     51          #include <yfuns.h>
     52          _STD_BEGIN
     53          #pragma module_name = "?__write"
     54          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     55          int MyLowLevelPutchar(int x){
   \                     MyLowLevelPutchar:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     56            while( U0CSR&(1<<0));
   \                     ??MyLowLevelPutchar_0:
   \   000000   E586         MOV       A,0x86
   \   000002   A2E0         MOV       C,0xE0 /* A   */.0
   \   000004   40FA         JC        ??MyLowLevelPutchar_0
     57            U0DBUF = x;
   \   000006   EA           MOV       A,R2
   \   000007   F5C1         MOV       0xc1,A
     58            return x;
   \   000009   02....       LJMP      ?BRET
   \   00000C                REQUIRE U0CSR
   \   00000C                REQUIRE U0DBUF
     59          }
     60          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     61          size_t __write(int handle, const unsigned char * buffer, size_t size){
   \                     __write:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V6,R2
   \   000007   8B..         MOV       ?V7,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   \   00000D   90FFEF       MOV       DPTR,#-0x11
   \   000010   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F5..         MOV       ?V2,A
   \   000016   A3           INC       DPTR
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F5..         MOV       ?V3,A
     62            /* Remove the #if #endif pair to enable the implementation */
     63            size_t nChars = 0;
   \   00001A   75..00       MOV       ?V0,#0x0
   \   00001D   75..00       MOV       ?V1,#0x0
     64            if (buffer == 0)  {
   \   000020   EE           MOV       A,R6
   \   000021   4F           ORL       A,R7
   \   000022   7006         JNZ       ??__write_0
     65              return 0;
   \   000024   7A00         MOV       R2,#0x0
   \   000026   7B00         MOV       R3,#0x0
   \   000028   806E         SJMP      ??__write_1
     66            }
     67            /* This template only writes to "standard out" and "standard err",
     68             * for all other file handles it returns failure. */
     69            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)  {
   \                     ??__write_0:
   \   00002A   7401         MOV       A,#0x1
   \   00002C   65..         XRL       A,?V6
   \   00002E   7004         JNZ       ??__write_2
   \   000030   7400         MOV       A,#0x0
   \   000032   65..         XRL       A,?V7
   \                     ??__write_2:
   \   000034   6012         JZ        ??__write_3
   \   000036   7402         MOV       A,#0x2
   \   000038   65..         XRL       A,?V6
   \   00003A   7004         JNZ       ??__write_4
   \   00003C   7400         MOV       A,#0x0
   \   00003E   65..         XRL       A,?V7
   \                     ??__write_4:
   \   000040   6006         JZ        ??__write_3
     70              return _LLIO_ERROR;
   \   000042   7AFF         MOV       R2,#-0x1
   \   000044   7BFF         MOV       R3,#-0x1
   \   000046   8050         SJMP      ??__write_1
     71            }
     72          
     73            for (/* Empty */; size != 0; --size){
   \                     ??__write_3:
   \   000048   E5..         MOV       A,?V2
   \   00004A   45..         ORL       A,?V3
   \   00004C   6046         JZ        ??__write_5
     74              if (MyLowLevelPutchar(*buffer++) < 0){
   \   00004E                ; Setup parameters for call to function MyLowLevelPutchar
   \   00004E   8E82         MOV       DPL,R6
   \   000050   8F83         MOV       DPH,R7
   \   000052   E0           MOVX      A,@DPTR
   \   000053   FA           MOV       R2,A
   \   000054   7B00         MOV       R3,#0x0
   \   000056   12....       LCALL     `??MyLowLevelPutchar::?relay`; Banked call to: MyLowLevelPutchar
   \   000059   8A..         MOV       ?V4,R2
   \   00005B   8B..         MOV       ?V5,R3
   \   00005D   A8..         MOV       R0,?V4
   \   00005F   A9..         MOV       R1,?V5
   \   000061   8E82         MOV       DPL,R6
   \   000063   8F83         MOV       DPH,R7
   \   000065   A3           INC       DPTR
   \   000066   AE82         MOV       R6,DPL
   \   000068   AF83         MOV       R7,DPH
   \   00006A   C3           CLR       C
   \   00006B   E8           MOV       A,R0
   \   00006C   9400         SUBB      A,#0x0
   \   00006E   E9           MOV       A,R1
   \   00006F   9400         SUBB      A,#0x0
   \   000071   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000073   65D0         XRL       A,PSW
   \   000075   33           RLC       A
   \   000076   5006         JNC       ??__write_6
     75                return _LLIO_ERROR;
   \   000078   7AFF         MOV       R2,#-0x1
   \   00007A   7BFF         MOV       R3,#-0x1
   \   00007C   801A         SJMP      ??__write_1
     76              }
     77              ++nChars;
   \                     ??__write_6:
   \   00007E   05..         INC       ?V0
   \   000080   E5..         MOV       A,?V0
   \   000082   7002         JNZ       ??__write_7
   \   000084   05..         INC       ?V1
     78            }
   \                     ??__write_7:
   \   000086   E5..         MOV       A,?V2
   \   000088   24FF         ADD       A,#-0x1
   \   00008A   F5..         MOV       ?V2,A
   \   00008C   E5..         MOV       A,?V3
   \   00008E   34FF         ADDC      A,#-0x1
   \   000090   F5..         MOV       ?V3,A
   \   000092   80B4         SJMP      ??__write_3
     79            return nChars;
   \                     ??__write_5:
   \   000094   AA..         MOV       R2,?V0
   \   000096   AB..         MOV       R3,?V1
   \                     ??__write_1:
   \   000098   7F08         MOV       R7,#0x8
   \   00009A   02....       LJMP      ?BANKED_LEAVE_SP
     80          }
     81          _STD_END
     82          
     83          #endif
     84          
E:\Neocore\Hardware\STACK_CORE_SRC\dma.c
      1          #include "dma.h"
      2          #include "ioCC2530.h"
      3          #include "action_manager.h"
      4          
      5          static void HW_Init(void);

   \                                 In  segment XDATA_I, align 1, keep-with-next
      6          module_s DMA_MODULE = {ALIAS(HW_Init)};
   \                     DMA_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for DMA_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
      7          
      8            

   \                                 In  segment XDATA_Z, align 1, keep-with-next
      9          DMA_s DMA_CH[5];
   \                     DMA_CH:
   \   000000                DS 40
   \   000028                REQUIRE __INIT_XDATA_Z
     10          
     11          /**
     12          @brief Настройка DMA каналов.
     13          @detail Согласно документации каналы 1-4 идут последовательно
     14          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     15          static void HW_Init(void){
   \                     ??HW_Init_4:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     16              // Настроим канал 0 DMA для загрузки данных в AES
     17            uint16_t CONF_ADDR = (uint16_t)&DMA_CH[0];
   \   000000   78..         MOV       R0,#DMA_CH & 0xff
   \   000002   79..         MOV       R1,#(DMA_CH >> 8) & 0xff
     18            DMA0CFGH = CONF_ADDR >> 8;
   \   000004   E8           MOV       A,R0
   \   000005   FA           MOV       R2,A
   \   000006   E9           MOV       A,R1
   \   000007   FB           MOV       R3,A
   \   000008   E4           CLR       A
   \   000009   CB           XCH       A,R3
   \   00000A   FA           MOV       R2,A
   \   00000B   EA           MOV       A,R2
   \   00000C   F5D5         MOV       0xd5,A
     19            DMA0CFGL = CONF_ADDR & 0xFF;
   \   00000E   E8           MOV       A,R0
   \   00000F   F5D4         MOV       0xd4,A
     20            
     21            // Настроим канал 1 DMA для выгрузки данных из AES
     22            CONF_ADDR = (uint16_t)&DMA_CH[1];
   \   000011   78..         MOV       R0,#(DMA_CH + 8) & 0xff
   \   000013   79..         MOV       R1,#((DMA_CH + 8) >> 8) & 0xff
     23            DMA1CFGH = CONF_ADDR >> 8;
   \   000015   E8           MOV       A,R0
   \   000016   FA           MOV       R2,A
   \   000017   E9           MOV       A,R1
   \   000018   FB           MOV       R3,A
   \   000019   E4           CLR       A
   \   00001A   CB           XCH       A,R3
   \   00001B   FA           MOV       R2,A
   \   00001C   EA           MOV       A,R2
   \   00001D   F5D3         MOV       0xd3,A
     24            DMA1CFGL = CONF_ADDR & 0xFF;
   \   00001F   E8           MOV       A,R0
   \   000020   F5D2         MOV       0xd2,A
     25          }
   \   000022   02....       LJMP      ?BRET
   \   000025                REQUIRE DMA0CFGH
   \   000025                REQUIRE DMA0CFGL
   \   000025                REQUIRE DMA1CFGH
   \   000025                REQUIRE DMA1CFGL
E:\Neocore\Hardware\STACK_CORE_SRC\frame.c
      1          #include "action_manager.h"
      2          #include "frame.h"
      3          #include "debug.h"
      4          #include "global.h"
      5          #include "mem_utils.h"
      6          #include "mem_slots.h"
      7          
      8          /**
      9          @file Статическое хранение принятых пакетов
     10          */
     11          
     12          static void SW_Init(void); 
     13          

   \                                 In  segment XDATA_I, align 1, keep-with-next
     14          module_s FR_MODULE = {ALIAS(SW_Init)};
   \                     FR_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for FR_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     15          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     16          static void SW_Init(void){ 
   \                     ??SW_Init_1:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     17          }; 
   \   000000   02....       LJMP      ?BRET
     18          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     19          struct frame* FR_create(){
   \                     FR_create:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     20            return (struct frame*)SL_alloc();
   \   000000                ; Setup parameters for call to function SL_alloc
   \   000000   12....       LCALL     `??SL_alloc::?relay`; Banked call to: SL_alloc
   \   000003   02....       LJMP      ?BRET
     21          };
     22          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     23          bool FR_delete(struct frame *frame){
   \                     FR_delete:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
   \   000006   EA           MOV       A,R2
   \   000007   FE           MOV       R6,A
   \   000008   EB           MOV       A,R3
   \   000009   FF           MOV       R7,A
     24            return SL_free((char*)frame);
   \   00000A                ; Setup parameters for call to function SL_free
   \   00000A   EE           MOV       A,R6
   \   00000B   FA           MOV       R2,A
   \   00000C   EF           MOV       A,R7
   \   00000D   FB           MOV       R3,A
   \   00000E   12....       LCALL     `??SL_free::?relay`; Banked call to: SL_free
   \   000011   D0E0         POP       A
   \   000013   FF           MOV       R7,A
   \   000014   D0E0         POP       A
   \   000016   FE           MOV       R6,A
   \   000017   02....       LJMP      ?BRET
     25          }
     26          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     27          bool FR_add_header(struct frame* frame ,void *head, char len){
   \                     FR_add_header:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   7405         MOV       A,#0x5
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 10
   \   000005   740A         MOV       A,#0xa
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   8C..         MOV       ?V2,R4
   \   000010   8D..         MOV       ?V3,R5
   \   000012   89..         MOV       ?V4,R1
     28            int new_len = frame->len + len;
   \   000014   85..82       MOV       DPL,?V0
   \   000017   85..83       MOV       DPH,?V1
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   FA           MOV       R2,A
   \   00001C   7B00         MOV       R3,#0x0
   \   00001E   E5..         MOV       A,?V4
   \   000020   F8           MOV       R0,A
   \   000021   7900         MOV       R1,#0x0
   \   000023   EA           MOV       A,R2
   \   000024   28           ADD       A,R0
   \   000025   FE           MOV       R6,A
   \   000026   EB           MOV       A,R3
   \   000027   39           ADDC      A,R1
   \   000028   FF           MOV       R7,A
     29            if (!(new_len < MAX_PAYLOAD_SIZE))
   \   000029   C3           CLR       C
   \   00002A   EE           MOV       A,R6
   \   00002B   947F         SUBB      A,#0x7f
   \   00002D   EF           MOV       A,R7
   \   00002E   9400         SUBB      A,#0x0
   \   000030   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000032   65D0         XRL       A,PSW
   \   000034   33           RLC       A
   \   000035   4004         JC        ??FR_add_header_0
     30              return false;
   \   000037   C3           CLR       C
   \   000038   02....       LJMP      ??FR_add_header_1 & 0xFFFF
     31            
     32            // Сдвинем данные на размер вставки при необходимости
     33            if (frame->len != 0)
   \                     ??FR_add_header_0:
   \   00003B   85..82       MOV       DPL,?V0
   \   00003E   85..83       MOV       DPH,?V1
   \   000041   E0           MOVX      A,@DPTR
   \   000042   604D         JZ        ??FR_add_header_2
     34              MEMCPY(&frame->payload[len], frame->payload, len);
   \   000044   E5..         MOV       A,?V4
   \   000046   F8           MOV       R0,A
   \   000047   7900         MOV       R1,#0x0
   \   000049   E5..         MOV       A,?V0
   \   00004B   28           ADD       A,R0
   \   00004C   F8           MOV       R0,A
   \   00004D   E5..         MOV       A,?V1
   \   00004F   39           ADDC      A,R1
   \   000050   F9           MOV       R1,A
   \   000051   E8           MOV       A,R0
   \   000052   2415         ADD       A,#0x15
   \   000054   F8           MOV       R0,A
   \   000055   5001         JNC       ??FR_add_header_3
   \   000057   09           INC       R1
   \                     ??FR_add_header_3:
   \   000058   90FFF5       MOV       DPTR,#-0xb
   \   00005B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00005E   E8           MOV       A,R0
   \   00005F   F0           MOVX      @DPTR,A
   \   000060   A3           INC       DPTR
   \   000061   E9           MOV       A,R1
   \   000062   F0           MOVX      @DPTR,A
   \   000063   E5..         MOV       A,?V0
   \   000065   2415         ADD       A,#0x15
   \   000067   F8           MOV       R0,A
   \   000068   E4           CLR       A
   \   000069   35..         ADDC      A,?V1
   \   00006B   F9           MOV       R1,A
   \   00006C   90FFF7       MOV       DPTR,#-0x9
   \   00006F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000072   E8           MOV       A,R0
   \   000073   F0           MOVX      @DPTR,A
   \   000074   A3           INC       DPTR
   \   000075   E9           MOV       A,R1
   \   000076   F0           MOVX      @DPTR,A
   \   000077   E5..         MOV       A,?V4
   \   000079   C0E0         PUSH      A
   \   00007B   90FFF8       MOV       DPTR,#-0x8
   \   00007E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000081   D0E0         POP       A
   \   000083   F0           MOVX      @DPTR,A
   \   000084                ; Setup parameters for call to function MEM_memcpy
   \   000084   90FFF5       MOV       DPTR,#-0xb
   \   000087   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00008A   AA82         MOV       R2,DPL
   \   00008C   AB83         MOV       R3,DPH
   \   00008E   12....       LCALL     `??MEM_memcpy::?relay`; Banked call to: MEM_memcpy
     35            
     36            // Скопируем новые данные
     37            MEMCPY(frame->payload, head, len);
   \                     ??FR_add_header_2:
   \   000091   E5..         MOV       A,?V0
   \   000093   2415         ADD       A,#0x15
   \   000095   F8           MOV       R0,A
   \   000096   E4           CLR       A
   \   000097   35..         ADDC      A,?V1
   \   000099   F9           MOV       R1,A
   \   00009A   90FFFA       MOV       DPTR,#-0x6
   \   00009D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A0   E8           MOV       A,R0
   \   0000A1   F0           MOVX      @DPTR,A
   \   0000A2   A3           INC       DPTR
   \   0000A3   E9           MOV       A,R1
   \   0000A4   F0           MOVX      @DPTR,A
   \   0000A5   90FFFC       MOV       DPTR,#-0x4
   \   0000A8   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000AB   E5..         MOV       A,?V2
   \   0000AD   F0           MOVX      @DPTR,A
   \   0000AE   A3           INC       DPTR
   \   0000AF   E5..         MOV       A,?V3
   \   0000B1   F0           MOVX      @DPTR,A
   \   0000B2   E5..         MOV       A,?V4
   \   0000B4   C0E0         PUSH      A
   \   0000B6   90FFFD       MOV       DPTR,#-0x3
   \   0000B9   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000BC   D0E0         POP       A
   \   0000BE   F0           MOVX      @DPTR,A
   \   0000BF                ; Setup parameters for call to function MEM_memcpy
   \   0000BF   90FFFA       MOV       DPTR,#-0x6
   \   0000C2   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000C5   AA82         MOV       R2,DPL
   \   0000C7   AB83         MOV       R3,DPH
   \   0000C9   12....       LCALL     `??MEM_memcpy::?relay`; Banked call to: MEM_memcpy
     38            frame->len = new_len;
   \   0000CC   EE           MOV       A,R6
   \   0000CD   C0E0         PUSH      A
   \   0000CF   85..82       MOV       DPL,?V0
   \   0000D2   85..83       MOV       DPH,?V1
   \   0000D5   D0E0         POP       A
   \   0000D7   F0           MOVX      @DPTR,A
     39            return true;
   \   0000D8   D3           SETB      C
   \                     ??FR_add_header_1:
   \   0000D9   74F6         MOV       A,#-0xa
   \   0000DB   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000DE   7F05         MOV       R7,#0x5
   \   0000E0   02....       LJMP      ?BANKED_LEAVE_SP
     40          };
     41          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     42          bool FR_del_header(struct frame* frame, char len){
   \                     FR_del_header:
   \   000000                REQUIRE ?V0
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006   C0..         PUSH      ?V0
   \   000008                ; Saved register size: 3
   \   000008                ; Auto size: 9
   \   000008   7409         MOV       A,#0x9
   \   00000A   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000D   EA           MOV       A,R2
   \   00000E   FE           MOV       R6,A
   \   00000F   EB           MOV       A,R3
   \   000010   FF           MOV       R7,A
   \   000011   89..         MOV       ?V0,R1
     43            if (len == 0 || len > frame->len )
   \   000013   E5..         MOV       A,?V0
   \   000015   600A         JZ        ??FR_del_header_0
   \   000017   8E82         MOV       DPL,R6
   \   000019   8F83         MOV       DPH,R7
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   C3           CLR       C
   \   00001D   95..         SUBB      A,?V0
   \   00001F   5004         JNC       ??FR_del_header_1
     44              return false;
   \                     ??FR_del_header_0:
   \   000021   C3           CLR       C
   \   000022   02....       LJMP      ??FR_del_header_2 & 0xFFFF
     45            MEMCPY(frame->payload, &frame->payload[len], len);
   \                     ??FR_del_header_1:
   \   000025   EE           MOV       A,R6
   \   000026   2415         ADD       A,#0x15
   \   000028   F8           MOV       R0,A
   \   000029   E4           CLR       A
   \   00002A   3F           ADDC      A,R7
   \   00002B   F9           MOV       R1,A
   \   00002C   90FFF6       MOV       DPTR,#-0xa
   \   00002F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000032   E8           MOV       A,R0
   \   000033   F0           MOVX      @DPTR,A
   \   000034   A3           INC       DPTR
   \   000035   E9           MOV       A,R1
   \   000036   F0           MOVX      @DPTR,A
   \   000037   E5..         MOV       A,?V0
   \   000039   F8           MOV       R0,A
   \   00003A   7900         MOV       R1,#0x0
   \   00003C   EE           MOV       A,R6
   \   00003D   28           ADD       A,R0
   \   00003E   F8           MOV       R0,A
   \   00003F   EF           MOV       A,R7
   \   000040   39           ADDC      A,R1
   \   000041   F9           MOV       R1,A
   \   000042   E8           MOV       A,R0
   \   000043   2415         ADD       A,#0x15
   \   000045   F8           MOV       R0,A
   \   000046   5001         JNC       ??FR_del_header_3
   \   000048   09           INC       R1
   \                     ??FR_del_header_3:
   \   000049   90FFF8       MOV       DPTR,#-0x8
   \   00004C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00004F   E8           MOV       A,R0
   \   000050   F0           MOVX      @DPTR,A
   \   000051   A3           INC       DPTR
   \   000052   E9           MOV       A,R1
   \   000053   F0           MOVX      @DPTR,A
   \   000054   E5..         MOV       A,?V0
   \   000056   C0E0         PUSH      A
   \   000058   90FFF9       MOV       DPTR,#-0x7
   \   00005B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00005E   D0E0         POP       A
   \   000060   F0           MOVX      @DPTR,A
   \   000061                ; Setup parameters for call to function MEM_memcpy
   \   000061   90FFF6       MOV       DPTR,#-0xa
   \   000064   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000067   AA82         MOV       R2,DPL
   \   000069   AB83         MOV       R3,DPH
   \   00006B   12....       LCALL     `??MEM_memcpy::?relay`; Banked call to: MEM_memcpy
     46            
     47            #ifdef FRAME_FOOTER_DEL
     48            MEMSET(&frame->payload[len], 0, len);
   \   00006E   90....       MOV       DPTR,#`?<Constant {(char *)0, 0, 0}>`
   \   000071   C082         PUSH      DPL
   \   000073   C083         PUSH      DPH
   \   000075   90FFF9       MOV       DPTR,#-0x7
   \   000078   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00007B   AC82         MOV       R4,DPL
   \   00007D   AD83         MOV       R5,DPH
   \   00007F   D083         POP       DPH
   \   000081   D082         POP       DPL
   \   000083   7404         MOV       A,#0x4
   \   000085   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   000088   E5..         MOV       A,?V0
   \   00008A   F8           MOV       R0,A
   \   00008B   7900         MOV       R1,#0x0
   \   00008D   EE           MOV       A,R6
   \   00008E   28           ADD       A,R0
   \   00008F   F8           MOV       R0,A
   \   000090   EF           MOV       A,R7
   \   000091   39           ADDC      A,R1
   \   000092   F9           MOV       R1,A
   \   000093   E8           MOV       A,R0
   \   000094   2415         ADD       A,#0x15
   \   000096   F8           MOV       R0,A
   \   000097   5001         JNC       ??FR_del_header_4
   \   000099   09           INC       R1
   \                     ??FR_del_header_4:
   \   00009A   90FFFB       MOV       DPTR,#-0x5
   \   00009D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A0   E8           MOV       A,R0
   \   0000A1   F0           MOVX      @DPTR,A
   \   0000A2   A3           INC       DPTR
   \   0000A3   E9           MOV       A,R1
   \   0000A4   F0           MOVX      @DPTR,A
   \   0000A5   E5..         MOV       A,?V0
   \   0000A7   C0E0         PUSH      A
   \   0000A9   90FFFC       MOV       DPTR,#-0x4
   \   0000AC   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000AF   D0E0         POP       A
   \   0000B1   F0           MOVX      @DPTR,A
   \   0000B2                ; Setup parameters for call to function MEM_memset
   \   0000B2   90FFFB       MOV       DPTR,#-0x5
   \   0000B5   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000B8   AA82         MOV       R2,DPL
   \   0000BA   AB83         MOV       R3,DPH
   \   0000BC   12....       LCALL     `??MEM_memset::?relay`; Banked call to: MEM_memset
     49            #endif
     50            
     51            frame->len = frame->len - len;;
   \   0000BF   8E82         MOV       DPL,R6
   \   0000C1   8F83         MOV       DPH,R7
   \   0000C3   E0           MOVX      A,@DPTR
   \   0000C4   C3           CLR       C
   \   0000C5   95..         SUBB      A,?V0
   \   0000C7   F0           MOVX      @DPTR,A
     52            return true;
   \   0000C8   D3           SETB      C
   \                     ??FR_del_header_2:
   \   0000C9   74F7         MOV       A,#-0x9
   \   0000CB   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000CE   D0..         POP       ?V0
   \   0000D0   D0E0         POP       A
   \   0000D2   FF           MOV       R7,A
   \   0000D3   D0E0         POP       A
   \   0000D5   FE           MOV       R6,A
   \   0000D6   02....       LJMP      ?BRET
     53          }

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {(char *)0, 0, 0}>`:
   \   000000   0000         DW 0H
   \   000002   00           DB 0
   \   000003   00           DB 0
     54          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     55          int FR_busy(){
   \                     FR_busy:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     56            return SL_busy();
   \   000000                ; Setup parameters for call to function SL_busy
   \   000000   12....       LCALL     `??SL_busy::?relay`; Banked call to: SL_busy
   \   000003   02....       LJMP      ?BRET
     57          }
     58          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     59          int FR_available(){
   \                     FR_available:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     60            return SL_available();
   \   000000                ; Setup parameters for call to function SL_available
   \   000000   12....       LCALL     `??SL_available::?relay`; Banked call to: SL_available
   \   000003   02....       LJMP      ?BRET
     61          };
E:\Neocore\Hardware\STACK_CORE_SRC\led.c
      1          #include "action_manager.h"
      2          
      3          static void HW_Init(void);
      4          static void SW_Init(void);
      5          static void Cold_Start(void);
      6          static void Hot_Start(void);
      7          

   \                                 In  segment XDATA_I, align 1, keep-with-next
      8          module_s LED_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
   \                     LED_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for LED_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
      9            ALIAS(Hot_Start), ALIAS(HW_Init)};
     10          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     11          static void HW_Init(void){};
   \                     ??HW_Init_5:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     12          static void SW_Init(void){};
   \                     ??SW_Init_2:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     13          static void Cold_Start(void){};
   \                     ??Cold_Start:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     14          static void Hot_Start(void){};
   \                     ??Hot_Start:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP      ?BRET
E:\Neocore\Hardware\STACK_CORE_SRC\llc.c
      1          #include "action_manager.h"
      2          #include "buffer.h"
      3          #include "stddef.h"
      4          #include "macros.h"
      5          #include "model.h"
      6          #include "debug.h"
      7          #include "radio.h"
      8          #include "mac.h"
      9          
     10          
     11          #define MAX_SLOTS 50
     12          
     13          #define RX_ALARM (1<<0)
     14          #define TX_ALARM (1<<1)
     15          
     16          static void SW_Init(void);
     17          static void Cold_Start(void);
     18          static void Hot_Start(void);
     19          static void IRQ_Init(void);
     20          

   \                                 In  segment XDATA_I, align 1, keep-with-next
     21          module_s LLC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
   \                     LLC_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for LLC_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     22            ALIAS(Hot_Start), ALIAS(IRQ_Init)};
     23          
     24          struct action{
     25            channel_t rx;
     26            struct frame *frame_tx;
     27          };
     28          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     29          static struct action ACTIONSLOTS[MAX_SLOTS];
   \                     ??ACTIONSLOTS:
   \   000000                DS 150
   \   000096                REQUIRE __INIT_XDATA_Z
     30          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     31          static void IRQ_Init(void){
   \                     ??IRQ_Init_1:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     32            for_each_type(struct action, ACTIONSLOTS, slot){
   \   000000   78..         MOV       R0,#??ACTIONSLOTS & 0xff
   \   000002   79..         MOV       R1,#(??ACTIONSLOTS >> 8) & 0xff
   \                     ??IRQ_Init_3:
   \   000004   C3           CLR       C
   \   000005   E8           MOV       A,R0
   \   000006   94..         SUBB      A,#(??ACTIONSLOTS + 150) & 0xff
   \   000008   E9           MOV       A,R1
   \   000009   94..         SUBB      A,#((??ACTIONSLOTS + 150) >> 8) & 0xff
   \   00000B   501C         JNC       ??IRQ_Init_4
     33              slot->rx = 0;
   \   00000D   8882         MOV       DPL,R0
   \   00000F   8983         MOV       DPH,R1
   \   000011   7400         MOV       A,#0x0
   \   000013   F0           MOVX      @DPTR,A
     34              slot->frame_tx = NULL;
   \   000014   8882         MOV       DPL,R0
   \   000016   8983         MOV       DPH,R1
   \   000018   A3           INC       DPTR
   \   000019   7400         MOV       A,#0x0
   \   00001B   F0           MOVX      @DPTR,A
   \   00001C   A3           INC       DPTR
   \   00001D   7400         MOV       A,#0x0
   \   00001F   F0           MOVX      @DPTR,A
     35            }
   \   000020   E8           MOV       A,R0
   \   000021   2403         ADD       A,#0x3
   \   000023   F8           MOV       R0,A
   \   000024   50DE         JNC       ??IRQ_Init_3
   \   000026   09           INC       R1
   \   000027   80DB         SJMP      ??IRQ_Init_3
     36          };
   \                     ??IRQ_Init_4:
   \   000029   02....       LJMP      ?BRET
     37          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     38          static void SW_Init(void){
   \                     ??SW_Init_3:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     39            for_each_type(struct action, ACTIONSLOTS, slot){
   \   000000   78..         MOV       R0,#??ACTIONSLOTS & 0xff
   \   000002   79..         MOV       R1,#(??ACTIONSLOTS >> 8) & 0xff
   \                     ??SW_Init_12:
   \   000004   C3           CLR       C
   \   000005   E8           MOV       A,R0
   \   000006   94..         SUBB      A,#(??ACTIONSLOTS + 150) & 0xff
   \   000008   E9           MOV       A,R1
   \   000009   94..         SUBB      A,#((??ACTIONSLOTS + 150) >> 8) & 0xff
   \   00000B   501C         JNC       ??SW_Init_13
     40              slot->rx = 0;
   \   00000D   8882         MOV       DPL,R0
   \   00000F   8983         MOV       DPH,R1
   \   000011   7400         MOV       A,#0x0
   \   000013   F0           MOVX      @DPTR,A
     41              slot->frame_tx = NULL;
   \   000014   8882         MOV       DPL,R0
   \   000016   8983         MOV       DPH,R1
   \   000018   A3           INC       DPTR
   \   000019   7400         MOV       A,#0x0
   \   00001B   F0           MOVX      @DPTR,A
   \   00001C   A3           INC       DPTR
   \   00001D   7400         MOV       A,#0x0
   \   00001F   F0           MOVX      @DPTR,A
     42            }
   \   000020   E8           MOV       A,R0
   \   000021   2403         ADD       A,#0x3
   \   000023   F8           MOV       R0,A
   \   000024   50DE         JNC       ??SW_Init_12
   \   000026   09           INC       R1
   \   000027   80DB         SJMP      ??SW_Init_12
     43          };
   \                     ??SW_Init_13:
   \   000029   02....       LJMP      ?BRET
     44          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     45          void LLC_open_slot(timeslot_t ts, channel_t ch){
   \                     LLC_open_slot:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
   \   000006   E9           MOV       A,R1
   \   000007   FE           MOV       R6,A
   \   000008   EA           MOV       A,R2
   \   000009   FF           MOV       R7,A
     46            ASSERT(ts >= 1 && ts < MAX_SLOTS);
   \   00000A   EE           MOV       A,R6
   \   00000B   6006         JZ        ??LLC_open_slot_0
   \   00000D   EE           MOV       A,R6
   \   00000E   C3           CLR       C
   \   00000F   9432         SUBB      A,#0x32
   \   000011   401F         JC        ??LLC_open_slot_1
   \                     ??LLC_open_slot_0:
   \   000013                ; Setup parameters for call to function printf
   \   000013   742E         MOV       A,#0x2e
   \   000015   C0E0         PUSH      A
   \   000017   7400         MOV       A,#0x0
   \   000019   C0E0         PUSH      A
   \   00001B   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   00001D   C0E0         PUSH      A
   \   00001F   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   000021   C0E0         PUSH      A
   \   000023   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_3` & 0xff
   \   000025   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_3` >> 8) & 0xff
   \   000027   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00002A   74FC         MOV       A,#-0x4
   \   00002C   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002F                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002F   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     47            ASSERT(ch >= MIN_CH && ch <= MAX_CH);
   \                     ??LLC_open_slot_1:
   \   000032   EF           MOV       A,R7
   \   000033   C3           CLR       C
   \   000034   940B         SUBB      A,#0xb
   \   000036   4006         JC        ??LLC_open_slot_2
   \   000038   EF           MOV       A,R7
   \   000039   C3           CLR       C
   \   00003A   941D         SUBB      A,#0x1d
   \   00003C   401F         JC        ??LLC_open_slot_3
   \                     ??LLC_open_slot_2:
   \   00003E                ; Setup parameters for call to function printf
   \   00003E   742F         MOV       A,#0x2f
   \   000040   C0E0         PUSH      A
   \   000042   7400         MOV       A,#0x0
   \   000044   C0E0         PUSH      A
   \   000046   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   000048   C0E0         PUSH      A
   \   00004A   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   00004C   C0E0         PUSH      A
   \   00004E   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_3` & 0xff
   \   000050   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_3` >> 8) & 0xff
   \   000052   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000055   74FC         MOV       A,#-0x4
   \   000057   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00005A                ; Setup parameters for call to function DBG_CORE_HALT
   \   00005A   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     48            ACTIONSLOTS[ts].rx = ch;
   \                     ??LLC_open_slot_3:
   \   00005D   EF           MOV       A,R7
   \   00005E   C0E0         PUSH      A
   \   000060   EE           MOV       A,R6
   \   000061   F8           MOV       R0,A
   \   000062   7900         MOV       R1,#0x0
   \   000064   E8           MOV       A,R0
   \   000065   75F003       MOV       B,#0x3
   \   000068   A4           MUL       AB
   \   000069   C8           XCH       A,R0
   \   00006A   AAF0         MOV       R2,B
   \   00006C   75F000       MOV       B,#0x0
   \   00006F   A4           MUL       AB
   \   000070   2A           ADD       A,R2
   \   000071   FA           MOV       R2,A
   \   000072   75F003       MOV       B,#0x3
   \   000075   E9           MOV       A,R1
   \   000076   A4           MUL       AB
   \   000077   2A           ADD       A,R2
   \   000078   F9           MOV       R1,A
   \   000079   74..         MOV       A,#??ACTIONSLOTS & 0xff
   \   00007B   28           ADD       A,R0
   \   00007C   F582         MOV       DPL,A
   \   00007E   74..         MOV       A,#(??ACTIONSLOTS >> 8) & 0xff
   \   000080   39           ADDC      A,R1
   \   000081   F583         MOV       DPH,A
   \   000083   D0E0         POP       A
   \   000085   F0           MOVX      @DPTR,A
     49          }
   \   000086   D0E0         POP       A
   \   000088   FF           MOV       R7,A
   \   000089   D0E0         POP       A
   \   00008B   FE           MOV       R6,A
   \   00008C   02....       LJMP      ?BRET
     50          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     51          void LLC_close_slot(timeslot_t ts){
   \                     LLC_close_slot:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
   \   000003   E9           MOV       A,R1
   \   000004   FE           MOV       R6,A
     52            ASSERT(ts >= 1 && ts < MAX_SLOTS);
   \   000005   EE           MOV       A,R6
   \   000006   6006         JZ        ??LLC_close_slot_0
   \   000008   EE           MOV       A,R6
   \   000009   C3           CLR       C
   \   00000A   9432         SUBB      A,#0x32
   \   00000C   401F         JC        ??LLC_close_slot_1
   \                     ??LLC_close_slot_0:
   \   00000E                ; Setup parameters for call to function printf
   \   00000E   7434         MOV       A,#0x34
   \   000010   C0E0         PUSH      A
   \   000012   7400         MOV       A,#0x0
   \   000014   C0E0         PUSH      A
   \   000016   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   000018   C0E0         PUSH      A
   \   00001A   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   00001C   C0E0         PUSH      A
   \   00001E   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_3` & 0xff
   \   000020   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_3` >> 8) & 0xff
   \   000022   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000025   74FC         MOV       A,#-0x4
   \   000027   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002A                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002A   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     53            ACTIONSLOTS[ts].rx = 0;
   \                     ??LLC_close_slot_1:
   \   00002D   EE           MOV       A,R6
   \   00002E   F8           MOV       R0,A
   \   00002F   7900         MOV       R1,#0x0
   \   000031   E8           MOV       A,R0
   \   000032   75F003       MOV       B,#0x3
   \   000035   A4           MUL       AB
   \   000036   C8           XCH       A,R0
   \   000037   AAF0         MOV       R2,B
   \   000039   75F000       MOV       B,#0x0
   \   00003C   A4           MUL       AB
   \   00003D   2A           ADD       A,R2
   \   00003E   FA           MOV       R2,A
   \   00003F   75F003       MOV       B,#0x3
   \   000042   E9           MOV       A,R1
   \   000043   A4           MUL       AB
   \   000044   2A           ADD       A,R2
   \   000045   F9           MOV       R1,A
   \   000046   74..         MOV       A,#??ACTIONSLOTS & 0xff
   \   000048   28           ADD       A,R0
   \   000049   F582         MOV       DPL,A
   \   00004B   74..         MOV       A,#(??ACTIONSLOTS >> 8) & 0xff
   \   00004D   39           ADDC      A,R1
   \   00004E   F583         MOV       DPH,A
   \   000050   7400         MOV       A,#0x0
   \   000052   F0           MOVX      @DPTR,A
     54          }
   \   000053   D0E0         POP       A
   \   000055   FE           MOV       R6,A
   \   000056   02....       LJMP      ?BRET
     55          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     56          bool LLC_add_tx_frame(struct frame *frame){
   \                     LLC_add_tx_frame:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
   \   000006   EA           MOV       A,R2
   \   000007   FE           MOV       R6,A
   \   000008   EB           MOV       A,R3
   \   000009   FF           MOV       R7,A
     57            ASSERT(frame);
   \   00000A   EE           MOV       A,R6
   \   00000B   4F           ORL       A,R7
   \   00000C   701F         JNZ       ??LLC_add_tx_frame_0
   \   00000E                ; Setup parameters for call to function printf
   \   00000E   7439         MOV       A,#0x39
   \   000010   C0E0         PUSH      A
   \   000012   7400         MOV       A,#0x0
   \   000014   C0E0         PUSH      A
   \   000016   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   000018   C0E0         PUSH      A
   \   00001A   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   00001C   C0E0         PUSH      A
   \   00001E   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_3` & 0xff
   \   000020   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_3` >> 8) & 0xff
   \   000022   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000025   74FC         MOV       A,#-0x4
   \   000027   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002A                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002A   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     58            AES_StreamCoder(true, frame->payload, frame->payload, frame->len);    
   \                     ??LLC_add_tx_frame_0:
   \   00002D                ; Setup parameters for call to function AES_StreamCoder
   \   00002D   8E82         MOV       DPL,R6
   \   00002F   8F83         MOV       DPH,R7
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F9           MOV       R1,A
   \   000033   EE           MOV       A,R6
   \   000034   2415         ADD       A,#0x15
   \   000036   FC           MOV       R4,A
   \   000037   E4           CLR       A
   \   000038   3F           ADDC      A,R7
   \   000039   FD           MOV       R5,A
   \   00003A   EE           MOV       A,R6
   \   00003B   2415         ADD       A,#0x15
   \   00003D   FA           MOV       R2,A
   \   00003E   E4           CLR       A
   \   00003F   3F           ADDC      A,R7
   \   000040   FB           MOV       R3,A
   \   000041   D2F0         SETB      B.0
   \   000043   12....       LCALL     `??AES_StreamCoder::?relay`; Banked call to: AES_StreamCoder
     59            if (BF_push_tx(frame))
   \   000046                ; Setup parameters for call to function BF_push_tx
   \   000046   EE           MOV       A,R6
   \   000047   FA           MOV       R2,A
   \   000048   EF           MOV       A,R7
   \   000049   FB           MOV       R3,A
   \   00004A   12....       LCALL     `??BF_push_tx::?relay`; Banked call to: BF_push_tx
   \   00004D   5003         JNC       ??LLC_add_tx_frame_1
     60              return true;
   \   00004F   D3           SETB      C
   \   000050   8001         SJMP      ??LLC_add_tx_frame_2
     61            return false;
   \                     ??LLC_add_tx_frame_1:
   \   000052   C3           CLR       C
   \                     ??LLC_add_tx_frame_2:
   \   000053   D0E0         POP       A
   \   000055   FF           MOV       R7,A
   \   000056   D0E0         POP       A
   \   000058   FE           MOV       R6,A
   \   000059   02....       LJMP      ?BRET
     62          }
     63          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     64          static void scheduler_tx(void){
   \                     ??scheduler_tx:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
     65            void *cursor = BF_cursor_tx();
   \   000005                ; Setup parameters for call to function BF_cursor_tx
   \   000005   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   000008   8A..         MOV       ?V0,R2
   \   00000A   8B..         MOV       ?V1,R3
   \   00000C   AE..         MOV       R6,?V0
   \   00000E   AF..         MOV       R7,?V1
     66            if (!cursor)
   \   000010   EE           MOV       A,R6
   \   000011   4F           ORL       A,R7
   \   000012   7003         JNZ       $+5
   \   000014   02....       LJMP      ??scheduler_tx_1 & 0xFFFF
     67              return;
     68            
     69            struct frame *frame = NULL;
   \   000017   75..00       MOV       ?V0,#0x0
   \   00001A   75..00       MOV       ?V1,#0x0
     70            while(cursor){
   \                     ??scheduler_tx_2:
   \   00001D   EE           MOV       A,R6
   \   00001E   4F           ORL       A,R7
   \   00001F   7003         JNZ       $+5
   \   000021   02....       LJMP      ??scheduler_tx_1 & 0xFFFF
     71              frame = BF_content(cursor);
   \   000024                ; Setup parameters for call to function BF_content
   \   000024   EE           MOV       A,R6
   \   000025   FA           MOV       R2,A
   \   000026   EF           MOV       A,R7
   \   000027   FB           MOV       R3,A
   \   000028   12....       LCALL     `??BF_content::?relay`; Banked call to: BF_content
   \   00002B   8A..         MOV       ?V2,R2
   \   00002D   8B..         MOV       ?V3,R3
   \   00002F   85....       MOV       ?V0,?V2
   \   000032   85....       MOV       ?V1,?V3
     72              ASSERT(frame->meta.TS != 0);
   \   000035   85..82       MOV       DPL,?V0
   \   000038   85..83       MOV       DPH,?V1
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   E0           MOVX      A,@DPTR
   \   000041   701F         JNZ       ??scheduler_tx_3
   \   000043                ; Setup parameters for call to function printf
   \   000043   7448         MOV       A,#0x48
   \   000045   C0E0         PUSH      A
   \   000047   7400         MOV       A,#0x0
   \   000049   C0E0         PUSH      A
   \   00004B   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   00004D   C0E0         PUSH      A
   \   00004F   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   000051   C0E0         PUSH      A
   \   000053   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_3` & 0xff
   \   000055   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_3` >> 8) & 0xff
   \   000057   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00005A   74FC         MOV       A,#-0x4
   \   00005C   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00005F                ; Setup parameters for call to function DBG_CORE_HALT
   \   00005F   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     73              // Если у нас есть что передавать, берем следующий кадр из буфера
     74              if (ACTIONSLOTS[frame->meta.TS].frame_tx){
   \                     ??scheduler_tx_3:
   \   000062   85..82       MOV       DPL,?V0
   \   000065   85..83       MOV       DPH,?V1
   \   000068   A3           INC       DPTR
   \   000069   A3           INC       DPTR
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   A3           INC       DPTR
   \   00006D   E0           MOVX      A,@DPTR
   \   00006E   F8           MOV       R0,A
   \   00006F   7900         MOV       R1,#0x0
   \   000071   E8           MOV       A,R0
   \   000072   75F003       MOV       B,#0x3
   \   000075   A4           MUL       AB
   \   000076   C8           XCH       A,R0
   \   000077   AAF0         MOV       R2,B
   \   000079   75F000       MOV       B,#0x0
   \   00007C   A4           MUL       AB
   \   00007D   2A           ADD       A,R2
   \   00007E   FA           MOV       R2,A
   \   00007F   75F003       MOV       B,#0x3
   \   000082   E9           MOV       A,R1
   \   000083   A4           MUL       AB
   \   000084   2A           ADD       A,R2
   \   000085   F9           MOV       R1,A
   \   000086   74..         MOV       A,#(??ACTIONSLOTS + 1) & 0xff
   \   000088   28           ADD       A,R0
   \   000089   F582         MOV       DPL,A
   \   00008B   74..         MOV       A,#((??ACTIONSLOTS + 1) >> 8) & 0xff
   \   00008D   39           ADDC      A,R1
   \   00008E   F583         MOV       DPH,A
   \   000090   E0           MOVX      A,@DPTR
   \   000091   F8           MOV       R0,A
   \   000092   A3           INC       DPTR
   \   000093   E0           MOVX      A,@DPTR
   \   000094   F9           MOV       R1,A
   \   000095   E8           MOV       A,R0
   \   000096   49           ORL       A,R1
   \   000097   6012         JZ        ??scheduler_tx_4
     75                cursor = BF_cursor_next(cursor);
   \   000099                ; Setup parameters for call to function BF_cursor_next
   \   000099   EE           MOV       A,R6
   \   00009A   FA           MOV       R2,A
   \   00009B   EF           MOV       A,R7
   \   00009C   FB           MOV       R3,A
   \   00009D   12....       LCALL     `??BF_cursor_next::?relay`; Banked call to: BF_cursor_next
   \   0000A0   8A..         MOV       ?V2,R2
   \   0000A2   8B..         MOV       ?V3,R3
   \   0000A4   AE..         MOV       R6,?V2
   \   0000A6   AF..         MOV       R7,?V3
     76                continue;
   \   0000A8   02....       LJMP      ??scheduler_tx_2 & 0xFFFF
     77              }
     78              ACTIONSLOTS[frame->meta.TS].frame_tx = frame;
   \                     ??scheduler_tx_4:
   \   0000AB   85..82       MOV       DPL,?V0
   \   0000AE   85..83       MOV       DPH,?V1
   \   0000B1   A3           INC       DPTR
   \   0000B2   A3           INC       DPTR
   \   0000B3   A3           INC       DPTR
   \   0000B4   A3           INC       DPTR
   \   0000B5   A3           INC       DPTR
   \   0000B6   E0           MOVX      A,@DPTR
   \   0000B7   F8           MOV       R0,A
   \   0000B8   7900         MOV       R1,#0x0
   \   0000BA   E8           MOV       A,R0
   \   0000BB   75F003       MOV       B,#0x3
   \   0000BE   A4           MUL       AB
   \   0000BF   C8           XCH       A,R0
   \   0000C0   AAF0         MOV       R2,B
   \   0000C2   75F000       MOV       B,#0x0
   \   0000C5   A4           MUL       AB
   \   0000C6   2A           ADD       A,R2
   \   0000C7   FA           MOV       R2,A
   \   0000C8   75F003       MOV       B,#0x3
   \   0000CB   E9           MOV       A,R1
   \   0000CC   A4           MUL       AB
   \   0000CD   2A           ADD       A,R2
   \   0000CE   F9           MOV       R1,A
   \   0000CF   74..         MOV       A,#(??ACTIONSLOTS + 1) & 0xff
   \   0000D1   28           ADD       A,R0
   \   0000D2   F582         MOV       DPL,A
   \   0000D4   74..         MOV       A,#((??ACTIONSLOTS + 1) >> 8) & 0xff
   \   0000D6   39           ADDC      A,R1
   \   0000D7   F583         MOV       DPH,A
   \   0000D9   E5..         MOV       A,?V0
   \   0000DB   F0           MOVX      @DPTR,A
   \   0000DC   A3           INC       DPTR
   \   0000DD   E5..         MOV       A,?V1
   \   0000DF   F0           MOVX      @DPTR,A
     79              TM_SetAlarm(frame->meta.TS, TX_ALARM); 
   \   0000E0                ; Setup parameters for call to function TM_SetAlarm
   \   0000E0   7A02         MOV       R2,#0x2
   \   0000E2   85..82       MOV       DPL,?V0
   \   0000E5   85..83       MOV       DPH,?V1
   \   0000E8   A3           INC       DPTR
   \   0000E9   A3           INC       DPTR
   \   0000EA   A3           INC       DPTR
   \   0000EB   A3           INC       DPTR
   \   0000EC   A3           INC       DPTR
   \   0000ED   E0           MOVX      A,@DPTR
   \   0000EE   F9           MOV       R1,A
   \   0000EF   12....       LCALL     `??TM_SetAlarm::?relay`; Banked call to: TM_SetAlarm
     80              void* cursor_for_delete = cursor;
   \   0000F2   8E..         MOV       ?V2,R6
   \   0000F4   8F..         MOV       ?V3,R7
     81              cursor = BF_cursor_next(cursor);
   \   0000F6                ; Setup parameters for call to function BF_cursor_next
   \   0000F6   EE           MOV       A,R6
   \   0000F7   FA           MOV       R2,A
   \   0000F8   EF           MOV       A,R7
   \   0000F9   FB           MOV       R3,A
   \   0000FA   12....       LCALL     `??BF_cursor_next::?relay`; Banked call to: BF_cursor_next
   \   0000FD   8A..         MOV       ?V4,R2
   \   0000FF   8B..         MOV       ?V5,R3
   \   000101   AE..         MOV       R6,?V4
   \   000103   AF..         MOV       R7,?V5
     82              if (!BF_remove_tx(cursor_for_delete))
   \   000105                ; Setup parameters for call to function BF_remove_tx
   \   000105   AA..         MOV       R2,?V2
   \   000107   AB..         MOV       R3,?V3
   \   000109   12....       LCALL     `??BF_remove_tx::?relay`; Banked call to: BF_remove_tx
   \   00010C   5003         JNC       $+5
   \   00010E   02....       LJMP      ??scheduler_tx_2 & 0xFFFF
     83                HALT("Error");
   \   000111                ; Setup parameters for call to function printf
   \   000111   74..         MOV       A,#??__FUNCTION__ & 0xff
   \   000113   C0E0         PUSH      A
   \   000115   74..         MOV       A,#(??__FUNCTION__ >> 8) & 0xff
   \   000117   C0E0         PUSH      A
   \   000119   7453         MOV       A,#0x53
   \   00011B   C0E0         PUSH      A
   \   00011D   7400         MOV       A,#0x0
   \   00011F   C0E0         PUSH      A
   \   000121   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   000123   C0E0         PUSH      A
   \   000125   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   000127   C0E0         PUSH      A
   \   000129   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">` & 0xff
   \   00012B   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">` >> 8) & 0xff
   \   00012D   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000130   74FA         MOV       A,#-0x6
   \   000132   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000135                ; Setup parameters for call to function printf
   \   000135   7A..         MOV       R2,#`?<Constant "Error">` & 0xff
   \   000137   7B..         MOV       R3,#(`?<Constant "Error">` >> 8) & 0xff
   \   000139   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00013C                ; Setup parameters for call to function DBG_CORE_HALT
   \   00013C   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
   \   00013F   02....       LJMP      ??scheduler_tx_2 & 0xFFFF
     84            }
     85          }
   \                     ??scheduler_tx_1:
   \   000142   7F06         MOV       R7,#0x6
   \   000144   02....       LJMP      ?BANKED_LEAVE_SP
     86          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     87          static void scheduler_rx(void){
   \                     ??scheduler_rx:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
     88            ASSERT(ACTIONSLOTS[0].rx == 0);
   \   000003   90....       MOV       DPTR,#??ACTIONSLOTS
   \   000006   E0           MOVX      A,@DPTR
   \   000007   601F         JZ        ??scheduler_rx_1
   \   000009                ; Setup parameters for call to function printf
   \   000009   7458         MOV       A,#0x58
   \   00000B   C0E0         PUSH      A
   \   00000D   7400         MOV       A,#0x0
   \   00000F   C0E0         PUSH      A
   \   000011   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   000013   C0E0         PUSH      A
   \   000015   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   000017   C0E0         PUSH      A
   \   000019   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_3` & 0xff
   \   00001B   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_3` >> 8) & 0xff
   \   00001D   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000020   74FC         MOV       A,#-0x4
   \   000022   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000025                ; Setup parameters for call to function DBG_CORE_HALT
   \   000025   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     89            for (char i = 1; i < MAX_SLOTS; i++)
   \                     ??scheduler_rx_1:
   \   000028   7E01         MOV       R6,#0x1
   \                     ??scheduler_rx_2:
   \   00002A   EE           MOV       A,R6
   \   00002B   C3           CLR       C
   \   00002C   9432         SUBB      A,#0x32
   \   00002E   5039         JNC       ??scheduler_rx_3
     90              if (ACTIONSLOTS[i].rx)
   \   000030   EE           MOV       A,R6
   \   000031   F8           MOV       R0,A
   \   000032   7900         MOV       R1,#0x0
   \   000034   E8           MOV       A,R0
   \   000035   75F003       MOV       B,#0x3
   \   000038   A4           MUL       AB
   \   000039   C8           XCH       A,R0
   \   00003A   AAF0         MOV       R2,B
   \   00003C   75F000       MOV       B,#0x0
   \   00003F   A4           MUL       AB
   \   000040   2A           ADD       A,R2
   \   000041   FA           MOV       R2,A
   \   000042   75F003       MOV       B,#0x3
   \   000045   E9           MOV       A,R1
   \   000046   A4           MUL       AB
   \   000047   2A           ADD       A,R2
   \   000048   F9           MOV       R1,A
   \   000049   74..         MOV       A,#??ACTIONSLOTS & 0xff
   \   00004B   28           ADD       A,R0
   \   00004C   F582         MOV       DPL,A
   \   00004E   74..         MOV       A,#(??ACTIONSLOTS >> 8) & 0xff
   \   000050   39           ADDC      A,R1
   \   000051   F583         MOV       DPH,A
   \   000053   E0           MOVX      A,@DPTR
   \   000054   6009         JZ        ??scheduler_rx_4
     91                TM_SetAlarm(i, RX_ALARM);
   \   000056                ; Setup parameters for call to function TM_SetAlarm
   \   000056   7A01         MOV       R2,#0x1
   \   000058   EE           MOV       A,R6
   \   000059   F9           MOV       R1,A
   \   00005A   12....       LCALL     `??TM_SetAlarm::?relay`; Banked call to: TM_SetAlarm
   \   00005D   8007         SJMP      ??scheduler_rx_5
     92              else
     93                TM_ClrAlarm(i, RX_ALARM);
   \                     ??scheduler_rx_4:
   \   00005F                ; Setup parameters for call to function TM_ClrAlarm
   \   00005F   7A01         MOV       R2,#0x1
   \   000061   EE           MOV       A,R6
   \   000062   F9           MOV       R1,A
   \   000063   12....       LCALL     `??TM_ClrAlarm::?relay`; Banked call to: TM_ClrAlarm
   \                     ??scheduler_rx_5:
   \   000066   0E           INC       R6
   \   000067   80C1         SJMP      ??scheduler_rx_2
     94          }
   \                     ??scheduler_rx_3:
   \   000069   D0E0         POP       A
   \   00006B   FE           MOV       R6,A
   \   00006C   02....       LJMP      ?BRET
     95          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     96          static void Cold_Start(void){
   \                     ??Cold_Start_1:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     97          // Планировщик планирует на один суперфрейм в начале ts0
     98            if (MODEL.TM.timeslot != 0)
   \   000000   90....       MOV       DPTR,#MODEL + 13
   \   000003   E0           MOVX      A,@DPTR
   \   000004   7006         JNZ       ??Cold_Start_4
     99              return;
    100            
    101            scheduler_tx();
   \   000006                ; Setup parameters for call to function scheduler_tx
   \   000006   12....       LCALL     `??scheduler_tx::?relay`; Banked call to: scheduler_tx
    102            scheduler_rx();
   \   000009                ; Setup parameters for call to function scheduler_rx
   \   000009   12....       LCALL     `??scheduler_rx::?relay`; Banked call to: scheduler_rx
    103          };
   \                     ??Cold_Start_4:
   \   00000C   02....       LJMP      ?BRET
    104          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    105          static inline void receive(){
   \                     ??receive:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
    106            timeslot_t ts = MODEL.TM.timeslot;
   \   000003   90....       MOV       DPTR,#MODEL + 13
   \   000006   E0           MOVX      A,@DPTR
   \   000007   FE           MOV       R6,A
    107            MAC_Receive(ACTIONSLOTS[ts].rx);
   \   000008                ; Setup parameters for call to function MAC_Receive
   \   000008   EE           MOV       A,R6
   \   000009   F8           MOV       R0,A
   \   00000A   7900         MOV       R1,#0x0
   \   00000C   E8           MOV       A,R0
   \   00000D   75F003       MOV       B,#0x3
   \   000010   A4           MUL       AB
   \   000011   C8           XCH       A,R0
   \   000012   AAF0         MOV       R2,B
   \   000014   75F000       MOV       B,#0x0
   \   000017   A4           MUL       AB
   \   000018   2A           ADD       A,R2
   \   000019   FA           MOV       R2,A
   \   00001A   75F003       MOV       B,#0x3
   \   00001D   E9           MOV       A,R1
   \   00001E   A4           MUL       AB
   \   00001F   2A           ADD       A,R2
   \   000020   F9           MOV       R1,A
   \   000021   74..         MOV       A,#??ACTIONSLOTS & 0xff
   \   000023   28           ADD       A,R0
   \   000024   F582         MOV       DPL,A
   \   000026   74..         MOV       A,#(??ACTIONSLOTS >> 8) & 0xff
   \   000028   39           ADDC      A,R1
   \   000029   F583         MOV       DPH,A
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   F9           MOV       R1,A
   \   00002D   12....       LCALL     `??MAC_Receive::?relay`; Banked call to: MAC_Receive
    108          }
   \   000030   D0E0         POP       A
   \   000032   FE           MOV       R6,A
   \   000033   02....       LJMP      ?BRET
    109          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    110          static void transmite(void){
   \                     ??transmite:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    111            timeslot_t ts = MODEL.TM.timeslot;
   \   000005   90....       MOV       DPTR,#MODEL + 13
   \   000008   E0           MOVX      A,@DPTR
   \   000009   F5..         MOV       ?V2,A
    112            struct frame *frame = ACTIONSLOTS[ts].frame_tx;
   \   00000B   E5..         MOV       A,?V2
   \   00000D   F8           MOV       R0,A
   \   00000E   7900         MOV       R1,#0x0
   \   000010   E8           MOV       A,R0
   \   000011   75F003       MOV       B,#0x3
   \   000014   A4           MUL       AB
   \   000015   C8           XCH       A,R0
   \   000016   AAF0         MOV       R2,B
   \   000018   75F000       MOV       B,#0x0
   \   00001B   A4           MUL       AB
   \   00001C   2A           ADD       A,R2
   \   00001D   FA           MOV       R2,A
   \   00001E   75F003       MOV       B,#0x3
   \   000021   E9           MOV       A,R1
   \   000022   A4           MUL       AB
   \   000023   2A           ADD       A,R2
   \   000024   F9           MOV       R1,A
   \   000025   74..         MOV       A,#(??ACTIONSLOTS + 1) & 0xff
   \   000027   28           ADD       A,R0
   \   000028   F582         MOV       DPL,A
   \   00002A   74..         MOV       A,#((??ACTIONSLOTS + 1) >> 8) & 0xff
   \   00002C   39           ADDC      A,R1
   \   00002D   F583         MOV       DPH,A
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   F5..         MOV       ?V0,A
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   F5..         MOV       ?V1,A
    113            
    114            if (!frame)
   \   000036   E5..         MOV       A,?V0
   \   000038   45..         ORL       A,?V1
   \   00003A   702E         JNZ       ??transmite_1
    115              HALT("Error")
   \   00003C                ; Setup parameters for call to function printf
   \   00003C   74..         MOV       A,#??__FUNCTION___1 & 0xff
   \   00003E   C0E0         PUSH      A
   \   000040   74..         MOV       A,#(??__FUNCTION___1 >> 8) & 0xff
   \   000042   C0E0         PUSH      A
   \   000044   7473         MOV       A,#0x73
   \   000046   C0E0         PUSH      A
   \   000048   7400         MOV       A,#0x0
   \   00004A   C0E0         PUSH      A
   \   00004C   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   00004E   C0E0         PUSH      A
   \   000050   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   000052   C0E0         PUSH      A
   \   000054   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">` & 0xff
   \   000056   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">` >> 8) & 0xff
   \   000058   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00005B   74FA         MOV       A,#-0x6
   \   00005D   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000060                ; Setup parameters for call to function printf
   \   000060   7A..         MOV       R2,#`?<Constant "Error">` & 0xff
   \   000062   7B..         MOV       R3,#(`?<Constant "Error">` >> 8) & 0xff
   \   000064   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000067                ; Setup parameters for call to function DBG_CORE_HALT
   \   000067   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    116            
    117            // Неудачные передачи учитывает MAC_Send()
    118            int send_res = MAC_Send(frame);
   \                     ??transmite_1:
   \   00006A                ; Setup parameters for call to function MAC_Send
   \   00006A   AA..         MOV       R2,?V0
   \   00006C   AB..         MOV       R3,?V1
   \   00006E   12....       LCALL     `??MAC_Send::?relay`; Banked call to: MAC_Send
   \   000071   8A..         MOV       ?V4,R2
   \   000073   8B..         MOV       ?V5,R3
   \   000075   AE..         MOV       R6,?V4
   \   000077   AF..         MOV       R7,?V5
    119            switch (send_res) {
   \   000079   8E..         MOV       ?V4,R6
   \   00007B   8F..         MOV       ?V5,R7
   \   00007D   78..         MOV       R0,#?V4
   \   00007F   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for transmite>_0`:
   \   000082   FFFF         DW        65535
   \   000084   02           DB        2
   \   000085   ....         DW        ??transmite_2
   \   000087   ....         DW        ??transmite_3
   \   000089   ....         DW        ??transmite_4
   \   00008B   ....         DW        ??transmite_5
    120              case 1: { // удачная передача
    121                TM_ClrAlarm(ts, TX_ALARM);
   \                     ??transmite_5:
   \   00008D                ; Setup parameters for call to function TM_ClrAlarm
   \   00008D   7A02         MOV       R2,#0x2
   \   00008F   A9..         MOV       R1,?V2
   \   000091   12....       LCALL     `??TM_ClrAlarm::?relay`; Banked call to: TM_ClrAlarm
    122                ACTIONSLOTS[ts].frame_tx = NULL;
   \   000094   E5..         MOV       A,?V2
   \   000096   F8           MOV       R0,A
   \   000097   7900         MOV       R1,#0x0
   \   000099   E8           MOV       A,R0
   \   00009A   75F003       MOV       B,#0x3
   \   00009D   A4           MUL       AB
   \   00009E   C8           XCH       A,R0
   \   00009F   AAF0         MOV       R2,B
   \   0000A1   75F000       MOV       B,#0x0
   \   0000A4   A4           MUL       AB
   \   0000A5   2A           ADD       A,R2
   \   0000A6   FA           MOV       R2,A
   \   0000A7   75F003       MOV       B,#0x3
   \   0000AA   E9           MOV       A,R1
   \   0000AB   A4           MUL       AB
   \   0000AC   2A           ADD       A,R2
   \   0000AD   F9           MOV       R1,A
   \   0000AE   74..         MOV       A,#(??ACTIONSLOTS + 1) & 0xff
   \   0000B0   28           ADD       A,R0
   \   0000B1   F582         MOV       DPL,A
   \   0000B3   74..         MOV       A,#((??ACTIONSLOTS + 1) >> 8) & 0xff
   \   0000B5   39           ADDC      A,R1
   \   0000B6   F583         MOV       DPH,A
   \   0000B8   7400         MOV       A,#0x0
   \   0000BA   F0           MOVX      @DPTR,A
   \   0000BB   A3           INC       DPTR
   \   0000BC   7400         MOV       A,#0x0
   \   0000BE   F0           MOVX      @DPTR,A
    123                LOG_ON("Send success");
   \   0000BF                ; Setup parameters for call to function printf
   \   0000BF   74..         MOV       A,#??__FUNCTION___1 & 0xff
   \   0000C1   C0E0         PUSH      A
   \   0000C3   74..         MOV       A,#(??__FUNCTION___1 >> 8) & 0xff
   \   0000C5   C0E0         PUSH      A
   \   0000C7   747B         MOV       A,#0x7b
   \   0000C9   C0E0         PUSH      A
   \   0000CB   7400         MOV       A,#0x0
   \   0000CD   C0E0         PUSH      A
   \   0000CF   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   0000D1   C0E0         PUSH      A
   \   0000D3   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   0000D5   C0E0         PUSH      A
   \   0000D7   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">` & 0xff
   \   0000D9   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">` >> 8) & 0xff
   \   0000DB   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0000DE   74FA         MOV       A,#-0x6
   \   0000E0   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000E3                ; Setup parameters for call to function printf
   \   0000E3   7A..         MOV       R2,#`?<Constant "Send success">` & 0xff
   \   0000E5   7B..         MOV       R3,#(`?<Constant "Send success">` >> 8) & 0xff
   \   0000E7   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0000EA                ; Setup parameters for call to function printf
   \   0000EA   7A..         MOV       R2,#`?<Constant "\\r\\n">` & 0xff
   \   0000EC   7B..         MOV       R3,#(`?<Constant "\\r\\n">` >> 8) & 0xff
   \   0000EE   12....       LCALL     `??printf::?relay`; Banked call to: printf
    124                break;
   \   0000F1   02....       LJMP      ??transmite_6 & 0xFFFF
    125              }
    126              case 0: { // неудачная передача. ACK не получен или CCA
    127                LOG_ON("CCA/ACK err")
   \                     ??transmite_4:
   \   0000F4                ; Setup parameters for call to function printf
   \   0000F4   74..         MOV       A,#??__FUNCTION___1 & 0xff
   \   0000F6   C0E0         PUSH      A
   \   0000F8   74..         MOV       A,#(??__FUNCTION___1 >> 8) & 0xff
   \   0000FA   C0E0         PUSH      A
   \   0000FC   747F         MOV       A,#0x7f
   \   0000FE   C0E0         PUSH      A
   \   000100   7400         MOV       A,#0x0
   \   000102   C0E0         PUSH      A
   \   000104   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   000106   C0E0         PUSH      A
   \   000108   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   00010A   C0E0         PUSH      A
   \   00010C   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">` & 0xff
   \   00010E   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">` >> 8) & 0xff
   \   000110   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000113   74FA         MOV       A,#-0x6
   \   000115   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000118                ; Setup parameters for call to function printf
   \   000118   7A..         MOV       R2,#`?<Constant "CCA/ACK err">` & 0xff
   \   00011A   7B..         MOV       R3,#(`?<Constant "CCA/ACK err">` >> 8) & 0xff
   \   00011C   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00011F                ; Setup parameters for call to function printf
   \   00011F   7A..         MOV       R2,#`?<Constant "\\r\\n">` & 0xff
   \   000121   7B..         MOV       R3,#(`?<Constant "\\r\\n">` >> 8) & 0xff
   \   000123   12....       LCALL     `??printf::?relay`; Banked call to: printf
    128                break;
   \   000126   02....       LJMP      ??transmite_6 & 0xFFFF
    129              }
    130              case -1: { // Исчерпаны попытки отправки
    131                TM_ClrAlarm(ts, TX_ALARM);
   \                     ??transmite_3:
   \   000129                ; Setup parameters for call to function TM_ClrAlarm
   \   000129   7A02         MOV       R2,#0x2
   \   00012B   A9..         MOV       R1,?V2
   \   00012D   12....       LCALL     `??TM_ClrAlarm::?relay`; Banked call to: TM_ClrAlarm
    132                ACTIONSLOTS[ts].frame_tx = NULL;
   \   000130   E5..         MOV       A,?V2
   \   000132   F8           MOV       R0,A
   \   000133   7900         MOV       R1,#0x0
   \   000135   E8           MOV       A,R0
   \   000136   75F003       MOV       B,#0x3
   \   000139   A4           MUL       AB
   \   00013A   C8           XCH       A,R0
   \   00013B   AAF0         MOV       R2,B
   \   00013D   75F000       MOV       B,#0x0
   \   000140   A4           MUL       AB
   \   000141   2A           ADD       A,R2
   \   000142   FA           MOV       R2,A
   \   000143   75F003       MOV       B,#0x3
   \   000146   E9           MOV       A,R1
   \   000147   A4           MUL       AB
   \   000148   2A           ADD       A,R2
   \   000149   F9           MOV       R1,A
   \   00014A   74..         MOV       A,#(??ACTIONSLOTS + 1) & 0xff
   \   00014C   28           ADD       A,R0
   \   00014D   F582         MOV       DPL,A
   \   00014F   74..         MOV       A,#((??ACTIONSLOTS + 1) >> 8) & 0xff
   \   000151   39           ADDC      A,R1
   \   000152   F583         MOV       DPH,A
   \   000154   7400         MOV       A,#0x0
   \   000156   F0           MOVX      @DPTR,A
   \   000157   A3           INC       DPTR
   \   000158   7400         MOV       A,#0x0
   \   00015A   F0           MOVX      @DPTR,A
    133                LOG_ON("Attempts exired");
   \   00015B                ; Setup parameters for call to function printf
   \   00015B   74..         MOV       A,#??__FUNCTION___1 & 0xff
   \   00015D   C0E0         PUSH      A
   \   00015F   74..         MOV       A,#(??__FUNCTION___1 >> 8) & 0xff
   \   000161   C0E0         PUSH      A
   \   000163   7485         MOV       A,#-0x7b
   \   000165   C0E0         PUSH      A
   \   000167   7400         MOV       A,#0x0
   \   000169   C0E0         PUSH      A
   \   00016B   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   00016D   C0E0         PUSH      A
   \   00016F   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   000171   C0E0         PUSH      A
   \   000173   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">` & 0xff
   \   000175   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">` >> 8) & 0xff
   \   000177   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00017A   74FA         MOV       A,#-0x6
   \   00017C   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00017F                ; Setup parameters for call to function printf
   \   00017F   7A..         MOV       R2,#`?<Constant "Attempts exired">` & 0xff
   \   000181   7B..         MOV       R3,#(`?<Constant "Attempts exired">` >> 8) & 0xff
   \   000183   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000186                ; Setup parameters for call to function printf
   \   000186   7A..         MOV       R2,#`?<Constant "\\r\\n">` & 0xff
   \   000188   7B..         MOV       R3,#(`?<Constant "\\r\\n">` >> 8) & 0xff
   \   00018A   12....       LCALL     `??printf::?relay`; Banked call to: printf
    134                break;
   \   00018D   802E         SJMP      ??transmite_6
    135              }
    136              default:
    137                HALT("Error");
   \                     ??transmite_2:
   \   00018F                ; Setup parameters for call to function printf
   \   00018F   74..         MOV       A,#??__FUNCTION___1 & 0xff
   \   000191   C0E0         PUSH      A
   \   000193   74..         MOV       A,#(??__FUNCTION___1 >> 8) & 0xff
   \   000195   C0E0         PUSH      A
   \   000197   7489         MOV       A,#-0x77
   \   000199   C0E0         PUSH      A
   \   00019B   7400         MOV       A,#0x0
   \   00019D   C0E0         PUSH      A
   \   00019F   74..         MOV       A,#`?<Constant "llc.c">` & 0xff
   \   0001A1   C0E0         PUSH      A
   \   0001A3   74..         MOV       A,#(`?<Constant "llc.c">` >> 8) & 0xff
   \   0001A5   C0E0         PUSH      A
   \   0001A7   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">` & 0xff
   \   0001A9   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">` >> 8) & 0xff
   \   0001AB   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0001AE   74FA         MOV       A,#-0x6
   \   0001B0   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001B3                ; Setup parameters for call to function printf
   \   0001B3   7A..         MOV       R2,#`?<Constant "Error">` & 0xff
   \   0001B5   7B..         MOV       R3,#(`?<Constant "Error">` >> 8) & 0xff
   \   0001B7   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0001BA                ; Setup parameters for call to function DBG_CORE_HALT
   \   0001BA   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    138            };
    139          }
   \                     ??transmite_6:
   \   0001BD   7F06         MOV       R7,#0x6
   \   0001BF   02....       LJMP      ?BANKED_LEAVE_SP
    140          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    141          static void Hot_Start(void){
   \                     ??Hot_Start_1:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
    142            timeslot_t ts = MODEL.TM.timeslot;
   \   000006   90....       MOV       DPTR,#MODEL + 13
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   FF           MOV       R7,A
    143            if (ts == 0)
   \   00000B   EF           MOV       A,R7
   \   00000C   6017         JZ        ??Hot_Start_4
    144              return;
    145            char alarm = MODEL.TM.alarm;
   \   00000E   90....       MOV       DPTR,#MODEL + 14
   \   000011   E0           MOVX      A,@DPTR
   \   000012   FE           MOV       R6,A
    146            
    147            if (alarm & TX_ALARM)
   \   000013   EE           MOV       A,R6
   \   000014   A2E1         MOV       C,0xE0 /* A   */.1
   \   000016   5005         JNC       ??Hot_Start_5
    148              transmite();
   \   000018                ; Setup parameters for call to function transmite
   \   000018   12....       LCALL     `??transmite::?relay`; Banked call to: transmite
   \   00001B   8008         SJMP      ??Hot_Start_4
    149            else if (alarm & RX_ALARM)
   \                     ??Hot_Start_5:
   \   00001D   EE           MOV       A,R6
   \   00001E   A2E0         MOV       C,0xE0 /* A   */.0
   \   000020   5003         JNC       ??Hot_Start_4
    150              receive();
   \   000022                ; Setup parameters for call to function receive
   \   000022   12....       LCALL     `??receive::?relay`; Banked call to: receive
    151          };
   \                     ??Hot_Start_4:
   \   000025   D0E0         POP       A
   \   000027   FF           MOV       R7,A
   \   000028   D0E0         POP       A
   \   00002A   FE           MOV       R6,A
   \   00002B   02....       LJMP      ?BRET
E:\Neocore\Hardware\STACK_CORE_SRC\mac.c
      1          #include "action_manager.h"
      2          #include "frame.h"
      3          #include "coder.h"
      4          #include "radio.h"
      5          #include "ustimer.h"
      6          #include "debug.h"
      7          #include "model.h"
      8          #include "buffer.h"
      9          
     10          #define RECV_TIMEOUT 2500
     11          
     12          static void SW_Init(void);
     13          static void IRQ_Init(void);
     14          

   \                                 In  segment XDATA_I, align 1, keep-with-next
     15          module_s MAC_MODULE = {ALIAS(SW_Init), ALIAS(IRQ_Init)};
   \                     MAC_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for MAC_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     16          
     17          struct ack{ // Формат структуры пакета ACK
     18            char CRC8;
     19          } __attribute__((packed));
     20          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     21          static void SW_Init(void){};
   \                     ??SW_Init_4:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     22          static void IRQ_Init(void){};
   \                     ??IRQ_Init_2:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP      ?BRET
     23          
     24          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     25          static inline struct frame* _recv_frame(channel_t ch){
   \                     ??_recv_frame:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
     26            if(!RI_SetChannel(ch))
   \   000007                ; Setup parameters for call to function RI_SetChannel
   \   000007   A9..         MOV       R1,?V0
   \   000009   12....       LCALL     `??RI_SetChannel::?relay`; Banked call to: RI_SetChannel
   \   00000C   402E         JC        ??_recv_frame_1
     27              HALT("Wrong channel");
   \   00000E                ; Setup parameters for call to function printf
   \   00000E   74..         MOV       A,#??__FUNCTION___2 & 0xff
   \   000010   C0E0         PUSH      A
   \   000012   74..         MOV       A,#(??__FUNCTION___2 >> 8) & 0xff
   \   000014   C0E0         PUSH      A
   \   000016   741B         MOV       A,#0x1b
   \   000018   C0E0         PUSH      A
   \   00001A   7400         MOV       A,#0x0
   \   00001C   C0E0         PUSH      A
   \   00001E   74..         MOV       A,#`?<Constant "mac.c">` & 0xff
   \   000020   C0E0         PUSH      A
   \   000022   74..         MOV       A,#(`?<Constant "mac.c">` >> 8) & 0xff
   \   000024   C0E0         PUSH      A
   \   000026   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_1` & 0xff
   \   000028   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_1` >> 8) & 0xff
   \   00002A   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00002D   74FA         MOV       A,#-0x6
   \   00002F   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000032                ; Setup parameters for call to function printf
   \   000032   7A..         MOV       R2,#`?<Constant "Wrong channel">` & 0xff
   \   000034   7B..         MOV       R3,#(`?<Constant "Wrong channel">` >> 8) & 0xff
   \   000036   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000039                ; Setup parameters for call to function DBG_CORE_HALT
   \   000039   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     28            
     29            //UST_delay(400);
     30            nwtime_t NOW1 = AT_time();
   \                     ??_recv_frame_1:
   \   00003C                ; Setup parameters for call to function AT_time
   \   00003C   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   00003F   8A..         MOV       ?V4,R2
   \   000041   8B..         MOV       ?V5,R3
   \   000043   85....       MOV       ?V2,?V4
   \   000046   85....       MOV       ?V3,?V5
     31            struct frame *frame = RI_Receive(RECV_TIMEOUT); //
   \   000049                ; Setup parameters for call to function RI_Receive
   \   000049   90....       MOV       DPTR,#__Constant_9c4
   \   00004C   12....       LCALL     ?XLOAD_R2345
   \   00004F   12....       LCALL     `??RI_Receive::?relay`; Banked call to: RI_Receive
   \   000052   8A..         MOV       ?V4,R2
   \   000054   8B..         MOV       ?V5,R3
   \   000056   AE..         MOV       R6,?V4
   \   000058   AF..         MOV       R7,?V5
     32            nwtime_t NOW2 = AT_time();
   \   00005A                ; Setup parameters for call to function AT_time
   \   00005A   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   00005D   8A..         MOV       ?V4,R2
   \   00005F   8B..         MOV       ?V5,R3
   \   000061   A8..         MOV       R0,?V4
   \   000063   A9..         MOV       R1,?V5
     33            return frame;
   \   000065   EE           MOV       A,R6
   \   000066   FA           MOV       R2,A
   \   000067   EF           MOV       A,R7
   \   000068   FB           MOV       R3,A
   \   000069   7F06         MOV       R7,#0x6
   \   00006B   02....       LJMP      ?BANKED_LEAVE_SP
     34          }
     35          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     36          static uint8_t xor_calc(struct frame *frame){
   \                     ??xor_calc:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
     37            uint8_t crc = 0x34; // Начальное значение
   \   000006   7934         MOV       R1,#0x34
     38            uint8_t *val = (uint8_t*)frame->payload;
   \   000008   EA           MOV       A,R2
   \   000009   2415         ADD       A,#0x15
   \   00000B   FC           MOV       R4,A
   \   00000C   E4           CLR       A
   \   00000D   3B           ADDC      A,R3
   \   00000E   FD           MOV       R5,A
     39            for (uint8_t i = 0; i < frame->len; i++)
   \   00000F   7800         MOV       R0,#0x0
   \                     ??xor_calc_1:
   \   000011   8A82         MOV       DPL,R2
   \   000013   8B83         MOV       DPH,R3
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FE           MOV       R6,A
   \   000017   E8           MOV       A,R0
   \   000018   C3           CLR       C
   \   000019   9E           SUBB      A,R6
   \   00001A   5013         JNC       ??xor_calc_2
     40              crc ^= val[i];
   \   00001C   E8           MOV       A,R0
   \   00001D   FE           MOV       R6,A
   \   00001E   7F00         MOV       R7,#0x0
   \   000020   EC           MOV       A,R4
   \   000021   2E           ADD       A,R6
   \   000022   F582         MOV       DPL,A
   \   000024   ED           MOV       A,R5
   \   000025   3F           ADDC      A,R7
   \   000026   F583         MOV       DPH,A
   \   000028   E0           MOVX      A,@DPTR
   \   000029   C9           XCH       A,R1
   \   00002A   69           XRL       A,R1
   \   00002B   C9           XCH       A,R1
   \   00002C   08           INC       R0
   \   00002D   80E2         SJMP      ??xor_calc_1
     41            return crc;
   \                     ??xor_calc_2:
   \   00002F   D0E0         POP       A
   \   000031   FF           MOV       R7,A
   \   000032   D0E0         POP       A
   \   000034   FE           MOV       R6,A
   \   000035   02....       LJMP      ?BRET
     42          }
     43          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     44          static inline void _send_ack(struct frame *frame){
   \                     ??_send_ack:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 1
   \   000005   C0E0         PUSH      A
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
     45            struct ack ack;
     46            struct frame *ack_frame;
     47            // Создаем подтверждение кадра
     48            ack.CRC8 = xor_calc(frame);
   \   00000B                ; Setup parameters for call to function xor_calc
   \   00000B   AA..         MOV       R2,?V0
   \   00000D   AB..         MOV       R3,?V1
   \   00000F   12....       LCALL     `??xor_calc::?relay`; Banked call to: xor_calc
   \   000012   E9           MOV       A,R1
   \   000013   C0E0         PUSH      A
   \   000015   90FFFD       MOV       DPTR,#-0x3
   \   000018   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00001B   D0E0         POP       A
   \   00001D   F0           MOVX      @DPTR,A
     49            // Создаем кадр для отправки
     50            ack_frame = FR_create();
   \   00001E                ; Setup parameters for call to function FR_create
   \   00001E   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   000021   8A..         MOV       ?V2,R2
   \   000023   8B..         MOV       ?V3,R3
   \   000025   AE..         MOV       R6,?V2
   \   000027   AF..         MOV       R7,?V3
     51            FR_add_header(ack_frame, &ack, sizeof(struct ack));
   \   000029                ; Setup parameters for call to function FR_add_header
   \   000029   7901         MOV       R1,#0x1
   \   00002B   858182       MOV       DPL,SP
   \   00002E   E5..         MOV       A,?ESP
   \   000030   54..         ANL       A,#?ESP_MASK
   \   000032   44..         ORL       A,#(SFB(EXT_STACK) >> 8) & 0xff
   \   000034   F583         MOV       DPH,A
   \   000036   AC82         MOV       R4,DPL
   \   000038   AD83         MOV       R5,DPH
   \   00003A   EE           MOV       A,R6
   \   00003B   FA           MOV       R2,A
   \   00003C   EF           MOV       A,R7
   \   00003D   FB           MOV       R3,A
   \   00003E   12....       LCALL     `??FR_add_header::?relay`; Banked call to: FR_add_header
     52            ack_frame->meta.SEND_TIME = 0;
   \   000041   EE           MOV       A,R6
   \   000042   2413         ADD       A,#0x13
   \   000044   F582         MOV       DPL,A
   \   000046   E4           CLR       A
   \   000047   3F           ADDC      A,R7
   \   000048   F583         MOV       DPH,A
   \   00004A   7400         MOV       A,#0x0
   \   00004C   F0           MOVX      @DPTR,A
   \   00004D   A3           INC       DPTR
   \   00004E   7400         MOV       A,#0x0
   \   000050   F0           MOVX      @DPTR,A
     53            RI_Send(ack_frame);
   \   000051                ; Setup parameters for call to function RI_Send
   \   000051   EE           MOV       A,R6
   \   000052   FA           MOV       R2,A
   \   000053   EF           MOV       A,R7
   \   000054   FB           MOV       R3,A
   \   000055   12....       LCALL     `??RI_Send::?relay`; Banked call to: RI_Send
     54            FR_delete(ack_frame);  
   \   000058                ; Setup parameters for call to function FR_delete
   \   000058   EE           MOV       A,R6
   \   000059   FA           MOV       R2,A
   \   00005A   EF           MOV       A,R7
   \   00005B   FB           MOV       R3,A
   \   00005C   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
     55          }
   \   00005F   D0E0         POP       A
   \   000061   7F04         MOV       R7,#0x4
   \   000063   02....       LJMP      ?BANKED_LEAVE_SP
     56          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     57          void MAC_Receive(channel_t ch){
   \                     MAC_Receive:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
     58            struct frame *frame = _recv_frame(ch);
   \   000007                ; Setup parameters for call to function _recv_frame
   \   000007   A9..         MOV       R1,?V0
   \   000009   12....       LCALL     `??_recv_frame::?relay`; Banked call to: _recv_frame
   \   00000C   8A..         MOV       ?V2,R2
   \   00000E   8B..         MOV       ?V3,R3
   \   000010   AE..         MOV       R6,?V2
   \   000012   AF..         MOV       R7,?V3
     59            if (!frame)
   \   000014   EE           MOV       A,R6
   \   000015   4F           ORL       A,R7
   \   000016   7003         JNZ       $+5
   \   000018   02....       LJMP      ??MAC_Receive_0 & 0xFFFF
     60              return;
     61            
     62            frame->meta.TS = MODEL.TM.timeslot;
   \   00001B   90....       MOV       DPTR,#MODEL + 13
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   C0E0         PUSH      A
   \   000021   8E82         MOV       DPL,R6
   \   000023   8F83         MOV       DPH,R7
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   D0E0         POP       A
   \   00002C   F0           MOVX      @DPTR,A
     63            if (MODEL.TM.timeslot > 1) // не системный таймслот требует подтверждения
   \   00002D   90....       MOV       DPTR,#MODEL + 13
   \   000030   E0           MOVX      A,@DPTR
   \   000031   C3           CLR       C
   \   000032   9402         SUBB      A,#0x2
   \   000034   4007         JC        ??MAC_Receive_1
     64              _send_ack(frame);
   \   000036                ; Setup parameters for call to function _send_ack
   \   000036   EE           MOV       A,R6
   \   000037   FA           MOV       R2,A
   \   000038   EF           MOV       A,R7
   \   000039   FB           MOV       R3,A
   \   00003A   12....       LCALL     `??_send_ack::?relay`; Banked call to: _send_ack
     65            
     66            AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
   \                     ??MAC_Receive_1:
   \   00003D                ; Setup parameters for call to function AES_StreamCoder
   \   00003D   8E82         MOV       DPL,R6
   \   00003F   8F83         MOV       DPH,R7
   \   000041   E0           MOVX      A,@DPTR
   \   000042   F9           MOV       R1,A
   \   000043   EE           MOV       A,R6
   \   000044   2415         ADD       A,#0x15
   \   000046   FC           MOV       R4,A
   \   000047   E4           CLR       A
   \   000048   3F           ADDC      A,R7
   \   000049   FD           MOV       R5,A
   \   00004A   EE           MOV       A,R6
   \   00004B   2415         ADD       A,#0x15
   \   00004D   FA           MOV       R2,A
   \   00004E   E4           CLR       A
   \   00004F   3F           ADDC      A,R7
   \   000050   FB           MOV       R3,A
   \   000051   C2F0         CLR       B.0
   \   000053   12....       LCALL     `??AES_StreamCoder::?relay`; Banked call to: AES_StreamCoder
     67            
     68            LOG_ON("push");
   \   000056                ; Setup parameters for call to function printf
   \   000056   74..         MOV       A,#??__FUNCTION___3 & 0xff
   \   000058   C0E0         PUSH      A
   \   00005A   74..         MOV       A,#(??__FUNCTION___3 >> 8) & 0xff
   \   00005C   C0E0         PUSH      A
   \   00005E   7444         MOV       A,#0x44
   \   000060   C0E0         PUSH      A
   \   000062   7400         MOV       A,#0x0
   \   000064   C0E0         PUSH      A
   \   000066   74..         MOV       A,#`?<Constant "mac.c">` & 0xff
   \   000068   C0E0         PUSH      A
   \   00006A   74..         MOV       A,#(`?<Constant "mac.c">` >> 8) & 0xff
   \   00006C   C0E0         PUSH      A
   \   00006E   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_1` & 0xff
   \   000070   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_1` >> 8) & 0xff
   \   000072   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000075   74FA         MOV       A,#-0x6
   \   000077   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00007A                ; Setup parameters for call to function printf
   \   00007A   7A..         MOV       R2,#`?<Constant "push">` & 0xff
   \   00007C   7B..         MOV       R3,#(`?<Constant "push">` >> 8) & 0xff
   \   00007E   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000081                ; Setup parameters for call to function printf
   \   000081   7A..         MOV       R2,#`?<Constant "\\r\\n">_1` & 0xff
   \   000083   7B..         MOV       R3,#(`?<Constant "\\r\\n">_1` >> 8) & 0xff
   \   000085   12....       LCALL     `??printf::?relay`; Banked call to: printf
     69            bool push_res = BF_push_rx(frame);
   \   000088                ; Setup parameters for call to function BF_push_rx
   \   000088   EE           MOV       A,R6
   \   000089   FA           MOV       R2,A
   \   00008A   EF           MOV       A,R7
   \   00008B   FB           MOV       R3,A
   \   00008C   12....       LCALL     `??BF_push_rx::?relay`; Banked call to: BF_push_rx
   \   00008F   92..         MOV       ?VB.0,C
     70            if (!push_res){
   \   000091   A2..         MOV       C,?VB.0
   \   000093   4039         JC        ??MAC_Receive_0
     71              FR_delete(frame);
   \   000095                ; Setup parameters for call to function FR_delete
   \   000095   EE           MOV       A,R6
   \   000096   FA           MOV       R2,A
   \   000097   EF           MOV       A,R7
   \   000098   FB           MOV       R3,A
   \   000099   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
     72              LOG_ON("push del");
   \   00009C                ; Setup parameters for call to function printf
   \   00009C   74..         MOV       A,#??__FUNCTION___3 & 0xff
   \   00009E   C0E0         PUSH      A
   \   0000A0   74..         MOV       A,#(??__FUNCTION___3 >> 8) & 0xff
   \   0000A2   C0E0         PUSH      A
   \   0000A4   7448         MOV       A,#0x48
   \   0000A6   C0E0         PUSH      A
   \   0000A8   7400         MOV       A,#0x0
   \   0000AA   C0E0         PUSH      A
   \   0000AC   74..         MOV       A,#`?<Constant "mac.c">` & 0xff
   \   0000AE   C0E0         PUSH      A
   \   0000B0   74..         MOV       A,#(`?<Constant "mac.c">` >> 8) & 0xff
   \   0000B2   C0E0         PUSH      A
   \   0000B4   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_1` & 0xff
   \   0000B6   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_1` >> 8) & 0xff
   \   0000B8   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0000BB   74FA         MOV       A,#-0x6
   \   0000BD   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000C0                ; Setup parameters for call to function printf
   \   0000C0   7A..         MOV       R2,#`?<Constant "push del">` & 0xff
   \   0000C2   7B..         MOV       R3,#(`?<Constant "push del">` >> 8) & 0xff
   \   0000C4   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0000C7                ; Setup parameters for call to function printf
   \   0000C7   7A..         MOV       R2,#`?<Constant "\\r\\n">_1` & 0xff
   \   0000C9   7B..         MOV       R3,#(`?<Constant "\\r\\n">_1` >> 8) & 0xff
   \   0000CB   12....       LCALL     `??printf::?relay`; Banked call to: printf
     73            }
     74            
     75          }
   \                     ??MAC_Receive_0:
   \   0000CE   7F04         MOV       R7,#0x4
   \   0000D0   02....       LJMP      ?BANKED_LEAVE_SP
     76          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     77          static inline bool _send_frame(struct frame *frame){
   \                     ??_send_frame:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
   \   000006   EA           MOV       A,R2
   \   000007   FE           MOV       R6,A
   \   000008   EB           MOV       A,R3
   \   000009   FF           MOV       R7,A
     78            if(!RI_SetChannel(frame->meta.CH))
   \   00000A                ; Setup parameters for call to function RI_SetChannel
   \   00000A   8E82         MOV       DPL,R6
   \   00000C   8F83         MOV       DPH,R7
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F9           MOV       R1,A
   \   000016   12....       LCALL     `??RI_SetChannel::?relay`; Banked call to: RI_SetChannel
   \   000019   402E         JC        ??_send_frame_1
     79              HALT("Wrong channel");  
   \   00001B                ; Setup parameters for call to function printf
   \   00001B   74..         MOV       A,#??__FUNCTION___4 & 0xff
   \   00001D   C0E0         PUSH      A
   \   00001F   74..         MOV       A,#(??__FUNCTION___4 >> 8) & 0xff
   \   000021   C0E0         PUSH      A
   \   000023   744F         MOV       A,#0x4f
   \   000025   C0E0         PUSH      A
   \   000027   7400         MOV       A,#0x0
   \   000029   C0E0         PUSH      A
   \   00002B   74..         MOV       A,#`?<Constant "mac.c">` & 0xff
   \   00002D   C0E0         PUSH      A
   \   00002F   74..         MOV       A,#(`?<Constant "mac.c">` >> 8) & 0xff
   \   000031   C0E0         PUSH      A
   \   000033   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_1` & 0xff
   \   000035   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_1` >> 8) & 0xff
   \   000037   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00003A   74FA         MOV       A,#-0x6
   \   00003C   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00003F                ; Setup parameters for call to function printf
   \   00003F   7A..         MOV       R2,#`?<Constant "Wrong channel">` & 0xff
   \   000041   7B..         MOV       R3,#(`?<Constant "Wrong channel">` >> 8) & 0xff
   \   000043   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000046                ; Setup parameters for call to function DBG_CORE_HALT
   \   000046   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     80            
     81            UST_delay(918);
   \                     ??_send_frame_1:
   \   000049                ; Setup parameters for call to function UST_delay
   \   000049   90....       MOV       DPTR,#__Constant_396
   \   00004C   12....       LCALL     ?XLOAD_R2345
   \   00004F   12....       LCALL     `??UST_delay::?relay`; Banked call to: UST_delay
     82            bool tx_success = RI_Send(frame);
   \   000052                ; Setup parameters for call to function RI_Send
   \   000052   EE           MOV       A,R6
   \   000053   FA           MOV       R2,A
   \   000054   EF           MOV       A,R7
   \   000055   FB           MOV       R3,A
   \   000056   12....       LCALL     `??RI_Send::?relay`; Banked call to: RI_Send
   \   000059   92F0         MOV       B.0,C
     83            return tx_success;
   \   00005B   A2F0         MOV       C,B.0
   \   00005D   D0E0         POP       A
   \   00005F   FF           MOV       R7,A
   \   000060   D0E0         POP       A
   \   000062   FE           MOV       R6,A
   \   000063   02....       LJMP      ?BRET
     84          }
     85          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     86          static inline bool _recv_ack(struct frame *frame){
   \                     ??_recv_ack:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     87            return true;
   \   000000   D3           SETB      C
   \   000001   02....       LJMP      ?BRET
     88          }
     89          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     90          int MAC_Send(struct frame *frame){
   \                     MAC_Send:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006   C0..         PUSH      ?VB
   \   000008                ; Saved register size: 3
   \   000008                ; Auto size: 0
   \   000008   EA           MOV       A,R2
   \   000009   FE           MOV       R6,A
   \   00000A   EB           MOV       A,R3
   \   00000B   FF           MOV       R7,A
     91            bool tx_success = _send_frame(frame);
   \   00000C                ; Setup parameters for call to function _send_frame
   \   00000C   EE           MOV       A,R6
   \   00000D   FA           MOV       R2,A
   \   00000E   EF           MOV       A,R7
   \   00000F   FB           MOV       R3,A
   \   000010   12....       LCALL     `??_send_frame::?relay`; Banked call to: _send_frame
   \   000013   92..         MOV       ?VB.0,C
     92            
     93            bool ack_success = false;
   \   000015   C2..         CLR       ?VB.1
     94            if (MODEL.TM.timeslot > 1) // Ждем подтверждения ack для не системных слотов
   \   000017   90....       MOV       DPTR,#MODEL + 13
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   C3           CLR       C
   \   00001C   9402         SUBB      A,#0x2
   \   00001E   400B         JC        ??MAC_Send_0
     95              ack_success = _recv_ack(frame);
   \   000020                ; Setup parameters for call to function _recv_ack
   \   000020   EE           MOV       A,R6
   \   000021   FA           MOV       R2,A
   \   000022   EF           MOV       A,R7
   \   000023   FB           MOV       R3,A
   \   000024   12....       LCALL     `??_recv_ack::?relay`; Banked call to: _recv_ack
   \   000027   92..         MOV       ?VB.1,C
   \   000029   8002         SJMP      ??MAC_Send_1
     96            else
     97              ack_success = true;
   \                     ??MAC_Send_0:
   \   00002B   D2..         SETB      ?VB.1
     98            
     99            if (tx_success && ack_success){ // Удачная передача
   \                     ??MAC_Send_1:
   \   00002D   A2..         MOV       C,?VB.1
   \   00002F   82..         ANL       C,?VB.0
   \   000031   500D         JNC       ??MAC_Send_2
    100              FR_delete(frame);
   \   000033                ; Setup parameters for call to function FR_delete
   \   000033   EE           MOV       A,R6
   \   000034   FA           MOV       R2,A
   \   000035   EF           MOV       A,R7
   \   000036   FB           MOV       R3,A
   \   000037   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
    101              return 1;
   \   00003A   7A01         MOV       R2,#0x1
   \   00003C   7B00         MOV       R3,#0x0
   \   00003E   8036         SJMP      ??MAC_Send_3
    102            }
    103            else{ // неудачная передача
    104              if (frame->meta.tx_attempts > 0)
   \                     ??MAC_Send_2:
   \   000040   EE           MOV       A,R6
   \   000041   2412         ADD       A,#0x12
   \   000043   F582         MOV       DPL,A
   \   000045   E4           CLR       A
   \   000046   3F           ADDC      A,R7
   \   000047   F583         MOV       DPH,A
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   600D         JZ        ??MAC_Send_4
    105                frame->meta.tx_attempts --;
   \   00004C   EE           MOV       A,R6
   \   00004D   2412         ADD       A,#0x12
   \   00004F   F582         MOV       DPL,A
   \   000051   E4           CLR       A
   \   000052   3F           ADDC      A,R7
   \   000053   F583         MOV       DPH,A
   \   000055   E0           MOVX      A,@DPTR
   \   000056   24FF         ADD       A,#-0x1
   \   000058   F0           MOVX      @DPTR,A
    106              
    107              if (!frame->meta.tx_attempts){ // кончились попытки передачи
   \                     ??MAC_Send_4:
   \   000059   EE           MOV       A,R6
   \   00005A   2412         ADD       A,#0x12
   \   00005C   F582         MOV       DPL,A
   \   00005E   E4           CLR       A
   \   00005F   3F           ADDC      A,R7
   \   000060   F583         MOV       DPH,A
   \   000062   E0           MOVX      A,@DPTR
   \   000063   700D         JNZ       ??MAC_Send_5
    108                FR_delete(frame);
   \   000065                ; Setup parameters for call to function FR_delete
   \   000065   EE           MOV       A,R6
   \   000066   FA           MOV       R2,A
   \   000067   EF           MOV       A,R7
   \   000068   FB           MOV       R3,A
   \   000069   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
    109                return -1;
   \   00006C   7AFF         MOV       R2,#-0x1
   \   00006E   7BFF         MOV       R3,#-0x1
   \   000070   8004         SJMP      ??MAC_Send_3
    110              }
    111            }
    112            return 0;
   \                     ??MAC_Send_5:
   \   000072   7A00         MOV       R2,#0x0
   \   000074   7B00         MOV       R3,#0x0
   \                     ??MAC_Send_3:
   \   000076   D0..         POP       ?VB
   \   000078   D0E0         POP       A
   \   00007A   FF           MOV       R7,A
   \   00007B   D0E0         POP       A
   \   00007D   FE           MOV       R6,A
   \   00007E   02....       LJMP      ?BRET
    113          }
E:\Neocore\Hardware\PRJ Test\main.c
      1          #include "utest.h"
      2          #include "stdint.h"
      3          #include "stdio.h"
      4          #include "debug.h"
      5          
      6                

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
      7          void main(){
   \                     main:
   \   000000                ; Auto size: 0
      8            run_tests();
   \   000000                ; Setup parameters for call to function run_tests
   \   000000   12....       LCALL     `??run_tests::?relay`; Banked call to: run_tests
      9            while(1);
   \                     ??main_0:
   \   000003   80FE         SJMP      ??main_0
     10          }
E:\Neocore\Hardware\STACK_CORE_SRC\mem_slots.c
      1          #include "debug.h"
      2          #include "global.h"
      3          #include "macros.h"

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant bool is_array_ptr(void *, void *, size_t)
   \                     ??is_array_ptr:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   90FFF3       MOV       DPTR,#-0xd
   \   00000C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   F5..         MOV       ?V0,A
   \   000012   A3           INC       DPTR
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F5..         MOV       ?V1,A
   \   000016   EC           MOV       A,R4
   \   000017   C3           CLR       C
   \   000018   9E           SUBB      A,R6
   \   000019   F8           MOV       R0,A
   \   00001A   ED           MOV       A,R5
   \   00001B   9F           SUBB      A,R7
   \   00001C   F9           MOV       R1,A
   \   00001D   AA..         MOV       R2,?V0
   \   00001F   AB..         MOV       R3,?V1
   \   000021   12....       LCALL     ?US_DIV_MOD
   \   000024   8A..         MOV       ?V2,R2
   \   000026   8B..         MOV       ?V3,R3
   \   000028   A8..         MOV       R0,?V2
   \   00002A   A9..         MOV       R1,?V3
   \   00002C   E8           MOV       A,R0
   \   00002D   49           ORL       A,R1
   \   00002E   7004         JNZ       ??is_array_ptr_1
   \   000030   D2F0         SETB      B.0
   \   000032   8002         SJMP      ??is_array_ptr_2
   \                     ??is_array_ptr_1:
   \   000034   C2F0         CLR       B.0
   \                     ??is_array_ptr_2:
   \   000036   A2F0         MOV       C,B.0
   \   000038   7F04         MOV       R7,#0x4
   \   00003A   02....       LJMP      ?BANKED_LEAVE_SP

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant size_t array_index(void *, void *, size_t)
   \                     ??array_index:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   90FFF3       MOV       DPTR,#-0xd
   \   00000C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   F5..         MOV       ?V0,A
   \   000012   A3           INC       DPTR
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F5..         MOV       ?V1,A
   \   000016   EC           MOV       A,R4
   \   000017   C3           CLR       C
   \   000018   9E           SUBB      A,R6
   \   000019   F8           MOV       R0,A
   \   00001A   ED           MOV       A,R5
   \   00001B   9F           SUBB      A,R7
   \   00001C   F9           MOV       R1,A
   \   00001D   AA..         MOV       R2,?V0
   \   00001F   AB..         MOV       R3,?V1
   \   000021   12....       LCALL     ?US_DIV_MOD
   \   000024   88..         MOV       ?V2,R0
   \   000026   89..         MOV       ?V3,R1
   \   000028   AA..         MOV       R2,?V2
   \   00002A   AB..         MOV       R3,?V3
   \   00002C   7F04         MOV       R7,#0x4
   \   00002E   02....       LJMP      ?BANKED_LEAVE_SP
      4          #include "stdbool.h"
      5          #include "action_manager.h"
      6          #include "mem_utils.h"  
      7          #include "cpu.h"

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant char __cli(void)
   \                     ??__cli_2:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   C2AF         CLR       0xa8.7
   \   000002   7901         MOV       R1,#0x1
   \   000004   02....       LJMP      ?BRET
   \   000007                REQUIRE _A_IEN0
      8          
      9          //!< Максимальный размер данных в одном слоте
     10          #define SLOT_BUFFER_SIZE 150
     11          #define RED_ZONE_CODE 0x73
     12          
     13          typedef char red_zone_t;
     14          
     15          static void SW_Init(void);

   \                                 In  segment XDATA_I, align 1, keep-with-next
     16          module_s MS_MODULE = {ALIAS(SW_Init)};
   \                     MS_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for MS_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     17          
     18          struct property{
     19            char taken: 1;
     20          };
     21          
     22          struct slot{
     23            struct property property;
     24            red_zone_t red_zone_1;
     25            char buffer[SLOT_BUFFER_SIZE];
     26            red_zone_t red_zone_2;
     27          };
     28          
     29          //!< Хранилище слотов

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     30          static struct slot SLOT_POOL[SLOT_POOL_ITEMS];
   \                     ??SLOT_POOL:
   \   000000                DS 3060
   \   000BF4                REQUIRE __INIT_XDATA_Z
     31          //!< Количество занятых слотов

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     32          static int slot_busy;
   \                     ??slot_busy:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     33          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     34          void SW_Init(void){
   \                     ??SW_Init_5:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 4
   \   000006   7404         MOV       A,#0x4
   \   000008   12....       LCALL     ?ALLOC_EXT_STACK8
     35            slot_busy = 0;
   \   00000B   90....       MOV       DPTR,#??slot_busy
   \   00000E   7400         MOV       A,#0x0
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   7400         MOV       A,#0x0
   \   000014   F0           MOVX      @DPTR,A
     36            for_each_type(struct slot, SLOT_POOL, slot){
   \   000015   7E..         MOV       R6,#??SLOT_POOL & 0xff
   \   000017   7F..         MOV       R7,#(??SLOT_POOL >> 8) & 0xff
   \                     ??SW_Init_14:
   \   000019   C3           CLR       C
   \   00001A   EE           MOV       A,R6
   \   00001B   94..         SUBB      A,#(??SLOT_POOL + 244) & 0xff
   \   00001D   EF           MOV       A,R7
   \   00001E   94..         SUBB      A,#((??SLOT_POOL + 3060) >> 8) & 0xff
   \   000020   505E         JNC       ??SW_Init_15
     37              slot->property.taken = false;
   \   000022   8E82         MOV       DPL,R6
   \   000024   8F83         MOV       DPH,R7
   \   000026   E0           MOVX      A,@DPTR
   \   000027   C2E0         CLR       0xE0 /* A   */.0
   \   000029   F0           MOVX      @DPTR,A
     38              #ifdef FILL_SLOT_ZERO
     39                MEMSET(slot->buffer, 0, SLOT_BUFFER_SIZE);
   \   00002A   90....       MOV       DPTR,#`?<Constant {(char *)0, 150, 0}>`
   \   00002D   C082         PUSH      DPL
   \   00002F   C083         PUSH      DPH
   \   000031   90FFF9       MOV       DPTR,#-0x7
   \   000034   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000037   AC82         MOV       R4,DPL
   \   000039   AD83         MOV       R5,DPH
   \   00003B   D083         POP       DPH
   \   00003D   D082         POP       DPL
   \   00003F   7404         MOV       A,#0x4
   \   000041   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   000044   EE           MOV       A,R6
   \   000045   2402         ADD       A,#0x2
   \   000047   F8           MOV       R0,A
   \   000048   E4           CLR       A
   \   000049   3F           ADDC      A,R7
   \   00004A   F9           MOV       R1,A
   \   00004B   90FFFB       MOV       DPTR,#-0x5
   \   00004E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000051   E8           MOV       A,R0
   \   000052   F0           MOVX      @DPTR,A
   \   000053   A3           INC       DPTR
   \   000054   E9           MOV       A,R1
   \   000055   F0           MOVX      @DPTR,A
   \   000056                ; Setup parameters for call to function MEM_memset
   \   000056   90FFFB       MOV       DPTR,#-0x5
   \   000059   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00005C   AA82         MOV       R2,DPL
   \   00005E   AB83         MOV       R3,DPH
   \   000060   12....       LCALL     `??MEM_memset::?relay`; Banked call to: MEM_memset
     40              #endif    
     41              slot->red_zone_1 = RED_ZONE_CODE;
   \   000063   8E82         MOV       DPL,R6
   \   000065   8F83         MOV       DPH,R7
   \   000067   A3           INC       DPTR
   \   000068   7473         MOV       A,#0x73
   \   00006A   F0           MOVX      @DPTR,A
     42              slot->red_zone_2 = RED_ZONE_CODE;
   \   00006B   EE           MOV       A,R6
   \   00006C   2498         ADD       A,#-0x68
   \   00006E   F582         MOV       DPL,A
   \   000070   E4           CLR       A
   \   000071   3F           ADDC      A,R7
   \   000072   F583         MOV       DPH,A
   \   000074   7473         MOV       A,#0x73
   \   000076   F0           MOVX      @DPTR,A
     43            }
   \   000077   EE           MOV       A,R6
   \   000078   2499         ADD       A,#-0x67
   \   00007A   FE           MOV       R6,A
   \   00007B   509C         JNC       ??SW_Init_14
   \   00007D   0F           INC       R7
   \   00007E   8099         SJMP      ??SW_Init_14
     44          };
   \                     ??SW_Init_15:
   \   000080   74FC         MOV       A,#-0x4
   \   000082   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000085   D0E0         POP       A
   \   000087   FF           MOV       R7,A
   \   000088   D0E0         POP       A
   \   00008A   FE           MOV       R6,A
   \   00008B   02....       LJMP      ?BRET

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {(char *)0, 150, 0}>`:
   \   000000   0000         DW 0H
   \   000002   96           DB 150
   \   000003   00           DB 0
     45          
     46          /**
     47          @brief Возвращает указатель на буфер или NULL. Буфер заполнен 0
     48          @detail 
     49          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     50          char* SL_alloc(void){  
   \                     SL_alloc:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   7403         MOV       A,#0x3
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 6
   \   000005                ; Auto size: 4
   \   000005   7404         MOV       A,#0x4
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
     51            char *ret_ptr = NULL;
   \   00000A   75..00       MOV       ?V0,#0x0
   \   00000D   75..00       MOV       ?V1,#0x0
     52            ATOMIC_BLOCK_RESTORE{
   \   000010   A2AF         MOV       C,0xa8.7
   \   000012   E4           CLR       A
   \   000013   33           RLC       A
   \   000014   F5..         MOV       ?V2,A
   \   000016                ; Setup parameters for call to function __cli
   \   000016   12....       LCALL     `??__cli::?relay_2`; Banked call to: __cli
   \   000019   E9           MOV       A,R1
   \   00001A   F8           MOV       R0,A
   \                     ??SL_alloc_0:
   \   00001B   E8           MOV       A,R0
   \   00001C   7003         JNZ       $+5
   \   00001E   02....       LJMP      ??SL_alloc_1 & 0xFFFF
     53              for_each_type(struct slot, SLOT_POOL, slot){
   \   000021   7E..         MOV       R6,#??SLOT_POOL & 0xff
   \   000023   7F..         MOV       R7,#(??SLOT_POOL >> 8) & 0xff
   \                     ??SL_alloc_2:
   \   000025   C3           CLR       C
   \   000026   EE           MOV       A,R6
   \   000027   94..         SUBB      A,#(??SLOT_POOL + 244) & 0xff
   \   000029   EF           MOV       A,R7
   \   00002A   94..         SUBB      A,#((??SLOT_POOL + 3060) >> 8) & 0xff
   \   00002C   506C         JNC       ??SL_alloc_3
     54                if (!slot->property.taken){
   \   00002E   8E82         MOV       DPL,R6
   \   000030   8F83         MOV       DPH,R7
   \   000032   E0           MOVX      A,@DPTR
   \   000033   A2E0         MOV       C,0xE0 /* A   */.0
   \   000035   405A         JC        ??SL_alloc_4
     55                  slot->property.taken = true;
   \   000037   8E82         MOV       DPL,R6
   \   000039   8F83         MOV       DPH,R7
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   D2E0         SETB      0xE0 /* A   */.0
   \   00003E   F0           MOVX      @DPTR,A
     56                  slot_busy++;
   \   00003F   90....       MOV       DPTR,#??slot_busy
   \   000042   E0           MOVX      A,@DPTR
   \   000043   2401         ADD       A,#0x1
   \   000045   F0           MOVX      @DPTR,A
   \   000046   A3           INC       DPTR
   \   000047   E0           MOVX      A,@DPTR
   \   000048   3400         ADDC      A,#0x0
   \   00004A   F0           MOVX      @DPTR,A
     57                  #ifdef FILL_SLOT_ZERO
     58                    MEMSET(slot->buffer, 0, SLOT_BUFFER_SIZE);
   \   00004B   90....       MOV       DPTR,#`?<Constant {(char *)0, 150, 0}>_1`
   \   00004E   C082         PUSH      DPL
   \   000050   C083         PUSH      DPH
   \   000052   90FFF9       MOV       DPTR,#-0x7
   \   000055   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000058   AC82         MOV       R4,DPL
   \   00005A   AD83         MOV       R5,DPH
   \   00005C   D083         POP       DPH
   \   00005E   D082         POP       DPL
   \   000060   7404         MOV       A,#0x4
   \   000062   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   000065   EE           MOV       A,R6
   \   000066   2402         ADD       A,#0x2
   \   000068   F8           MOV       R0,A
   \   000069   E4           CLR       A
   \   00006A   3F           ADDC      A,R7
   \   00006B   F9           MOV       R1,A
   \   00006C   90FFFB       MOV       DPTR,#-0x5
   \   00006F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000072   E8           MOV       A,R0
   \   000073   F0           MOVX      @DPTR,A
   \   000074   A3           INC       DPTR
   \   000075   E9           MOV       A,R1
   \   000076   F0           MOVX      @DPTR,A
   \   000077                ; Setup parameters for call to function MEM_memset
   \   000077   90FFFB       MOV       DPTR,#-0x5
   \   00007A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00007D   AA82         MOV       R2,DPL
   \   00007F   AB83         MOV       R3,DPH
   \   000081   12....       LCALL     `??MEM_memset::?relay`; Banked call to: MEM_memset
     59                  #endif
     60                  ret_ptr = slot->buffer;
   \   000084   EE           MOV       A,R6
   \   000085   2402         ADD       A,#0x2
   \   000087   F8           MOV       R0,A
   \   000088   E4           CLR       A
   \   000089   3F           ADDC      A,R7
   \   00008A   F9           MOV       R1,A
   \   00008B   88..         MOV       ?V0,R0
   \   00008D   89..         MOV       ?V1,R1
     61                  break;
   \   00008F   8009         SJMP      ??SL_alloc_3
     62                };
     63              };  
   \                     ??SL_alloc_4:
   \   000091   EE           MOV       A,R6
   \   000092   2499         ADD       A,#-0x67
   \   000094   FE           MOV       R6,A
   \   000095   508E         JNC       ??SL_alloc_2
   \   000097   0F           INC       R7
   \   000098   808B         SJMP      ??SL_alloc_2
     64            };
   \                     ??SL_alloc_3:
   \   00009A   7800         MOV       R0,#0x0
   \   00009C   E5..         MOV       A,?V2
   \   00009E   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000A0   92AF         MOV       0xa8.7,C
   \   0000A2   02....       LJMP      ??SL_alloc_0 & 0xFFFF
     65            return ret_ptr;
   \                     ??SL_alloc_1:
   \   0000A5   AA..         MOV       R2,?V0
   \   0000A7   AB..         MOV       R3,?V1
   \   0000A9   74FC         MOV       A,#-0x4
   \   0000AB   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000AE   7F03         MOV       R7,#0x3
   \   0000B0   02....       LJMP      ?BANKED_LEAVE_SP
   \   0000B3                REQUIRE _A_IEN0
     66          };

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {(char *)0, 150, 0}>_1`:
   \   000000   0000         DW 0H
   \   000002   96           DB 150
   \   000003   00           DB 0
     67          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     68          static bool _free(char *buff){
   \                     ??_free:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
     69            struct slot *slot = container_of(buff, struct slot, buffer);
   \   000009   E5..         MOV       A,?V0
   \   00000B   24FE         ADD       A,#-0x2
   \   00000D   FE           MOV       R6,A
   \   00000E   E5..         MOV       A,?V1
   \   000010   34FF         ADDC      A,#-0x1
   \   000012   FF           MOV       R7,A
     70            
     71            if (!is_array_ptr(SLOT_POOL, slot, sizeof(struct slot)))
   \   000013                ; Setup parameters for call to function is_array_ptr
   \   000013   7499         MOV       A,#-0x67
   \   000015   C0E0         PUSH      A
   \   000017   7400         MOV       A,#0x0
   \   000019   C0E0         PUSH      A
   \   00001B   EE           MOV       A,R6
   \   00001C   FC           MOV       R4,A
   \   00001D   EF           MOV       A,R7
   \   00001E   FD           MOV       R5,A
   \   00001F   7A..         MOV       R2,#??SLOT_POOL & 0xff
   \   000021   7B..         MOV       R3,#(??SLOT_POOL >> 8) & 0xff
   \   000023   12....       LCALL     `??is_array_ptr::?relay`; Banked call to: is_array_ptr
   \   000026   D0E0         POP       A
   \   000028   D0E0         POP       A
   \   00002A   4003         JC        ??_free_1
     72              return false;
   \   00002C   C3           CLR       C
   \   00002D   804C         SJMP      ??_free_2
     73            
     74            size_t index = array_index(SLOT_POOL, slot, sizeof(struct slot));
   \                     ??_free_1:
   \   00002F                ; Setup parameters for call to function array_index
   \   00002F   7499         MOV       A,#-0x67
   \   000031   C0E0         PUSH      A
   \   000033   7400         MOV       A,#0x0
   \   000035   C0E0         PUSH      A
   \   000037   EE           MOV       A,R6
   \   000038   FC           MOV       R4,A
   \   000039   EF           MOV       A,R7
   \   00003A   FD           MOV       R5,A
   \   00003B   7A..         MOV       R2,#??SLOT_POOL & 0xff
   \   00003D   7B..         MOV       R3,#(??SLOT_POOL >> 8) & 0xff
   \   00003F   12....       LCALL     `??array_index::?relay`; Banked call to: array_index
   \   000042   D0E0         POP       A
   \   000044   D0E0         POP       A
   \   000046   8A..         MOV       ?V2,R2
   \   000048   8B..         MOV       ?V3,R3
   \   00004A   A8..         MOV       R0,?V2
   \   00004C   A9..         MOV       R1,?V3
     75            if (!(index < SLOT_BUFFER_SIZE))
   \   00004E   C3           CLR       C
   \   00004F   E8           MOV       A,R0
   \   000050   9496         SUBB      A,#-0x6a
   \   000052   E9           MOV       A,R1
   \   000053   9400         SUBB      A,#0x0
   \   000055   4003         JC        ??_free_3
     76              return false;
   \   000057   C3           CLR       C
   \   000058   8021         SJMP      ??_free_2
     77            
     78            if (slot->property.taken != true)
   \                     ??_free_3:
   \   00005A   8E82         MOV       DPL,R6
   \   00005C   8F83         MOV       DPH,R7
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   A2E0         MOV       C,0xE0 /* A   */.0
   \   000061   4003         JC        ??_free_4
     79              return false;
   \   000063   C3           CLR       C
   \   000064   8015         SJMP      ??_free_2
     80              
     81            slot->property.taken = false;
   \                     ??_free_4:
   \   000066   8E82         MOV       DPL,R6
   \   000068   8F83         MOV       DPH,R7
   \   00006A   E0           MOVX      A,@DPTR
   \   00006B   C2E0         CLR       0xE0 /* A   */.0
   \   00006D   F0           MOVX      @DPTR,A
     82            slot_busy--;
   \   00006E   90....       MOV       DPTR,#??slot_busy
   \   000071   E0           MOVX      A,@DPTR
   \   000072   24FF         ADD       A,#-0x1
   \   000074   F0           MOVX      @DPTR,A
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   34FF         ADDC      A,#-0x1
   \   000079   F0           MOVX      @DPTR,A
     83            return true;
   \   00007A   D3           SETB      C
   \                     ??_free_2:
   \   00007B   7F04         MOV       R7,#0x4
   \   00007D   02....       LJMP      ?BANKED_LEAVE_SP
     84          }
     85          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     86          bool SL_free(char *buff){
   \                     SL_free:
   \   000000                REQUIRE ?V0
   \   000000   7401         MOV       A,#0x1
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 4
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
     87            bool res;
     88            ATOMIC_BLOCK_RESTORE{
   \   000009   A2AF         MOV       C,0xa8.7
   \   00000B   E4           CLR       A
   \   00000C   33           RLC       A
   \   00000D   F5..         MOV       ?V0,A
   \   00000F                ; Setup parameters for call to function __cli
   \   00000F   12....       LCALL     `??__cli::?relay_2`; Banked call to: __cli
   \   000012   E9           MOV       A,R1
   \   000013   F8           MOV       R0,A
   \                     ??SL_free_0:
   \   000014   E8           MOV       A,R0
   \   000015   6013         JZ        ??SL_free_1
     89              res = _free(buff);
   \   000017                ; Setup parameters for call to function _free
   \   000017   EE           MOV       A,R6
   \   000018   FA           MOV       R2,A
   \   000019   EF           MOV       A,R7
   \   00001A   FB           MOV       R3,A
   \   00001B   12....       LCALL     `??_free::?relay`; Banked call to: _free
   \   00001E   92..         MOV       ?VB.0,C
     90            }
   \   000020   7800         MOV       R0,#0x0
   \   000022   E5..         MOV       A,?V0
   \   000024   A2E0         MOV       C,0xE0 /* A   */.0
   \   000026   92AF         MOV       0xa8.7,C
   \   000028   80EA         SJMP      ??SL_free_0
     91            return res;
   \                     ??SL_free_1:
   \   00002A   A2..         MOV       C,?VB.0
   \   00002C   7F01         MOV       R7,#0x1
   \   00002E   02....       LJMP      ?BANKED_LEAVE_SP
   \   000031                REQUIRE _A_IEN0
     92          };
     93          
     94          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     95          int SL_busy(){
   \                     SL_busy:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     96            ASSERT(slot_busy <= SLOT_POOL_ITEMS);
   \   000000   90....       MOV       DPTR,#??slot_busy
   \   000003   C3           CLR       C
   \   000004   E0           MOVX      A,@DPTR
   \   000005   9415         SUBB      A,#0x15
   \   000007   A3           INC       DPTR
   \   000008   E0           MOVX      A,@DPTR
   \   000009   9400         SUBB      A,#0x0
   \   00000B   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00000D   65D0         XRL       A,PSW
   \   00000F   33           RLC       A
   \   000010   401F         JC        ??SL_busy_0
   \   000012                ; Setup parameters for call to function printf
   \   000012   7460         MOV       A,#0x60
   \   000014   C0E0         PUSH      A
   \   000016   7400         MOV       A,#0x0
   \   000018   C0E0         PUSH      A
   \   00001A   74..         MOV       A,#`?<Constant "mem_slots.c">` & 0xff
   \   00001C   C0E0         PUSH      A
   \   00001E   74..         MOV       A,#(`?<Constant "mem_slots.c">` >> 8) & 0xff
   \   000020   C0E0         PUSH      A
   \   000022   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_4` & 0xff
   \   000024   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_4` >> 8) & 0xff
   \   000026   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000029   74FC         MOV       A,#-0x4
   \   00002B   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002E                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002E   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     97            return slot_busy;
   \                     ??SL_busy_0:
   \   000031   90....       MOV       DPTR,#??slot_busy
   \   000034   E0           MOVX      A,@DPTR
   \   000035   FA           MOV       R2,A
   \   000036   A3           INC       DPTR
   \   000037   E0           MOVX      A,@DPTR
   \   000038   FB           MOV       R3,A
   \   000039   02....       LJMP      ?BRET
     98          };
     99          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    100          int SL_available(){
   \                     SL_available:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    101            ASSERT(slot_busy <= SLOT_POOL_ITEMS);  
   \   000000   90....       MOV       DPTR,#??slot_busy
   \   000003   C3           CLR       C
   \   000004   E0           MOVX      A,@DPTR
   \   000005   9415         SUBB      A,#0x15
   \   000007   A3           INC       DPTR
   \   000008   E0           MOVX      A,@DPTR
   \   000009   9400         SUBB      A,#0x0
   \   00000B   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00000D   65D0         XRL       A,PSW
   \   00000F   33           RLC       A
   \   000010   401F         JC        ??SL_available_0
   \   000012                ; Setup parameters for call to function printf
   \   000012   7465         MOV       A,#0x65
   \   000014   C0E0         PUSH      A
   \   000016   7400         MOV       A,#0x0
   \   000018   C0E0         PUSH      A
   \   00001A   74..         MOV       A,#`?<Constant "mem_slots.c">` & 0xff
   \   00001C   C0E0         PUSH      A
   \   00001E   74..         MOV       A,#(`?<Constant "mem_slots.c">` >> 8) & 0xff
   \   000020   C0E0         PUSH      A
   \   000022   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_4` & 0xff
   \   000024   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_4` >> 8) & 0xff
   \   000026   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000029   74FC         MOV       A,#-0x4
   \   00002B   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002E                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002E   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    102            return SLOT_POOL_ITEMS - slot_busy;
   \                     ??SL_available_0:
   \   000031   90....       MOV       DPTR,#??slot_busy
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F8           MOV       R0,A
   \   000036   A3           INC       DPTR
   \   000037   E0           MOVX      A,@DPTR
   \   000038   F9           MOV       R1,A
   \   000039   7414         MOV       A,#0x14
   \   00003B   C3           CLR       C
   \   00003C   98           SUBB      A,R0
   \   00003D   FA           MOV       R2,A
   \   00003E   7400         MOV       A,#0x0
   \   000040   99           SUBB      A,R1
   \   000041   FB           MOV       R3,A
   \   000042   02....       LJMP      ?BRET
    103          };
    104          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    105          int SL_zone_check(){
   \                     SL_zone_check:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    106            int index = 0;
   \   000000   7C00         MOV       R4,#0x0
   \   000002   7D00         MOV       R5,#0x0
    107            for_each_type(struct slot, SLOT_POOL, slot){
   \   000004   78..         MOV       R0,#??SLOT_POOL & 0xff
   \   000006   79..         MOV       R1,#(??SLOT_POOL >> 8) & 0xff
   \                     ??SL_zone_check_0:
   \   000008   C3           CLR       C
   \   000009   E8           MOV       A,R0
   \   00000A   94..         SUBB      A,#(??SLOT_POOL + 244) & 0xff
   \   00000C   E9           MOV       A,R1
   \   00000D   94..         SUBB      A,#((??SLOT_POOL + 3060) >> 8) & 0xff
   \   00000F   502C         JNC       ??SL_zone_check_1
    108              if (!(slot->red_zone_1 == RED_ZONE_CODE &&
    109                    slot->red_zone_2 == RED_ZONE_CODE))
   \   000011   8882         MOV       DPL,R0
   \   000013   8983         MOV       DPH,R1
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   6473         XRL       A,#0x73
   \   000019   700E         JNZ       ??SL_zone_check_2
   \   00001B   E8           MOV       A,R0
   \   00001C   2498         ADD       A,#-0x68
   \   00001E   F582         MOV       DPL,A
   \   000020   E4           CLR       A
   \   000021   39           ADDC      A,R1
   \   000022   F583         MOV       DPH,A
   \   000024   E0           MOVX      A,@DPTR
   \   000025   6473         XRL       A,#0x73
   \   000027   6006         JZ        ??SL_zone_check_3
    110                return index;
   \                     ??SL_zone_check_2:
   \   000029   EC           MOV       A,R4
   \   00002A   FA           MOV       R2,A
   \   00002B   ED           MOV       A,R5
   \   00002C   FB           MOV       R3,A
   \   00002D   8012         SJMP      ??SL_zone_check_4
    111              index++;
   \                     ??SL_zone_check_3:
   \   00002F   0C           INC       R4
   \   000030   EC           MOV       A,R4
   \   000031   7001         JNZ       ??SL_zone_check_5
   \   000033   0D           INC       R5
    112            }
   \                     ??SL_zone_check_5:
   \   000034   E8           MOV       A,R0
   \   000035   2499         ADD       A,#-0x67
   \   000037   F8           MOV       R0,A
   \   000038   50CE         JNC       ??SL_zone_check_0
   \   00003A   09           INC       R1
   \   00003B   80CB         SJMP      ??SL_zone_check_0
    113            return -1;
   \                     ??SL_zone_check_1:
   \   00003D   7AFF         MOV       R2,#-0x1
   \   00003F   7BFF         MOV       R3,#-0x1
   \                     ??SL_zone_check_4:
   \   000041   02....       LJMP      ?BRET
    114          };
    115          
E:\Neocore\Hardware\STACK_CORE_SRC\mem_utils.c
      1          #include "mem_utils.h"
      2          #include "debug.h"
      3          
      4          /**
      5          @file Реентерабельное копирование
      6          */
      7          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
      8          void MEM_memcpy(struct memcpy *memcpy){
   \                     MEM_memcpy:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
      9            while (memcpy->len > 0){
   \                     ??MEM_memcpy_0:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   E0           MOVX      A,@DPTR
   \   000009   605E         JZ        ??MEM_memcpy_1
     10              *memcpy->dst = *memcpy->src;
   \   00000B   8A82         MOV       DPL,R2
   \   00000D   8B83         MOV       DPH,R3
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   F8           MOV       R0,A
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F583         MOV       DPH,A
   \   000017   8882         MOV       DPL,R0
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   C0E0         PUSH      A
   \   00001C   8A82         MOV       DPL,R2
   \   00001E   8B83         MOV       DPH,R3
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F8           MOV       R0,A
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   F583         MOV       DPH,A
   \   000026   8882         MOV       DPL,R0
   \   000028   D0E0         POP       A
   \   00002A   F0           MOVX      @DPTR,A
     11              memcpy->dst++;
   \   00002B   8A82         MOV       DPL,R2
   \   00002D   8B83         MOV       DPH,R3
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   2401         ADD       A,#0x1
   \   000032   F8           MOV       R0,A
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   3400         ADDC      A,#0x0
   \   000037   F9           MOV       R1,A
   \   000038   8A82         MOV       DPL,R2
   \   00003A   8B83         MOV       DPH,R3
   \   00003C   E8           MOV       A,R0
   \   00003D   F0           MOVX      @DPTR,A
   \   00003E   A3           INC       DPTR
   \   00003F   E9           MOV       A,R1
   \   000040   F0           MOVX      @DPTR,A
     12              memcpy->src++;
   \   000041   8A82         MOV       DPL,R2
   \   000043   8B83         MOV       DPH,R3
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   E0           MOVX      A,@DPTR
   \   000048   2401         ADD       A,#0x1
   \   00004A   F8           MOV       R0,A
   \   00004B   A3           INC       DPTR
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   3400         ADDC      A,#0x0
   \   00004F   F9           MOV       R1,A
   \   000050   8A82         MOV       DPL,R2
   \   000052   8B83         MOV       DPH,R3
   \   000054   A3           INC       DPTR
   \   000055   A3           INC       DPTR
   \   000056   E8           MOV       A,R0
   \   000057   F0           MOVX      @DPTR,A
   \   000058   A3           INC       DPTR
   \   000059   E9           MOV       A,R1
   \   00005A   F0           MOVX      @DPTR,A
     13              memcpy->len--;
   \   00005B   8A82         MOV       DPL,R2
   \   00005D   8B83         MOV       DPH,R3
   \   00005F   A3           INC       DPTR
   \   000060   A3           INC       DPTR
   \   000061   A3           INC       DPTR
   \   000062   A3           INC       DPTR
   \   000063   E0           MOVX      A,@DPTR
   \   000064   24FF         ADD       A,#-0x1
   \   000066   F0           MOVX      @DPTR,A
   \   000067   8097         SJMP      ??MEM_memcpy_0
     14            }
     15          };
   \                     ??MEM_memcpy_1:
   \   000069   02....       LJMP      ?BRET
     16          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     17          void MEM_memset(struct memset *memset){
   \                     MEM_memset:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     18            while (memset->len > 0){
   \                     ??MEM_memset_0:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   603B         JZ        ??MEM_memset_1
     19              *memset->dst = memset->val;
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   E0           MOVX      A,@DPTR
   \   000011   C0E0         PUSH      A
   \   000013   8A82         MOV       DPL,R2
   \   000015   8B83         MOV       DPH,R3
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F8           MOV       R0,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F583         MOV       DPH,A
   \   00001D   8882         MOV       DPL,R0
   \   00001F   D0E0         POP       A
   \   000021   F0           MOVX      @DPTR,A
     20              memset->dst++;
   \   000022   8A82         MOV       DPL,R2
   \   000024   8B83         MOV       DPH,R3
   \   000026   E0           MOVX      A,@DPTR
   \   000027   2401         ADD       A,#0x1
   \   000029   F8           MOV       R0,A
   \   00002A   A3           INC       DPTR
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   3400         ADDC      A,#0x0
   \   00002E   F9           MOV       R1,A
   \   00002F   8A82         MOV       DPL,R2
   \   000031   8B83         MOV       DPH,R3
   \   000033   E8           MOV       A,R0
   \   000034   F0           MOVX      @DPTR,A
   \   000035   A3           INC       DPTR
   \   000036   E9           MOV       A,R1
   \   000037   F0           MOVX      @DPTR,A
     21              memset->len--;
   \   000038   8A82         MOV       DPL,R2
   \   00003A   8B83         MOV       DPH,R3
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   24FF         ADD       A,#-0x1
   \   000041   F0           MOVX      @DPTR,A
   \   000042   80BC         SJMP      ??MEM_memset_0
     22            }  
     23          };
   \                     ??MEM_memset_1:
   \   000044   02....       LJMP      ?BRET
     24          
     25          
E:\Neocore\Hardware\STACK_CORE_SRC\model.c
      1          #include "model.h"
      2          #include "action_manager.h"
      3          
      4          /**
      5          @file
      6          */
      7          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
      8          MODEL_s MODEL;
   \                     MODEL:
   \   000000                DS 152
   \   000098                REQUIRE __INIT_XDATA_Z
      9          
     10            
     11          static void SW_Init(void); 
     12          

   \                                 In  segment XDATA_I, align 1, keep-with-next
     13          module_s MD_MODULE = {ALIAS(SW_Init)};
   \                     MD_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for MD_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     14          
     15           

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     16          static void SW_Init(void){}; 
   \                     ??SW_Init_6:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP      ?BRET
     17          
     18          
E:\Neocore\Hardware\Stack_core_src\radio.c
      1          #include "radio.h"
      2          #include "mem_utils.h"
      3          #include "debug.h"
      4          #include "radio_defs.h"
      5          #include "ustimer.h"
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "alarm_timer.h"
      9          #include "model.h"
     10          #include "action_manager.h"
     11          #include "frame.h"
     12          #include "macros.h"
     13          #include "stdlib.h"
     14          
     15          static void HW_Init(void);
     16          static void SW_Init(void);

   \                                 In  segment XDATA_I, align 1, keep-with-next
     17          module_s RADIO_MODULE = {ALIAS(SW_Init), ALIAS(HW_Init)};
   \                     RADIO_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for RADIO_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     18          
     19          static void random_core_init(void);

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     20          static char RXBUFF[128];
   \                     ??RXBUFF:
   \   000000                DS 128
   \   000080                REQUIRE __INIT_XDATA_Z
     21          
     22          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     23          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     24          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     25          /*!
     26          \details 
     27           Расчет качества связи. Коэффициенты получаются эксперементально.
     28           Есть предположение, что количество ошибок будет пропорционально квадрату
     29           коеффициента корреляции сигнала.
     30           LIQ = 255 передача 1000 пакетов без ошибок CRC
     31           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     32           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     33          */ 
     34          
     35          #define CONST_A (int8_t)0 //!< Коэффициент A
     36          #define CONST_B (int8_t)1 //!< Коэффициент B
     37          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     38          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     39          
     40          #ifdef RADIO_DEBUG
     41            #define WRITE_TIME_DBG(where) (where) = AT_time()
     42            #define WRITE_PARA_DBG(where,val) (where) = (val) 
     43          #else
     44            #define WRITE_TIME_DBG(where) {}
     45            #define WRITE_PARA_DBG(where,val)
     46          #endif
     47          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     48          static void SW_Init(void){
   \                     ??SW_Init_7:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     49            // Настройки поумолчанию
     50            MODEL.RADIO.CRCError = 0;
   \   000000   90....       MOV       DPTR,#MODEL + 87
   \   000003   7400         MOV       A,#0x0
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   7400         MOV       A,#0x0
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   A3           INC       DPTR
   \   00000B   7400         MOV       A,#0x0
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   A3           INC       DPTR
   \   00000F   7400         MOV       A,#0x0
   \   000011   F0           MOVX      @DPTR,A
     51            MODEL.RADIO.CCAReject = 0;
   \   000012   90....       MOV       DPTR,#MODEL + 91
   \   000015   7400         MOV       A,#0x0
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   7400         MOV       A,#0x0
   \   00001B   F0           MOVX      @DPTR,A
   \   00001C   A3           INC       DPTR
   \   00001D   7400         MOV       A,#0x0
   \   00001F   F0           MOVX      @DPTR,A
   \   000020   A3           INC       DPTR
   \   000021   7400         MOV       A,#0x0
   \   000023   F0           MOVX      @DPTR,A
     52            MODEL.RADIO.channel = CH11;
   \   000024   90....       MOV       DPTR,#MODEL + 96
   \   000027   740B         MOV       A,#0xb
   \   000029   F0           MOVX      @DPTR,A
     53            MODEL.RADIO.power_tx = m0x5;
   \   00002A   90....       MOV       DPTR,#MODEL + 95
   \   00002D   74C5         MOV       A,#-0x3b
   \   00002F   F0           MOVX      @DPTR,A
     54            // Пост действия с радио
     55            random_core_init();
   \   000030                ; Setup parameters for call to function random_core_init
   \   000030   12....       LCALL     `??random_core_init::?relay`; Banked call to: random_core_init
     56          }
   \   000033   02....       LJMP      ?BRET
     57          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     58          static void HW_Init(void){
   \                     ??HW_Init_6:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 1
   \   000000   C0E0         PUSH      A
     59            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
   \   000002   906180       MOV       DPTR,#0x6180
   \   000005   7400         MOV       A,#0x0
   \   000007   F0           MOVX      @DPTR,A
     60            MDMTEST1_u MDM1; // Устанавливаем режим модуляции
     61            MDM1.value = MDMTEST1;
   \   000008   9061B9       MOV       DPTR,#0x61b9
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   C0E0         PUSH      A
   \   00000E   90FFFD       MOV       DPTR,#-0x3
   \   000011   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000014   D0E0         POP       A
   \   000016   F0           MOVX      @DPTR,A
     62            MDM1.bits.MODULATION_MODE = IEEE_MODE;
   \   000017   858182       MOV       DPL,SP
   \   00001A   E5..         MOV       A,?ESP
   \   00001C   54..         ANL       A,#?ESP_MASK
   \   00001E   44..         ORL       A,#(SFB(EXT_STACK) >> 8) & 0xff
   \   000020   F583         MOV       DPH,A
   \   000022   E0           MOVX      A,@DPTR
   \   000023   C2E1         CLR       0xE0 /* A   */.1
   \   000025   F0           MOVX      @DPTR,A
     63            MDMTEST1 = MDM1.value;   
   \   000026   858182       MOV       DPL,SP
   \   000029   E5..         MOV       A,?ESP
   \   00002B   54..         ANL       A,#?ESP_MASK
   \   00002D   44..         ORL       A,#(SFB(EXT_STACK) >> 8) & 0xff
   \   00002F   F583         MOV       DPH,A
   \   000031   E0           MOVX      A,@DPTR
   \   000032   9061B9       MOV       DPTR,#0x61b9
   \   000035   F0           MOVX      @DPTR,A
     64          }
   \   000036   D0E0         POP       A
   \   000038   02....       LJMP      ?BRET
     65          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     66          static inline void setFreq(channel_t ch)
   \                     ??setFreq:
     67          {
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 1
   \   000003   C0E0         PUSH      A
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
     68            ASSERT( (ch >= MIN_CH) && (ch <= MAX_CH));
   \   000007   EE           MOV       A,R6
   \   000008   C3           CLR       C
   \   000009   940B         SUBB      A,#0xb
   \   00000B   4006         JC        ??setFreq_1
   \   00000D   EE           MOV       A,R6
   \   00000E   C3           CLR       C
   \   00000F   941D         SUBB      A,#0x1d
   \   000011   401F         JC        ??setFreq_2
   \                     ??setFreq_1:
   \   000013                ; Setup parameters for call to function printf
   \   000013   7444         MOV       A,#0x44
   \   000015   C0E0         PUSH      A
   \   000017   7400         MOV       A,#0x0
   \   000019   C0E0         PUSH      A
   \   00001B   74..         MOV       A,#`?<Constant "radio.c">` & 0xff
   \   00001D   C0E0         PUSH      A
   \   00001F   74..         MOV       A,#(`?<Constant "radio.c">` >> 8) & 0xff
   \   000021   C0E0         PUSH      A
   \   000023   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_5` & 0xff
   \   000025   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_5` >> 8) & 0xff
   \   000027   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00002A   74FC         MOV       A,#-0x4
   \   00002C   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002F                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002F   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     69            // Устанавливаем частоту радиопередатчика
     70            FREQCTRL_u FRQ;
     71            FRQ.value = FRQ_CALC(MODEL.RADIO.channel);
   \                     ??setFreq_2:
   \   000032   75F005       MOV       B,#0x5
   \   000035   90....       MOV       DPTR,#MODEL + 96
   \   000038   E0           MOVX      A,@DPTR
   \   000039   A4           MUL       AB
   \   00003A   24D4         ADD       A,#-0x2c
   \   00003C   C0E0         PUSH      A
   \   00003E   90FFFD       MOV       DPTR,#-0x3
   \   000041   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000044   D0E0         POP       A
   \   000046   F0           MOVX      @DPTR,A
     72            FREQCTRL = FRQ.value;  
   \   000047   858182       MOV       DPL,SP
   \   00004A   E5..         MOV       A,?ESP
   \   00004C   54..         ANL       A,#?ESP_MASK
   \   00004E   44..         ORL       A,#(SFB(EXT_STACK) >> 8) & 0xff
   \   000050   F583         MOV       DPH,A
   \   000052   E0           MOVX      A,@DPTR
   \   000053   90618F       MOV       DPTR,#0x618f
   \   000056   F0           MOVX      @DPTR,A
     73          }
   \   000057   D0E0         POP       A
   \   000059   D0E0         POP       A
   \   00005B   FE           MOV       R6,A
   \   00005C   02....       LJMP      ?BRET
     74          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     75          static inline void pre_config(void){
   \                     ??pre_config:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     76            setFreq(MODEL.RADIO.channel); 
   \   000000                ; Setup parameters for call to function setFreq
   \   000000   90....       MOV       DPTR,#MODEL + 96
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   12....       LCALL     `??setFreq::?relay`; Banked call to: setFreq
     77            TXPOWER = MODEL.RADIO.power_tx;
   \   000008   90....       MOV       DPTR,#MODEL + 95
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   906190       MOV       DPTR,#0x6190
   \   00000F   F0           MOVX      @DPTR,A
     78          }
   \   000010   02....       LJMP      ?BRET
     79          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     80          bool RI_SetChannel(channel_t channel){
   \                     RI_SetChannel:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     81            if (!(channel >= MIN_CH) && (channel <= MAX_CH))
   \   000000   E9           MOV       A,R1
   \   000001   C3           CLR       C
   \   000002   940B         SUBB      A,#0xb
   \   000004   5009         JNC       ??RI_SetChannel_0
   \   000006   E9           MOV       A,R1
   \   000007   C3           CLR       C
   \   000008   941D         SUBB      A,#0x1d
   \   00000A   5003         JNC       ??RI_SetChannel_0
     82              return false;
   \   00000C   C3           CLR       C
   \   00000D   8006         SJMP      ??RI_SetChannel_1
     83            MODEL.RADIO.channel = channel;
   \                     ??RI_SetChannel_0:
   \   00000F   E9           MOV       A,R1
   \   000010   90....       MOV       DPTR,#MODEL + 96
   \   000013   F0           MOVX      @DPTR,A
     84            return true;
   \   000014   D3           SETB      C
   \                     ??RI_SetChannel_1:
   \   000015   02....       LJMP      ?BRET
     85          }
     86          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     87          static void LoadTXData(char *src, size_t len){
   \                     ??LoadTXData:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     88            ISFLUSHTX(); // Очищаем буфер передатчика
   \   000000   75E1EE       MOV       0xe1,#-0x12
     89            RFD = len + 2; // Поле LEN на два байта больше
   \   000003   EC           MOV       A,R4
   \   000004   2402         ADD       A,#0x2
   \   000006   F5D9         MOV       0xd9,A
     90            for (size_t i = 0 ; i < len; i++)
   \   000008   7800         MOV       R0,#0x0
   \   00000A   7900         MOV       R1,#0x0
   \                     ??LoadTXData_1:
   \   00000C   C3           CLR       C
   \   00000D   E8           MOV       A,R0
   \   00000E   9C           SUBB      A,R4
   \   00000F   E9           MOV       A,R1
   \   000010   9D           SUBB      A,R5
   \   000011   5012         JNC       ??LoadTXData_2
     91              RFD = src[i];
   \   000013   EA           MOV       A,R2
   \   000014   28           ADD       A,R0
   \   000015   F582         MOV       DPL,A
   \   000017   EB           MOV       A,R3
   \   000018   39           ADDC      A,R1
   \   000019   F583         MOV       DPH,A
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F5D9         MOV       0xd9,A
   \   00001E   08           INC       R0
   \   00001F   E8           MOV       A,R0
   \   000020   70EA         JNZ       ??LoadTXData_1
   \   000022   09           INC       R1
   \   000023   80E7         SJMP      ??LoadTXData_1
     92            RFD = 0x00; // Добавляем CRC1,2
   \                     ??LoadTXData_2:
   \   000025   75D900       MOV       0xd9,#0x0
     93            RFD = 0x00;
   \   000028   75D900       MOV       0xd9,#0x0
     94          };
   \   00002B   02....       LJMP      ?BRET
   \   00002E                REQUIRE RFST
   \   00002E                REQUIRE RFD
     95          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     96          static bool SendData(struct frame *fr){
   \                     ??SendData:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   7402         MOV       A,#0x2
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 5
   \   000005                ; Auto size: 50
   \   000005   7432         MOV       A,#0x32
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
     97            LoadTXData(fr->payload, fr->len);
   \   00000E                ; Setup parameters for call to function LoadTXData
   \   00000E   8E82         MOV       DPL,R6
   \   000010   8F83         MOV       DPH,R7
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FC           MOV       R4,A
   \   000014   7D00         MOV       R5,#0x0
   \   000016   EE           MOV       A,R6
   \   000017   2415         ADD       A,#0x15
   \   000019   FA           MOV       R2,A
   \   00001A   E4           CLR       A
   \   00001B   3F           ADDC      A,R7
   \   00001C   FB           MOV       R3,A
   \   00001D   12....       LCALL     `??LoadTXData::?relay`; Banked call to: LoadTXData
     98            
     99            // Прежде чем включать радио нужно подождать
    100            if (fr->meta.SEND_TIME != 0) 
   \   000020   EE           MOV       A,R6
   \   000021   2413         ADD       A,#0x13
   \   000023   F582         MOV       DPL,A
   \   000025   E4           CLR       A
   \   000026   3F           ADDC      A,R7
   \   000027   F583         MOV       DPH,A
   \   000029   E0           MOVX      A,@DPTR
   \   00002A   F8           MOV       R0,A
   \   00002B   A3           INC       DPTR
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F9           MOV       R1,A
   \   00002E   E8           MOV       A,R0
   \   00002F   49           ORL       A,R1
   \   000030   6015         JZ        ??SendData_1
    101                AT_wait(fr->meta.SEND_TIME - 29);
   \   000032                ; Setup parameters for call to function AT_wait
   \   000032   EE           MOV       A,R6
   \   000033   2413         ADD       A,#0x13
   \   000035   F582         MOV       DPL,A
   \   000037   E4           CLR       A
   \   000038   3F           ADDC      A,R7
   \   000039   F583         MOV       DPH,A
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   24E3         ADD       A,#-0x1d
   \   00003E   FA           MOV       R2,A
   \   00003F   A3           INC       DPTR
   \   000040   E0           MOVX      A,@DPTR
   \   000041   34FF         ADDC      A,#-0x1
   \   000043   FB           MOV       R3,A
   \   000044   12....       LCALL     `??AT_wait::?relay`; Banked call to: AT_wait
    102            
    103            ISRXON();
   \                     ??SendData_1:
   \   000047   75E1E3       MOV       0xe1,#-0x1d
    104            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.isrxon);
   \   00004A                ; Setup parameters for call to function AT_time
   \   00004A   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   00004D   90....       MOV       DPTR,#MODEL + 105
   \   000050   EA           MOV       A,R2
   \   000051   F0           MOVX      @DPTR,A
   \   000052   A3           INC       DPTR
   \   000053   EB           MOV       A,R3
   \   000054   F0           MOVX      @DPTR,A
    105            RFIRQF1 &= ~RFIRQF1_TXDONE;
   \   000055   5391FD       ANL       0x91,#0xfd
    106            RFIRQF0 &= ~RFIRQF0_SFD; 
   \   000058   53E9FD       ANL       0xe9,#0xfd
    107            bool result = true;
   \   00005B   D2..         SETB      ?VB.0
    108            while(!RSSISTAT);
   \                     ??SendData_2:
   \   00005D   906199       MOV       DPTR,#0x6199
   \   000060   E0           MOVX      A,@DPTR
   \   000061   60FA         JZ        ??SendData_2
    109            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.rssistat);
   \   000063                ; Setup parameters for call to function AT_time
   \   000063   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   000066   90....       MOV       DPTR,#MODEL + 107
   \   000069   EA           MOV       A,R2
   \   00006A   F0           MOVX      @DPTR,A
   \   00006B   A3           INC       DPTR
   \   00006C   EB           MOV       A,R3
   \   00006D   F0           MOVX      @DPTR,A
    110            TRY{
   \   00006E   90FFCD       MOV       DPTR,#-0x33
   \   000071   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000074   7408         MOV       A,#0x8
   \   000076                REQUIRE ?V7
   \   000076   12....       LCALL     ?SETJMP_XDATA
   \   000079   8A..         MOV       ?V0,R2
   \   00007B   8B..         MOV       ?V1,R3
   \   00007D   78..         MOV       R0,#?V0
   \   00007F   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for SendData>_0`:
   \   000082   0000         DW        0
   \   000084   01           DB        1
   \   000085   ....         DW        ??SendData_3
   \   000087   ....         DW        ??SendData_4
   \   000089   ....         DW        ??SendData_5
    111              if (fr->meta.SEND_TIME != 0) // Отправка в определеное время
   \                     ??SendData_4:
   \   00008B   EE           MOV       A,R6
   \   00008C   2413         ADD       A,#0x13
   \   00008E   F582         MOV       DPL,A
   \   000090   E4           CLR       A
   \   000091   3F           ADDC      A,R7
   \   000092   F583         MOV       DPH,A
   \   000094   E0           MOVX      A,@DPTR
   \   000095   F8           MOV       R0,A
   \   000096   A3           INC       DPTR
   \   000097   E0           MOVX      A,@DPTR
   \   000098   F9           MOV       R1,A
   \   000099   E8           MOV       A,R0
   \   00009A   49           ORL       A,R1
   \   00009B   6015         JZ        ??SendData_6
    112                AT_wait(fr->meta.SEND_TIME - 13); 
   \   00009D                ; Setup parameters for call to function AT_wait
   \   00009D   EE           MOV       A,R6
   \   00009E   2413         ADD       A,#0x13
   \   0000A0   F582         MOV       DPL,A
   \   0000A2   E4           CLR       A
   \   0000A3   3F           ADDC      A,R7
   \   0000A4   F583         MOV       DPH,A
   \   0000A6   E0           MOVX      A,@DPTR
   \   0000A7   24F3         ADD       A,#-0xd
   \   0000A9   FA           MOV       R2,A
   \   0000AA   A3           INC       DPTR
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   34FF         ADDC      A,#-0x1
   \   0000AE   FB           MOV       R3,A
   \   0000AF   12....       LCALL     `??AT_wait::?relay`; Banked call to: AT_wait
    113              ISTXONCCA();
   \                     ??SendData_6:
   \   0000B2   75E1EA       MOV       0xe1,#-0x16
    114              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.istxoncca);
   \   0000B5                ; Setup parameters for call to function AT_time
   \   0000B5   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   0000B8   90....       MOV       DPTR,#MODEL + 109
   \   0000BB   EA           MOV       A,R2
   \   0000BC   F0           MOVX      @DPTR,A
   \   0000BD   A3           INC       DPTR
   \   0000BE   EB           MOV       A,R3
   \   0000BF   F0           MOVX      @DPTR,A
    115              if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
   \   0000C0   906193       MOV       DPTR,#0x6193
   \   0000C3   E0           MOVX      A,@DPTR
   \   0000C4   A2E3         MOV       C,0xE0 /* A   */.3
   \   0000C6   400F         JC        ??SendData_7
    116                THROW(1);
   \   0000C8   7A01         MOV       R2,#0x1
   \   0000CA   7B00         MOV       R3,#0x0
   \   0000CC   90FFCD       MOV       DPTR,#-0x33
   \   0000CF   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000D2   7408         MOV       A,#0x8
   \   0000D4                REQUIRE ?V7
   \   0000D4   02....       LJMP      ?LONGJMP_XDATA
    117              // Ждем отправки SFD
    118              while (!(RFIRQF0 & RFIRQF0_SFD));
   \                     ??SendData_7:
   \   0000D7   E5E9         MOV       A,0xe9
   \   0000D9   A2E1         MOV       C,0xE0 /* A   */.1
   \   0000DB   50FA         JNC       ??SendData_7
    119              fr->meta.TIMESTAMP = AT_time();
   \   0000DD                ; Setup parameters for call to function AT_time
   \   0000DD   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   0000E0   8E82         MOV       DPL,R6
   \   0000E2   8F83         MOV       DPH,R7
   \   0000E4   A3           INC       DPTR
   \   0000E5   EA           MOV       A,R2
   \   0000E6   F0           MOVX      @DPTR,A
   \   0000E7   A3           INC       DPTR
   \   0000E8   EB           MOV       A,R3
   \   0000E9   F0           MOVX      @DPTR,A
    120              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.sfd);
   \   0000EA                ; Setup parameters for call to function AT_time
   \   0000EA   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   0000ED   90....       MOV       DPTR,#MODEL + 111
   \   0000F0   EA           MOV       A,R2
   \   0000F1   F0           MOVX      @DPTR,A
   \   0000F2   A3           INC       DPTR
   \   0000F3   EB           MOV       A,R3
   \   0000F4   F0           MOVX      @DPTR,A
    121              // Ждем завершения отправки сообщения
    122              while (!(RFIRQF1 & RFIRQF1_TXDONE));
   \                     ??SendData_8:
   \   0000F5   E591         MOV       A,0x91
   \   0000F7   A2E1         MOV       C,0xE0 /* A   */.1
   \   0000F9   50FA         JNC       ??SendData_8
    123              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.txdone);
   \   0000FB                ; Setup parameters for call to function AT_time
   \   0000FB   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   0000FE   90....       MOV       DPTR,#MODEL + 113
   \   000101   EA           MOV       A,R2
   \   000102   F0           MOVX      @DPTR,A
   \   000103   A3           INC       DPTR
   \   000104   EB           MOV       A,R3
   \   000105   F0           MOVX      @DPTR,A
    124              
    125            }
    126            CATCH(1){ //SAMPLED_CCA == 0
   \   000106   8002         SJMP      ??SendData_3
    127              result = false;
   \                     ??SendData_5:
   \   000108   C2..         CLR       ?VB.0
    128            }
    129            FINALLY{
    130              ISRFOFF();
   \                     ??SendData_3:
   \   00010A   75E1EF       MOV       0xe1,#-0x11
    131            }
    132            ETRY;  
    133            return result;
   \   00010D   A2..         MOV       C,?VB.0
   \   00010F   74CE         MOV       A,#-0x32
   \   000111   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000114   7F02         MOV       R7,#0x2
   \   000116   02....       LJMP      ?BANKED_LEAVE_SP
   \   000119                REQUIRE RFST
   \   000119                REQUIRE RFIRQF1
   \   000119                REQUIRE RFIRQF0
    134          }
    135          
    136          /*!
    137          \brief Передает данные в эфир
    138          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    139          bool RI_Send(struct frame *fr){
   \                     RI_Send:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 14
   \   000005   740E         MOV       A,#0xe
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   90FFFD       MOV       DPTR,#-0x3
   \   00000D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
    140            ASSERT(fr != NULL);
   \   000015   90FFFD       MOV       DPTR,#-0x3
   \   000018   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F8           MOV       R0,A
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F9           MOV       R1,A
   \   000020   E8           MOV       A,R0
   \   000021   49           ORL       A,R1
   \   000022   701F         JNZ       ??RI_Send_0
   \   000024                ; Setup parameters for call to function printf
   \   000024   748C         MOV       A,#-0x74
   \   000026   C0E0         PUSH      A
   \   000028   7400         MOV       A,#0x0
   \   00002A   C0E0         PUSH      A
   \   00002C   74..         MOV       A,#`?<Constant "radio.c">` & 0xff
   \   00002E   C0E0         PUSH      A
   \   000030   74..         MOV       A,#(`?<Constant "radio.c">` >> 8) & 0xff
   \   000032   C0E0         PUSH      A
   \   000034   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_5` & 0xff
   \   000036   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_5` >> 8) & 0xff
   \   000038   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00003B   74FC         MOV       A,#-0x4
   \   00003D   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000040                ; Setup parameters for call to function DBG_CORE_HALT
   \   000040   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    141            pre_config();
   \                     ??RI_Send_0:
   \   000043                ; Setup parameters for call to function pre_config
   \   000043   12....       LCALL     `??pre_config::?relay`; Banked call to: pre_config
    142            stamp_t start = UST_now();
   \   000046                ; Setup parameters for call to function UST_now
   \   000046   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   000049   90FFF1       MOV       DPTR,#-0xf
   \   00004C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00004F   12....       LCALL     ?XSTORE_R2345
    143            bool send_res = SendData(fr);
   \   000052                ; Setup parameters for call to function SendData
   \   000052   90FFFD       MOV       DPTR,#-0x3
   \   000055   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000058   E0           MOVX      A,@DPTR
   \   000059   FA           MOV       R2,A
   \   00005A   A3           INC       DPTR
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   FB           MOV       R3,A
   \   00005D   12....       LCALL     `??SendData::?relay`; Banked call to: SendData
   \   000060   92..         MOV       ?VB.0,C
    144            stamp_t stop = UST_now();
   \   000062                ; Setup parameters for call to function UST_now
   \   000062   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   000065   90FFF5       MOV       DPTR,#-0xb
   \   000068   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00006B   12....       LCALL     ?XSTORE_R2345
    145            //TODO Неверно считает интервал так как при отправке
    146            // sync пакета мы ждем
    147            ustime_t tx_time = UST_interval(start, stop); 
   \   00006E                ; Setup parameters for call to function UST_interval
   \   00006E   90FFF5       MOV       DPTR,#-0xb
   \   000071   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000074   78..         MOV       R0,#?V0
   \   000076   12....       LCALL     ?L_MOV_X
   \   000079   78..         MOV       R0,#?V0
   \   00007B   12....       LCALL     ?PUSH_ISTACK_I_FOUR
   \   00007E   90FFED       MOV       DPTR,#-0x13
   \   000081   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000084   12....       LCALL     ?XLOAD_R2345
   \   000087   12....       LCALL     `??UST_interval::?relay`; Banked call to: UST_interval
   \   00008A   74FC         MOV       A,#-0x4
   \   00008C   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00008F   90FFF9       MOV       DPTR,#-0x7
   \   000092   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000095   12....       LCALL     ?XSTORE_R2345
    148            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.fulltime, tx_time);
   \   000098   90FFF9       MOV       DPTR,#-0x7
   \   00009B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00009E   12....       LCALL     ?XLOAD_R0123
   \   0000A1   90....       MOV       DPTR,#MODEL + 116
   \   0000A4   12....       LCALL     ?XSTORE_R0123
    149            MODEL.RADIO.UptimeTX += tx_time;
   \   0000A7   90FFF9       MOV       DPTR,#-0x7
   \   0000AA   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000AD   78..         MOV       R0,#?V0
   \   0000AF   12....       LCALL     ?L_MOV_X
   \   0000B2   78..         MOV       R0,#?V0
   \   0000B4   12....       LCALL     ?UL_TO_FLT
   \   0000B7   90....       MOV       DPTR,#MODEL + 97
   \   0000BA   78..         MOV       R0,#?V4
   \   0000BC   12....       LCALL     ?L_MOV_X
   \   0000BF   78..         MOV       R0,#?V0
   \   0000C1   79..         MOV       R1,#?V4
   \   0000C3   12....       LCALL     ?FLT_ADD
   \   0000C6   90....       MOV       DPTR,#MODEL + 97
   \   0000C9   78..         MOV       R0,#?V0
   \   0000CB   12....       LCALL     ?L_MOV_TO_X
    150            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.ccasampled, send_res);
   \   0000CE   A2..         MOV       C,?VB.0
   \   0000D0   E4           CLR       A
   \   0000D1   33           RLC       A
   \   0000D2   90....       MOV       DPTR,#MODEL + 115
   \   0000D5   F0           MOVX      @DPTR,A
    151            if (!send_res)
   \   0000D6   A2..         MOV       C,?VB.0
   \   0000D8   4010         JC        ??RI_Send_1
    152              MODEL.RADIO.CCAReject++;
   \   0000DA   90....       MOV       DPTR,#__Constant_1
   \   0000DD   78..         MOV       R0,#?V0
   \   0000DF   12....       LCALL     ?L_MOV_X
   \   0000E2   90....       MOV       DPTR,#MODEL + 91
   \   0000E5   78..         MOV       R0,#?V0
   \   0000E7   12....       LCALL     ?L_ADD_TO_X
    153            return send_res;
   \                     ??RI_Send_1:
   \   0000EA   A2..         MOV       C,?VB.0
   \   0000EC   74F2         MOV       A,#-0xe
   \   0000EE   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000F1   7F08         MOV       R7,#0x8
   \   0000F3   02....       LJMP      ?BANKED_LEAVE_SP
    154          }
    155          
    156          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    157          static void UnLoadRXData(char *src, size_t len){
   \                     ??UnLoadRXData:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    158            for (size_t i = 0 ; i < len; i++)
   \   000000   7800         MOV       R0,#0x0
   \   000002   7900         MOV       R1,#0x0
   \                     ??UnLoadRXData_1:
   \   000004   C3           CLR       C
   \   000005   E8           MOV       A,R0
   \   000006   9C           SUBB      A,R4
   \   000007   E9           MOV       A,R1
   \   000008   9D           SUBB      A,R5
   \   000009   5016         JNC       ??UnLoadRXData_2
    159              src[i] = RFD;
   \   00000B   E5D9         MOV       A,0xd9
   \   00000D   C0E0         PUSH      A
   \   00000F   EA           MOV       A,R2
   \   000010   28           ADD       A,R0
   \   000011   F582         MOV       DPL,A
   \   000013   EB           MOV       A,R3
   \   000014   39           ADDC      A,R1
   \   000015   F583         MOV       DPH,A
   \   000017   D0E0         POP       A
   \   000019   F0           MOVX      @DPTR,A
   \   00001A   08           INC       R0
   \   00001B   E8           MOV       A,R0
   \   00001C   70E6         JNZ       ??UnLoadRXData_1
   \   00001E   09           INC       R1
   \   00001F   80E3         SJMP      ??UnLoadRXData_1
    160          };
   \                     ??UnLoadRXData_2:
   \   000021   02....       LJMP      ?BRET
   \   000024                REQUIRE RFD
    161          
    162          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    163          static bool RecvData(ustime_t timeout, nwtime_t *sfd_stamp){   
   \                     ??RecvData:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 54
   \   000005   7436         MOV       A,#0x36
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   8C..         MOV       ?V2,R4
   \   000010   8D..         MOV       ?V3,R5
   \   000012   90FFBB       MOV       DPTR,#-0x45
   \   000015   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000018   E0           MOVX      A,@DPTR
   \   000019   FE           MOV       R6,A
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   FF           MOV       R7,A
    164            bool recv_result = true;
   \   00001D   D2..         SETB      ?VB.0
    165            
    166            ISFLUSHRX();
   \   00001F   75E1ED       MOV       0xe1,#-0x13
    167            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
   \   000022   53E9BF       ANL       0xe9,#0xbf
    168            RFIRQF0 &= ~RFIRQF0_SFD; 
   \   000025   53E9FD       ANL       0xe9,#0xfd
    169            ISRXON();
   \   000028   75E1E3       MOV       0xe1,#-0x1d
    170            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.isrxon);
   \   00002B                ; Setup parameters for call to function AT_time
   \   00002B   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   00002E   90....       MOV       DPTR,#MODEL + 120
   \   000031   EA           MOV       A,R2
   \   000032   F0           MOVX      @DPTR,A
   \   000033   A3           INC       DPTR
   \   000034   EB           MOV       A,R3
   \   000035   F0           MOVX      @DPTR,A
    171            stamp_t start = UST_now();
   \   000036                ; Setup parameters for call to function UST_now
   \   000036   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   000039   EA           MOV       A,R2
   \   00003A   F8           MOV       R0,A
   \   00003B   EB           MOV       A,R3
   \   00003C   F9           MOV       R1,A
   \   00003D   EC           MOV       A,R4
   \   00003E   FA           MOV       R2,A
   \   00003F   ED           MOV       A,R5
   \   000040   FB           MOV       R3,A
   \   000041   90FFFB       MOV       DPTR,#-0x5
   \   000044   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000047   12....       LCALL     ?XSTORE_R0123
    172            TRY{
   \   00004A   90FFC9       MOV       DPTR,#-0x37
   \   00004D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000050   7408         MOV       A,#0x8
   \   000052                REQUIRE ?V7
   \   000052   12....       LCALL     ?SETJMP_XDATA
   \   000055   8A..         MOV       ?V4,R2
   \   000057   8B..         MOV       ?V5,R3
   \   000059   78..         MOV       R0,#?V4
   \   00005B   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for RecvData>_0`:
   \   00005E   0000         DW        0
   \   000060   01           DB        1
   \   000061   ....         DW        ??RecvData_1
   \   000063   ....         DW        ??RecvData_2
   \   000065   ....         DW        ??RecvData_3
    173              while(true){
    174                if (UST_time_over(start, timeout))
   \                     ??RecvData_2:
   \   000067                ; Setup parameters for call to function UST_time_over
   \   000067   78..         MOV       R0,#?V0
   \   000069   12....       LCALL     ?PUSH_ISTACK_I_FOUR
   \   00006C   90FFF7       MOV       DPTR,#-0x9
   \   00006F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000072   12....       LCALL     ?XLOAD_R2345
   \   000075   12....       LCALL     `??UST_time_over::?relay`; Banked call to: UST_time_over
   \   000078   74FC         MOV       A,#-0x4
   \   00007A   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00007D   500F         JNC       ??RecvData_4
    175                  THROW(1);
   \   00007F   7A01         MOV       R2,#0x1
   \   000081   7B00         MOV       R3,#0x0
   \   000083   90FFC9       MOV       DPTR,#-0x37
   \   000086   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000089   7408         MOV       A,#0x8
   \   00008B                REQUIRE ?V7
   \   00008B   02....       LJMP      ?LONGJMP_XDATA
    176                
    177                if ((RFIRQF0 & RFIRQF0_SFD)){ // Принят сигнал SFD
   \                     ??RecvData_4:
   \   00008E   E5E9         MOV       A,0xe9
   \   000090   A2E1         MOV       C,0xE0 /* A   */.1
   \   000092   50D3         JNC       ??RecvData_2
    178                  *sfd_stamp = AT_time(); 
   \   000094                ; Setup parameters for call to function AT_time
   \   000094   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   000097   8E82         MOV       DPL,R6
   \   000099   8F83         MOV       DPH,R7
   \   00009B   EA           MOV       A,R2
   \   00009C   F0           MOVX      @DPTR,A
   \   00009D   A3           INC       DPTR
   \   00009E   EB           MOV       A,R3
   \   00009F   F0           MOVX      @DPTR,A
    179                  WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.sfd);
   \   0000A0                ; Setup parameters for call to function AT_time
   \   0000A0   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   0000A3   90....       MOV       DPTR,#MODEL + 122
   \   0000A6   EA           MOV       A,R2
   \   0000A7   F0           MOVX      @DPTR,A
   \   0000A8   A3           INC       DPTR
   \   0000A9   EB           MOV       A,R3
   \   0000AA   F0           MOVX      @DPTR,A
    180                  break;
    181                }
    182              }
    183              // Ждем окончания приема пакета
    184              while (!(RFIRQF0 & RFIRQF0_RXPKTDONE));
   \                     ??RecvData_5:
   \   0000AB   E5E9         MOV       A,0xe9
   \   0000AD   A2E6         MOV       C,0xE0 /* A   */.6
   \   0000AF   50FA         JNC       ??RecvData_5
    185              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.rxdone);
   \   0000B1                ; Setup parameters for call to function AT_time
   \   0000B1   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   0000B4   90....       MOV       DPTR,#MODEL + 124
   \   0000B7   EA           MOV       A,R2
   \   0000B8   F0           MOVX      @DPTR,A
   \   0000B9   A3           INC       DPTR
   \   0000BA   EB           MOV       A,R3
   \   0000BB   F0           MOVX      @DPTR,A
    186            }
    187            CATCH(1){ // Вышло время ожидания
   \   0000BC   8002         SJMP      ??RecvData_1
    188              recv_result = false;
   \                     ??RecvData_3:
   \   0000BE   C2..         CLR       ?VB.0
    189            }
    190            FINALLY{
    191              ISRFOFF();
   \                     ??RecvData_1:
   \   0000C0   75E1EF       MOV       0xe1,#-0x11
    192            }
    193            ETRY;
    194            return recv_result;
   \   0000C3   A2..         MOV       C,?VB.0
   \   0000C5   74CA         MOV       A,#-0x36
   \   0000C7   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000CA   7F06         MOV       R7,#0x6
   \   0000CC   02....       LJMP      ?BANKED_LEAVE_SP
   \   0000CF                REQUIRE RFST
   \   0000CF                REQUIRE RFIRQF0
    195          }
    196          
    197          /*!
    198          \brief Принимает данные из эфира
    199          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    200          RI_CRC_ERROR. Отмечает время прихода SFD в тактах сетевого времени .
    201          \param[in] timeout Время ожидания данных в микросекундах
    202          \return Возвращает NULL если данных нет
    203          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    204          struct frame* RI_Receive(ustime_t timeout){
   \                     RI_Receive:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 20
   \   000005   7414         MOV       A,#0x14
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   90FFEB       MOV       DPTR,#-0x15
   \   00000D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   EC           MOV       A,R4
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   ED           MOV       A,R5
   \   00001A   F0           MOVX      @DPTR,A
    205            // Устанавливаем частоту передачи пакета
    206            pre_config();
   \   00001B                ; Setup parameters for call to function pre_config
   \   00001B   12....       LCALL     `??pre_config::?relay`; Banked call to: pre_config
    207            nwtime_t sfd_stamp;
    208               
    209            // Принимаем пакет 
    210            stamp_t start = UST_now();
   \   00001E                ; Setup parameters for call to function UST_now
   \   00001E   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   000021   90FFEF       MOV       DPTR,#-0x11
   \   000024   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000027   12....       LCALL     ?XSTORE_R2345
    211            bool recv_res = RecvData(timeout, &sfd_stamp);
   \   00002A                ; Setup parameters for call to function RecvData
   \   00002A   90FFFB       MOV       DPTR,#-0x5
   \   00002D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000030   C082         PUSH      DPL
   \   000032   C083         PUSH      DPH
   \   000034   90FFE9       MOV       DPTR,#-0x17
   \   000037   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00003A   12....       LCALL     ?XLOAD_R2345
   \   00003D   12....       LCALL     `??RecvData::?relay`; Banked call to: RecvData
   \   000040   D0E0         POP       A
   \   000042   D0E0         POP       A
   \   000044   92..         MOV       ?VB.0,C
    212            stamp_t stop = UST_now();
   \   000046                ; Setup parameters for call to function UST_now
   \   000046   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   000049   90FFF3       MOV       DPTR,#-0xd
   \   00004C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00004F   12....       LCALL     ?XSTORE_R2345
    213            ustime_t rx_time = UST_interval(start, stop); 
   \   000052                ; Setup parameters for call to function UST_interval
   \   000052   90FFF3       MOV       DPTR,#-0xd
   \   000055   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000058   78..         MOV       R0,#?V0
   \   00005A   12....       LCALL     ?L_MOV_X
   \   00005D   78..         MOV       R0,#?V0
   \   00005F   12....       LCALL     ?PUSH_ISTACK_I_FOUR
   \   000062   90FFEB       MOV       DPTR,#-0x15
   \   000065   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000068   12....       LCALL     ?XLOAD_R2345
   \   00006B   12....       LCALL     `??UST_interval::?relay`; Banked call to: UST_interval
   \   00006E   74FC         MOV       A,#-0x4
   \   000070   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000073   90FFF7       MOV       DPTR,#-0x9
   \   000076   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000079   12....       LCALL     ?XSTORE_R2345
    214            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_RX.fulltime, rx_time);
   \   00007C   90FFF7       MOV       DPTR,#-0x9
   \   00007F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000082   12....       LCALL     ?XLOAD_R0123
   \   000085   90....       MOV       DPTR,#MODEL + 126
   \   000088   12....       LCALL     ?XSTORE_R0123
    215            MODEL.RADIO.UptimeRX += rx_time;
   \   00008B   90FFF7       MOV       DPTR,#-0x9
   \   00008E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000091   78..         MOV       R0,#?V0
   \   000093   12....       LCALL     ?L_MOV_X
   \   000096   78..         MOV       R0,#?V0
   \   000098   12....       LCALL     ?UL_TO_FLT
   \   00009B   90....       MOV       DPTR,#MODEL + 101
   \   00009E   78..         MOV       R0,#?V4
   \   0000A0   12....       LCALL     ?L_MOV_X
   \   0000A3   78..         MOV       R0,#?V0
   \   0000A5   79..         MOV       R1,#?V4
   \   0000A7   12....       LCALL     ?FLT_ADD
   \   0000AA   90....       MOV       DPTR,#MODEL + 101
   \   0000AD   78..         MOV       R0,#?V0
   \   0000AF   12....       LCALL     ?L_MOV_TO_X
    216            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_RX.received, recv_res);
   \   0000B2   A2..         MOV       C,?VB.0
   \   0000B4   E4           CLR       A
   \   0000B5   33           RLC       A
   \   0000B6   90....       MOV       DPTR,#MODEL + 130
   \   0000B9   F0           MOVX      @DPTR,A
    217            if (!recv_res) // Нет пакета, возвращаем NULL
   \   0000BA   A2..         MOV       C,?VB.0
   \   0000BC   4007         JC        ??RI_Receive_0
    218              return NULL;
   \   0000BE   7A00         MOV       R2,#0x0
   \   0000C0   7B00         MOV       R3,#0x0
   \   0000C2   02....       LJMP      ??RI_Receive_1 & 0xFFFF
    219            
    220            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
   \                     ??RI_Receive_0:
   \   0000C5   90619B       MOV       DPTR,#0x619b
   \   0000C8   E0           MOVX      A,@DPTR
   \   0000C9   F5..         MOV       ?V0,A
    221            
    222            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    223            if (frame_size <= 2)
   \   0000CB   E5..         MOV       A,?V0
   \   0000CD   C3           CLR       C
   \   0000CE   9403         SUBB      A,#0x3
   \   0000D0   5007         JNC       ??RI_Receive_2
    224              return NULL;
   \   0000D2   7A00         MOV       R2,#0x0
   \   0000D4   7B00         MOV       R3,#0x0
   \   0000D6   02....       LJMP      ??RI_Receive_1 & 0xFFFF
    225            
    226            UnLoadRXData(RXBUFF, frame_size);
   \                     ??RI_Receive_2:
   \   0000D9                ; Setup parameters for call to function UnLoadRXData
   \   0000D9   E5..         MOV       A,?V0
   \   0000DB   FC           MOV       R4,A
   \   0000DC   7D00         MOV       R5,#0x0
   \   0000DE   7A..         MOV       R2,#??RXBUFF & 0xff
   \   0000E0   7B..         MOV       R3,#(??RXBUFF >> 8) & 0xff
   \   0000E2   12....       LCALL     `??UnLoadRXData::?relay`; Banked call to: UnLoadRXData
    227            
    228            int8_t  FCS1 = RXBUFF[frame_size - 2]; // RSSI
   \   0000E5   E5..         MOV       A,?V0
   \   0000E7   F8           MOV       R0,A
   \   0000E8   7900         MOV       R1,#0x0
   \   0000EA   74..         MOV       A,#(??RXBUFF + 254) & 0xff
   \   0000EC   28           ADD       A,R0
   \   0000ED   F582         MOV       DPL,A
   \   0000EF   74..         MOV       A,#((??RXBUFF - 2) >> 8) & 0xff
   \   0000F1   39           ADDC      A,R1
   \   0000F2   F583         MOV       DPH,A
   \   0000F4   E0           MOVX      A,@DPTR
   \   0000F5   C0E0         PUSH      A
   \   0000F7   90FFFC       MOV       DPTR,#-0x4
   \   0000FA   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000FD   D0E0         POP       A
   \   0000FF   F0           MOVX      @DPTR,A
    229            uint8_t FCS2 = RXBUFF[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
   \   000100   E5..         MOV       A,?V0
   \   000102   F8           MOV       R0,A
   \   000103   7900         MOV       R1,#0x0
   \   000105   74..         MOV       A,#(??RXBUFF + 255) & 0xff
   \   000107   28           ADD       A,R0
   \   000108   F582         MOV       DPL,A
   \   00010A   74..         MOV       A,#((??RXBUFF - 1) >> 8) & 0xff
   \   00010C   39           ADDC      A,R1
   \   00010D   F583         MOV       DPH,A
   \   00010F   E0           MOVX      A,@DPTR
   \   000110   F5..         MOV       ?V1,A
    230            uint8_t LEN_F = RXBUFF[0]; // Поле LEN
   \   000112   90....       MOV       DPTR,#??RXBUFF
   \   000115   E0           MOVX      A,@DPTR
   \   000116   C0E0         PUSH      A
   \   000118   90FFFD       MOV       DPTR,#-0x3
   \   00011B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00011E   D0E0         POP       A
   \   000120   F0           MOVX      @DPTR,A
    231            
    232            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    233            // с фактической длинной принятых данных
    234            if (LEN_F != frame_size - 1){
   \   000121   858182       MOV       DPL,SP
   \   000124   E5..         MOV       A,?ESP
   \   000126   54..         ANL       A,#?ESP_MASK
   \   000128   44..         ORL       A,#(SFB(EXT_STACK) >> 8) & 0xff
   \   00012A   F583         MOV       DPH,A
   \   00012C   E0           MOVX      A,@DPTR
   \   00012D   FA           MOV       R2,A
   \   00012E   7B00         MOV       R3,#0x0
   \   000130   E5..         MOV       A,?V0
   \   000132   F8           MOV       R0,A
   \   000133   7900         MOV       R1,#0x0
   \   000135   E8           MOV       A,R0
   \   000136   24FF         ADD       A,#-0x1
   \   000138   F8           MOV       R0,A
   \   000139   E9           MOV       A,R1
   \   00013A   34FF         ADDC      A,#-0x1
   \   00013C   F9           MOV       R1,A
   \   00013D   E8           MOV       A,R0
   \   00013E   6A           XRL       A,R2
   \   00013F   7002         JNZ       ??RI_Receive_3
   \   000141   E9           MOV       A,R1
   \   000142   6B           XRL       A,R3
   \                     ??RI_Receive_3:
   \   000143   6017         JZ        ??RI_Receive_4
    235              MODEL.RADIO.CRCError++;
   \   000145   90....       MOV       DPTR,#__Constant_1
   \   000148   78..         MOV       R0,#?V4
   \   00014A   12....       LCALL     ?L_MOV_X
   \   00014D   90....       MOV       DPTR,#MODEL + 87
   \   000150   78..         MOV       R0,#?V4
   \   000152   12....       LCALL     ?L_ADD_TO_X
    236              return NULL;
   \   000155   7A00         MOV       R2,#0x0
   \   000157   7B00         MOV       R3,#0x0
   \   000159   02....       LJMP      ??RI_Receive_1 & 0xFFFF
    237            }
    238            
    239            // Проверим поле CRCOK
    240            if (!(FCS2 && 1<<7)){
   \                     ??RI_Receive_4:
   \   00015C   E5..         MOV       A,?V1
   \   00015E   7017         JNZ       ??RI_Receive_5
    241              MODEL.RADIO.CRCError++;
   \   000160   90....       MOV       DPTR,#__Constant_1
   \   000163   78..         MOV       R0,#?V4
   \   000165   12....       LCALL     ?L_MOV_X
   \   000168   90....       MOV       DPTR,#MODEL + 87
   \   00016B   78..         MOV       R0,#?V4
   \   00016D   12....       LCALL     ?L_ADD_TO_X
    242              return NULL;
   \   000170   7A00         MOV       R2,#0x0
   \   000172   7B00         MOV       R3,#0x0
   \   000174   02....       LJMP      ??RI_Receive_1 & 0xFFFF
    243            }
    244            
    245            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    246            struct frame *frame = FR_create();
   \                     ??RI_Receive_5:
   \   000177                ; Setup parameters for call to function FR_create
   \   000177   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   00017A   8A..         MOV       ?V2,R2
   \   00017C   8B..         MOV       ?V3,R3
   \   00017E   AE..         MOV       R6,?V2
   \   000180   AF..         MOV       R7,?V3
    247            ASSERT(frame);
   \   000182   EE           MOV       A,R6
   \   000183   4F           ORL       A,R7
   \   000184   701F         JNZ       ??RI_Receive_6
   \   000186                ; Setup parameters for call to function printf
   \   000186   74F7         MOV       A,#-0x9
   \   000188   C0E0         PUSH      A
   \   00018A   7400         MOV       A,#0x0
   \   00018C   C0E0         PUSH      A
   \   00018E   74..         MOV       A,#`?<Constant "radio.c">` & 0xff
   \   000190   C0E0         PUSH      A
   \   000192   74..         MOV       A,#(`?<Constant "radio.c">` >> 8) & 0xff
   \   000194   C0E0         PUSH      A
   \   000196   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_5` & 0xff
   \   000198   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_5` >> 8) & 0xff
   \   00019A   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00019D   74FC         MOV       A,#-0x4
   \   00019F   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001A2                ; Setup parameters for call to function DBG_CORE_HALT
   \   0001A2   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    248            bool add_h = FR_add_header(frame, &RXBUFF[1], frame_size - 3);
   \                     ??RI_Receive_6:
   \   0001A5                ; Setup parameters for call to function FR_add_header
   \   0001A5   74FD         MOV       A,#-0x3
   \   0001A7   25..         ADD       A,?V0
   \   0001A9   F9           MOV       R1,A
   \   0001AA   7C..         MOV       R4,#(??RXBUFF + 1) & 0xff
   \   0001AC   7D..         MOV       R5,#((??RXBUFF + 1) >> 8) & 0xff
   \   0001AE   EE           MOV       A,R6
   \   0001AF   FA           MOV       R2,A
   \   0001B0   EF           MOV       A,R7
   \   0001B1   FB           MOV       R3,A
   \   0001B2   12....       LCALL     `??FR_add_header::?relay`; Banked call to: FR_add_header
   \   0001B5   92..         MOV       ?VB.1,C
    249            ASSERT(add_h);
   \   0001B7   A2..         MOV       C,?VB.1
   \   0001B9   401F         JC        ??RI_Receive_7
   \   0001BB                ; Setup parameters for call to function printf
   \   0001BB   74F9         MOV       A,#-0x7
   \   0001BD   C0E0         PUSH      A
   \   0001BF   7400         MOV       A,#0x0
   \   0001C1   C0E0         PUSH      A
   \   0001C3   74..         MOV       A,#`?<Constant "radio.c">` & 0xff
   \   0001C5   C0E0         PUSH      A
   \   0001C7   74..         MOV       A,#(`?<Constant "radio.c">` >> 8) & 0xff
   \   0001C9   C0E0         PUSH      A
   \   0001CB   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_5` & 0xff
   \   0001CD   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_5` >> 8) & 0xff
   \   0001CF   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0001D2   74FC         MOV       A,#-0x4
   \   0001D4   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001D7                ; Setup parameters for call to function DBG_CORE_HALT
   \   0001D7   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    250            
    251            frame->meta.TIMESTAMP = sfd_stamp;
   \                     ??RI_Receive_7:
   \   0001DA   90FFFB       MOV       DPTR,#-0x5
   \   0001DD   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001E0   E0           MOVX      A,@DPTR
   \   0001E1   F8           MOV       R0,A
   \   0001E2   A3           INC       DPTR
   \   0001E3   E0           MOVX      A,@DPTR
   \   0001E4   F9           MOV       R1,A
   \   0001E5   8E82         MOV       DPL,R6
   \   0001E7   8F83         MOV       DPH,R7
   \   0001E9   A3           INC       DPTR
   \   0001EA   E8           MOV       A,R0
   \   0001EB   F0           MOVX      @DPTR,A
   \   0001EC   A3           INC       DPTR
   \   0001ED   E9           MOV       A,R1
   \   0001EE   F0           MOVX      @DPTR,A
    252            frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
   \   0001EF   90FFFD       MOV       DPTR,#-0x3
   \   0001F2   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001F5   E0           MOVX      A,@DPTR
   \   0001F6   24B4         ADD       A,#-0x4c
   \   0001F8   C0E0         PUSH      A
   \   0001FA   8E82         MOV       DPL,R6
   \   0001FC   8F83         MOV       DPH,R7
   \   0001FE   A3           INC       DPTR
   \   0001FF   A3           INC       DPTR
   \   000200   A3           INC       DPTR
   \   000201   D0E0         POP       A
   \   000203   F0           MOVX      @DPTR,A
    253            uint8_t corr = FCS2 & 0x7F;
   \   000204   747F         MOV       A,#0x7f
   \   000206   55..         ANL       A,?V1
   \   000208   F8           MOV       R0,A
    254            frame->meta.LIQ = LIQ_CALC(corr);
   \   000209   E8           MOV       A,R0
   \   00020A   C0E0         PUSH      A
   \   00020C   8E82         MOV       DPL,R6
   \   00020E   8F83         MOV       DPH,R7
   \   000210   A3           INC       DPTR
   \   000211   A3           INC       DPTR
   \   000212   A3           INC       DPTR
   \   000213   A3           INC       DPTR
   \   000214   D0E0         POP       A
   \   000216   F0           MOVX      @DPTR,A
    255            frame->meta.CH = MODEL.RADIO.channel;
   \   000217   90....       MOV       DPTR,#MODEL + 96
   \   00021A   E0           MOVX      A,@DPTR
   \   00021B   C0E0         PUSH      A
   \   00021D   8E82         MOV       DPL,R6
   \   00021F   8F83         MOV       DPH,R7
   \   000221   A3           INC       DPTR
   \   000222   A3           INC       DPTR
   \   000223   A3           INC       DPTR
   \   000224   A3           INC       DPTR
   \   000225   A3           INC       DPTR
   \   000226   A3           INC       DPTR
   \   000227   D0E0         POP       A
   \   000229   F0           MOVX      @DPTR,A
    256            return frame;
   \   00022A   EE           MOV       A,R6
   \   00022B   FA           MOV       R2,A
   \   00022C   EF           MOV       A,R7
   \   00022D   FB           MOV       R3,A
   \                     ??RI_Receive_1:
   \   00022E   74EC         MOV       A,#-0x14
   \   000230   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000233   7F08         MOV       R7,#0x8
   \   000235   02....       LJMP      ?BANKED_LEAVE_SP
    257          }
    258          
    259          
    260          /**
    261          @breif Подссчет количества бит в байте
    262          @return Возвращает количество бит
    263          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    264          static uint8_t bits_count(uint8_t value) {
   \                     ??bits_count:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV       A,R1
   \   000001   FA           MOV       R2,A
    265            int ret = 0;
   \   000002   7800         MOV       R0,#0x0
   \   000004   7900         MOV       R1,#0x0
    266            for ( ; value; value = value >> 1 )
   \                     ??bits_count_1:
   \   000006   EA           MOV       A,R2
   \   000007   6014         JZ        ??bits_count_2
    267              ret += value & 1;
   \   000009   EA           MOV       A,R2
   \   00000A   A2E0         MOV       C,0xE0 /* A   */.0
   \   00000C   E4           CLR       A
   \   00000D   33           RLC       A
   \   00000E   FC           MOV       R4,A
   \   00000F   7D00         MOV       R5,#0x0
   \   000011   E8           MOV       A,R0
   \   000012   2C           ADD       A,R4
   \   000013   F8           MOV       R0,A
   \   000014   E9           MOV       A,R1
   \   000015   3D           ADDC      A,R5
   \   000016   F9           MOV       R1,A
   \   000017   EA           MOV       A,R2
   \   000018   C3           CLR       C
   \   000019   13           RRC       A
   \   00001A   FA           MOV       R2,A
   \   00001B   80E9         SJMP      ??bits_count_1
    268            return ret;
   \                     ??bits_count_2:
   \   00001D   E8           MOV       A,R0
   \   00001E   F9           MOV       R1,A
   \   00001F   02....       LJMP      ?BRET
    269          }
    270          
    271          /**
    272          @brief Возращает 1 байт случайного числа
    273          @details Радио выдает всего лишь дви бита, нам нужно 8 
    274          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    275          static inline uint8_t getRNDByte(void)
   \                     ??getRNDByte:
    276          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    277            uint8_t val = 0;
   \   000000   7900         MOV       R1,#0x0
    278            val |= RFRND << 0;
   \   000002   9061A7       MOV       DPTR,#0x61a7
   \   000005   E0           MOVX      A,@DPTR
   \   000006   C9           XCH       A,R1
   \   000007   49           ORL       A,R1
   \   000008   C9           XCH       A,R1
    279            val |= RFRND << 2;
   \   000009   9061A7       MOV       DPTR,#0x61a7
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   33           RLC       A
   \   00000E   33           RLC       A
   \   00000F   54FC         ANL       A,#0xfc
   \   000011   C9           XCH       A,R1
   \   000012   49           ORL       A,R1
   \   000013   C9           XCH       A,R1
    280            val |= RFRND << 4;
   \   000014   9061A7       MOV       DPTR,#0x61a7
   \   000017   E0           MOVX      A,@DPTR
   \   000018   C4           SWAP      A
   \   000019   54F0         ANL       A,#0xf0
   \   00001B   C9           XCH       A,R1
   \   00001C   49           ORL       A,R1
   \   00001D   C9           XCH       A,R1
    281            val |= RFRND << 6;
   \   00001E   9061A7       MOV       DPTR,#0x61a7
   \   000021   E0           MOVX      A,@DPTR
   \   000022   C4           SWAP      A
   \   000023   33           RLC       A
   \   000024   33           RLC       A
   \   000025   54C0         ANL       A,#0xc0
   \   000027   C9           XCH       A,R1
   \   000028   49           ORL       A,R1
   \   000029   C9           XCH       A,R1
    282            return val;
   \   00002A   02....       LJMP      ?BRET
    283          }
    284          
    285          /**
    286          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    287          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    288          возвращает гарантированно новое значение. 
    289          @return возвращает случайное число.
    290          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    291          static inline uint8_t readRandom(void)
   \                     ??readRandom:
    292          {
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
    293            uint8_t rnd_val = 0;
   \   000006   7E00         MOV       R6,#0x0
    294            uint8_t bit_cnt = 0;
   \   000008   7F00         MOV       R7,#0x0
    295            while ( bit_cnt <= 2 || bit_cnt >= 6 )
   \                     ??readRandom_1:
   \   00000A   EF           MOV       A,R7
   \   00000B   C3           CLR       C
   \   00000C   9403         SUBB      A,#0x3
   \   00000E   4006         JC        ??readRandom_2
   \   000010   EF           MOV       A,R7
   \   000011   C3           CLR       C
   \   000012   9406         SUBB      A,#0x6
   \   000014   401A         JC        ??readRandom_3
    296            {
    297              rnd_val = getRNDByte();
   \                     ??readRandom_2:
   \   000016                ; Setup parameters for call to function getRNDByte
   \   000016   12....       LCALL     `??getRNDByte::?relay`; Banked call to: getRNDByte
   \   000019   E9           MOV       A,R1
   \   00001A   FE           MOV       R6,A
    298              while (rnd_val == getRNDByte());
   \                     ??readRandom_4:
   \   00001B                ; Setup parameters for call to function getRNDByte
   \   00001B   12....       LCALL     `??getRNDByte::?relay`; Banked call to: getRNDByte
   \   00001E   E9           MOV       A,R1
   \   00001F   6E           XRL       A,R6
   \   000020   60F9         JZ        ??readRandom_4
    299              rnd_val = getRNDByte();
   \   000022                ; Setup parameters for call to function getRNDByte
   \   000022   12....       LCALL     `??getRNDByte::?relay`; Banked call to: getRNDByte
   \   000025   E9           MOV       A,R1
   \   000026   FE           MOV       R6,A
    300              bit_cnt = bits_count(rnd_val);
   \   000027                ; Setup parameters for call to function bits_count
   \   000027   EE           MOV       A,R6
   \   000028   F9           MOV       R1,A
   \   000029   12....       LCALL     `??bits_count::?relay`; Banked call to: bits_count
   \   00002C   E9           MOV       A,R1
   \   00002D   FF           MOV       R7,A
   \   00002E   80DA         SJMP      ??readRandom_1
    301            }
    302            return rnd_val;
   \                     ??readRandom_3:
   \   000030   EE           MOV       A,R6
   \   000031   F9           MOV       R1,A
   \   000032   D0E0         POP       A
   \   000034   FF           MOV       R7,A
   \   000035   D0E0         POP       A
   \   000037   FE           MOV       R6,A
   \   000038   02....       LJMP      ?BRET
    303          }
    304          
    305          /*!
    306          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    307          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    308          static void random_core_init(void)  
   \                     ??random_core_init:
    309          {
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
    310            unsigned int rnd_core = 0;;
   \   000006   7E00         MOV       R6,#0x0
   \   000008   7F00         MOV       R7,#0x0
    311               
    312            pre_config();
   \   00000A                ; Setup parameters for call to function pre_config
   \   00000A   12....       LCALL     `??pre_config::?relay`; Banked call to: pre_config
    313            FREQCTRL = 0x00; // Выбираем не используемую частоту
   \   00000D   90618F       MOV       DPTR,#0x618f
   \   000010   7400         MOV       A,#0x0
   \   000012   F0           MOVX      @DPTR,A
    314          
    315            // TODO По какой то причине OP_EXE не выполняет команду.
    316            // регистра RFST читается как 0xD0. это его состояние при reset
    317            // Включаем демодулятор
    318            ISRXON();
   \   000013   75E1E3       MOV       0xe1,#-0x1d
    319            
    320            // Ждем пока статус RSSI_VALID станет true
    321            while(!RSSISTAT);
   \                     ??random_core_init_1:
   \   000016   906199       MOV       DPTR,#0x6199
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   60FA         JZ        ??random_core_init_1
    322            
    323            // Ждем случайных чисел
    324            while (RFRND == 0);
   \                     ??random_core_init_2:
   \   00001C   9061A7       MOV       DPTR,#0x61a7
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   60FA         JZ        ??random_core_init_2
    325            
    326            // Настраиваем ядро случайного генератора
    327            rnd_core = readRandom();
   \   000022                ; Setup parameters for call to function readRandom
   \   000022   12....       LCALL     `??readRandom::?relay`; Banked call to: readRandom
   \   000025   E9           MOV       A,R1
   \   000026   F8           MOV       R0,A
   \   000027   7900         MOV       R1,#0x0
   \   000029   E8           MOV       A,R0
   \   00002A   FE           MOV       R6,A
   \   00002B   E9           MOV       A,R1
   \   00002C   FF           MOV       R7,A
    328            rnd_core |= (unsigned int)readRandom()<<8;
   \   00002D                ; Setup parameters for call to function readRandom
   \   00002D   12....       LCALL     `??readRandom::?relay`; Banked call to: readRandom
   \   000030   E9           MOV       A,R1
   \   000031   F8           MOV       R0,A
   \   000032   7900         MOV       R1,#0x0
   \   000034   E4           CLR       A
   \   000035   C8           XCH       A,R0
   \   000036   F9           MOV       R1,A
   \   000037   E8           MOV       A,R0
   \   000038   4E           ORL       A,R6
   \   000039   FE           MOV       R6,A
   \   00003A   E9           MOV       A,R1
   \   00003B   4F           ORL       A,R7
   \   00003C   FF           MOV       R7,A
    329            srand(rnd_core);
   \   00003D                ; Setup parameters for call to function srand
   \   00003D   EE           MOV       A,R6
   \   00003E   FA           MOV       R2,A
   \   00003F   EF           MOV       A,R7
   \   000040   FB           MOV       R3,A
   \   000041   12....       LCALL     `??srand::?relay`; Banked call to: srand
    330            
    331            // Выключаем демодулятор
    332            ISRFOFF();
   \   000044   75E1EF       MOV       0xe1,#-0x11
    333            // Первая генерация случайного числа занимает много времени.
    334            // Влияло на работу радио, так как использовались случайные посылки
    335            rand(); 
   \   000047                ; Setup parameters for call to function rand
   \   000047   12....       LCALL     `??rand::?relay` ; Banked call to: rand
    336          }
   \   00004A   D0E0         POP       A
   \   00004C   FF           MOV       R7,A
   \   00004D   D0E0         POP       A
   \   00004F   FE           MOV       R6,A
   \   000050   02....       LJMP      ?BRET
   \   000053                REQUIRE RFST
    337          
    338          /**
    339          @brief Измерение мощности сигнала
    340          @details Частота = 2394+fch. fch = [0..113]. 2394MHz to 2507MHz.
    341           Устройство поддерживает частоты до 2507 МГц
    342          @param[in] fch номер ЧАСТОТНОГО канала
    343          @param[in] timeout_ms время сканирования в мс
    344          @param[out] Максимальная мощность сигнала за время сканирования
    345          @return true если успешно
    346          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    347          bool RI_Measure_POW(char fch, ustime_t timeout, 
   \                     RI_Measure_POW:
    348                              int8_t *RSSI_SIG){
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
   \   00000B   8C..         MOV       ?V2,R4
   \   00000D   8D..         MOV       ?V3,R5
   \   00000F   90FFF1       MOV       DPTR,#-0xf
   \   000012   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000015   E0           MOVX      A,@DPTR
   \   000016   F5..         MOV       ?V4,A
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F5..         MOV       ?V5,A
    349            if (fch > 113)
   \   00001C   EE           MOV       A,R6
   \   00001D   C3           CLR       C
   \   00001E   9472         SUBB      A,#0x72
   \   000020   4003         JC        ??RI_Measure_POW_0
    350              return false;
   \   000022   C3           CLR       C
   \   000023   8037         SJMP      ??RI_Measure_POW_1
    351            //(2394+FREQCTRL.FREQ[6:0])
    352            FREQCTRL = fch; // Выбираем не используемую частоту
   \                     ??RI_Measure_POW_0:
   \   000025   EE           MOV       A,R6
   \   000026   90618F       MOV       DPTR,#0x618f
   \   000029   F0           MOVX      @DPTR,A
    353            ISRXON();
   \   00002A   75E1E3       MOV       0xe1,#-0x1d
    354            while(!RSSISTAT);
   \                     ??RI_Measure_POW_2:
   \   00002D   906199       MOV       DPTR,#0x6199
   \   000030   E0           MOVX      A,@DPTR
   \   000031   60FA         JZ        ??RI_Measure_POW_2
    355            FRMCTRL0 |= 1<<4; // включаем ENERGY_SCAN, детектор пикового сигнала
   \   000033   906189       MOV       DPTR,#0x6189
   \   000036   E0           MOVX      A,@DPTR
   \   000037   D2E4         SETB      0xE0 /* A   */.4
   \   000039   F0           MOVX      @DPTR,A
    356            UST_delay(timeout);
   \   00003A                ; Setup parameters for call to function UST_delay
   \   00003A   AA..         MOV       R2,?V0
   \   00003C   AB..         MOV       R3,?V1
   \   00003E   AC..         MOV       R4,?V2
   \   000040   AD..         MOV       R5,?V3
   \   000042   12....       LCALL     `??UST_delay::?relay`; Banked call to: UST_delay
    357            int8_t rssi = RSSI + RSSI_OFFSET;
   \   000045   906198       MOV       DPTR,#0x6198
   \   000048   E0           MOVX      A,@DPTR
   \   000049   24B4         ADD       A,#-0x4c
   \   00004B   F8           MOV       R0,A
    358            *RSSI_SIG = rssi;
   \   00004C   E8           MOV       A,R0
   \   00004D   C0E0         PUSH      A
   \   00004F   85..82       MOV       DPL,?V4
   \   000052   85..83       MOV       DPH,?V5
   \   000055   D0E0         POP       A
   \   000057   F0           MOVX      @DPTR,A
    359            ISRFOFF();
   \   000058   75E1EF       MOV       0xe1,#-0x11
    360            return true;
   \   00005B   D3           SETB      C
   \                     ??RI_Measure_POW_1:
   \   00005C   7F06         MOV       R7,#0x6
   \   00005E   02....       LJMP      ?BANKED_LEAVE_SP
   \   000061                REQUIRE RFST
    361          }
    362          
E:\Neocore\Hardware\STACK_CORE_SRC\rtc.c
      1          #include "action_manager.h"
      2          #include "model.h"
      3           
      4          static void SW_Init(void); 
      5          static void Cold_Start(void);
      6          static void Hot_Start(void);
      7          

   \                                 In  segment XDATA_I, align 1, keep-with-next
      8          module_s RTC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
   \                     RTC_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for RTC_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
      9            ALIAS(Hot_Start)};
     10           

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     11          static void SW_Init(void){}; 
   \                     ??SW_Init_8:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     12          static void Cold_Start(void){};
   \                     ??Cold_Start_2:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP      ?BRET
     13          
     14          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     15          static void Hot_Start(void){
   \                     ??Hot_Start_2:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004   C0..         PUSH      ?V2
   \   000006   C0..         PUSH      ?V3
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
     16            if (MODEL.TM.timeslot != 0)
   \   000008   90....       MOV       DPTR,#MODEL + 13
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   7020         JNZ       ??Hot_Start_6
     17              return;    
     18            MODEL.RTC.uptime++;
   \   00000E   90....       MOV       DPTR,#__Constant_1
   \   000011   78..         MOV       R0,#?V0
   \   000013   12....       LCALL     ?L_MOV_X
   \   000016   90....       MOV       DPTR,#MODEL + 4
   \   000019   78..         MOV       R0,#?V0
   \   00001B   12....       LCALL     ?L_ADD_TO_X
     19            MODEL.RTC.rtc++;
   \   00001E   90....       MOV       DPTR,#__Constant_1
   \   000021   78..         MOV       R0,#?V0
   \   000023   12....       LCALL     ?L_MOV_X
   \   000026   90....       MOV       DPTR,#MODEL + 8
   \   000029   78..         MOV       R0,#?V0
   \   00002B   12....       LCALL     ?L_ADD_TO_X
     20          };
   \                     ??Hot_Start_6:
   \   00002E   D0..         POP       ?V3
   \   000030   D0..         POP       ?V2
   \   000032   D0..         POP       ?V1
   \   000034   D0..         POP       ?V0
   \   000036   02....       LJMP      ?BRET
E:\Neocore\Hardware\STACK_CORE_SRC\sync.c
      1          #include "sync.h"
      2          #include "action_manager.h"
      3          #include "radio.h"
      4          #include "model.h"
      5          #include "alarm_timer.h"
      6          #include "debug.h"
      7          #include "frame.h"
      8          #include "coder.h"
      9          #include "stdlib.h"
     10          #include "macros.h"
     11          #include "global.h"
     12          
     13          #define MODE_0 0 // Отклчена модуль синхронизации 
     14          #define MODE_1 1 // Прием, ретрансляция, синхронизация
     15          #define MODE_2 2 // Периодическое вещание
     16          #define SYNC_TS 0 // Слот для синхронизации
     17          #define MAGIC 0x19833891 // Проверка что пакет действительно sync
     18          #define SYNC_TIME 163 // Точное время отправки пакета.nwtime
     19          #define NEG_RECV_OFFSET 33 // nwtime
     20          #define POS_RECV_OFFSET 33 // nwtime
     21          #define SEND_PERIOD 10 // Периодичность отправки пакетов
     22          #define RETRANSMITE_TRY 3 // Кол-во попыток отправки sync
     23          #define PROBABILIT 40 // % вероятность одной попытки отправки 
     24          #define UNSYNC_TIME 60 // Время в секундах рассинхронизации сети
     25          
     26          static void SW_Init(void);
     27          static void Cold_Start(void);
     28          static void Hot_Start(void);
     29          static bool send_sync(void);
     30          static struct frame* recv_sync(void);

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     31          static char retransmite;
   \                     ??retransmite:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     32          

   \                                 In  segment XDATA_I, align 1, keep-with-next
     33          module_s SYNC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
   \                     SYNC_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for SYNC_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     34            ALIAS(Hot_Start)};
     35          
     36          struct sync{
     37            char sys_ch;
     38            char tx_power;
     39            char panid;
     40            unsigned long rtc;
     41            unsigned long magic;
     42          } __attribute__((packed));
     43          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     44          static void SW_Init(void){ 
   \                     ??SW_Init_9:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     45            MODEL.SYNC.next_sync_send = 0;
   \   000000   90....       MOV       DPTR,#MODEL + 137
   \   000003   7400         MOV       A,#0x0
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   7400         MOV       A,#0x0
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   A3           INC       DPTR
   \   00000B   7400         MOV       A,#0x0
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   A3           INC       DPTR
   \   00000F   7400         MOV       A,#0x0
   \   000011   F0           MOVX      @DPTR,A
     46            MODEL.SYNC.next_time_recv = 0;
   \   000012   90....       MOV       DPTR,#MODEL + 141
   \   000015   7400         MOV       A,#0x0
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   7400         MOV       A,#0x0
   \   00001B   F0           MOVX      @DPTR,A
   \   00001C   A3           INC       DPTR
   \   00001D   7400         MOV       A,#0x0
   \   00001F   F0           MOVX      @DPTR,A
   \   000020   A3           INC       DPTR
   \   000021   7400         MOV       A,#0x0
   \   000023   F0           MOVX      @DPTR,A
     47            MODEL.SYNC.last_time_recv = 0;
   \   000024   90....       MOV       DPTR,#MODEL + 145
   \   000027   7400         MOV       A,#0x0
   \   000029   F0           MOVX      @DPTR,A
   \   00002A   A3           INC       DPTR
   \   00002B   7400         MOV       A,#0x0
   \   00002D   F0           MOVX      @DPTR,A
   \   00002E   A3           INC       DPTR
   \   00002F   7400         MOV       A,#0x0
   \   000031   F0           MOVX      @DPTR,A
   \   000032   A3           INC       DPTR
   \   000033   7400         MOV       A,#0x0
   \   000035   F0           MOVX      @DPTR,A
     48            MODEL.SYNC.sys_channel = DEFAULT_SYS_CH;
   \   000036   90....       MOV       DPTR,#MODEL + 133
   \   000039   740B         MOV       A,#0xb
   \   00003B   F0           MOVX      @DPTR,A
     49            MODEL.SYNC.sync_channel = DEFAULT_SYNC_CH;
   \   00003C   90....       MOV       DPTR,#MODEL + 134
   \   00003F   741C         MOV       A,#0x1c
   \   000041   F0           MOVX      @DPTR,A
     50            retransmite = 0;
   \   000042   90....       MOV       DPTR,#??retransmite
   \   000045   7400         MOV       A,#0x0
   \   000047   F0           MOVX      @DPTR,A
     51          };
   \   000048   02....       LJMP      ?BRET
     52          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     53          static void Cold_Start(void){
   \                     ??Cold_Start_3:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     54          };
   \   000000   02....       LJMP      ?BRET
     55          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     56          static inline bool validate_sync(struct sync *sync){
   \                     ??validate_sync:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004   C0..         PUSH      ?V2
   \   000006   C0..         PUSH      ?V3
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
     57            bool valid = 
     58              (sync->magic == MAGIC) &&
     59              (sync->panid == MODEL.SYNC.panid);
   \   000008   90....       MOV       DPTR,#__Constant_19833891
   \   00000B   78..         MOV       R0,#?V0
   \   00000D   12....       LCALL     ?L_MOV_X
   \   000010   8A82         MOV       DPL,R2
   \   000012   8B83         MOV       DPH,R3
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   78..         MOV       R0,#?V0
   \   00001D   12....       LCALL     ?L_EQ_X
   \   000020   7013         JNZ       ??validate_sync_1
   \   000022   8A82         MOV       DPL,R2
   \   000024   8B83         MOV       DPH,R3
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   E0           MOVX      A,@DPTR
   \   000029   F8           MOV       R0,A
   \   00002A   90....       MOV       DPTR,#MODEL + 149
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   68           XRL       A,R0
   \   00002F   7004         JNZ       ??validate_sync_1
   \   000031   D2F0         SETB      B.0
   \   000033   8002         SJMP      ??validate_sync_2
   \                     ??validate_sync_1:
   \   000035   C2F0         CLR       B.0
     60            return valid;
   \                     ??validate_sync_2:
   \   000037   A2F0         MOV       C,B.0
   \   000039   D0..         POP       ?V3
   \   00003B   D0..         POP       ?V2
   \   00003D   D0..         POP       ?V1
   \   00003F   D0..         POP       ?V0
   \   000041   02....       LJMP      ?BRET
     61          }
     62          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     63          static inline void accept_sync_data(struct sync *sync){
   \                     ??accept_sync_data:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
     64            MODEL.RTC.rtc = sync->rtc;
   \   000006   8A82         MOV       DPL,R2
   \   000008   8B83         MOV       DPH,R3
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   12....       LCALL     ?XLOAD_R4567
   \   000010   90....       MOV       DPTR,#MODEL + 8
   \   000013   12....       LCALL     ?XSTORE_R4567
     65          };
   \   000016   D0E0         POP       A
   \   000018   FF           MOV       R7,A
   \   000019   D0E0         POP       A
   \   00001B   FE           MOV       R6,A
   \   00001C   02....       LJMP      ?BRET
     66          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     67          static inline void syncronize_timer(struct frame *frame){
   \                     ??syncronize_timer:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
     68            nwtime_t now = AT_time();
   \   000009                ; Setup parameters for call to function AT_time
   \   000009   12....       LCALL     `??AT_time::?relay`; Banked call to: AT_time
   \   00000C   8A..         MOV       ?V0,R2
   \   00000E   8B..         MOV       ?V1,R3
   \   000010   85....       MOV       ?V4,?V0
   \   000013   85....       MOV       ?V5,?V1
     69            // Время прошедшее с момента получения пакета
     70            // RI_Send корректриует время, чтобы SFD был передан в SEND_TIME
     71            // Поэтому нам корректировать ненужно
     72            nwtime_t passed = AT_interval(now, frame->meta.TIMESTAMP);  
   \   000016                ; Setup parameters for call to function AT_interval
   \   000016   8E82         MOV       DPL,R6
   \   000018   8F83         MOV       DPH,R7
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   FC           MOV       R4,A
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   FD           MOV       R5,A
   \   000020   AA..         MOV       R2,?V4
   \   000022   AB..         MOV       R3,?V5
   \   000024   12....       LCALL     `??AT_interval::?relay`; Banked call to: AT_interval
   \   000027   8A..         MOV       ?V0,R2
   \   000029   8B..         MOV       ?V1,R3
   \   00002B   85....       MOV       ?V2,?V0
   \   00002E   85....       MOV       ?V3,?V1
     73            AT_set_time(SYNC_TIME + passed);
   \   000031                ; Setup parameters for call to function AT_set_time
   \   000031   E5..         MOV       A,?V2
   \   000033   24A3         ADD       A,#-0x5d
   \   000035   FA           MOV       R2,A
   \   000036   E4           CLR       A
   \   000037   35..         ADDC      A,?V3
   \   000039   FB           MOV       R3,A
   \   00003A   12....       LCALL     `??AT_set_time::?relay`; Banked call to: AT_set_time
     74            MODEL.SYNC.sync_err = SYNC_TIME - frame->meta.TIMESTAMP;
   \   00003D   8E82         MOV       DPL,R6
   \   00003F   8F83         MOV       DPH,R7
   \   000041   A3           INC       DPTR
   \   000042   E0           MOVX      A,@DPTR
   \   000043   F8           MOV       R0,A
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   F9           MOV       R1,A
   \   000047   74A3         MOV       A,#-0x5d
   \   000049   C3           CLR       C
   \   00004A   98           SUBB      A,R0
   \   00004B   F8           MOV       R0,A
   \   00004C   7400         MOV       A,#0x0
   \   00004E   99           SUBB      A,R1
   \   00004F   F9           MOV       R1,A
   \   000050   90....       MOV       DPTR,#MODEL + 135
   \   000053   E8           MOV       A,R0
   \   000054   F0           MOVX      @DPTR,A
   \   000055   A3           INC       DPTR
   \   000056   E9           MOV       A,R1
   \   000057   F0           MOVX      @DPTR,A
     75            LOG_ON("Sync err %d", MODEL.SYNC.sync_err);
   \   000058                ; Setup parameters for call to function printf
   \   000058   74..         MOV       A,#??__FUNCTION___5 & 0xff
   \   00005A   C0E0         PUSH      A
   \   00005C   74..         MOV       A,#(??__FUNCTION___5 >> 8) & 0xff
   \   00005E   C0E0         PUSH      A
   \   000060   744B         MOV       A,#0x4b
   \   000062   C0E0         PUSH      A
   \   000064   7400         MOV       A,#0x0
   \   000066   C0E0         PUSH      A
   \   000068   74..         MOV       A,#`?<Constant "sync.c">` & 0xff
   \   00006A   C0E0         PUSH      A
   \   00006C   74..         MOV       A,#(`?<Constant "sync.c">` >> 8) & 0xff
   \   00006E   C0E0         PUSH      A
   \   000070   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_2` & 0xff
   \   000072   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_2` >> 8) & 0xff
   \   000074   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000077   74FA         MOV       A,#-0x6
   \   000079   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00007C                ; Setup parameters for call to function printf
   \   00007C   90....       MOV       DPTR,#MODEL + 135
   \   00007F   12....       LCALL     ?PUSH_ISTACK_X_TWO
   \   000082   7A..         MOV       R2,#`?<Constant "Sync err %d">` & 0xff
   \   000084   7B..         MOV       R3,#(`?<Constant "Sync err %d">` >> 8) & 0xff
   \   000086   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000089   D0E0         POP       A
   \   00008B   D0E0         POP       A
   \   00008D                ; Setup parameters for call to function printf
   \   00008D   7A..         MOV       R2,#`?<Constant "\\r\\n">_2` & 0xff
   \   00008F   7B..         MOV       R3,#(`?<Constant "\\r\\n">_2` >> 8) & 0xff
   \   000091   12....       LCALL     `??printf::?relay`; Banked call to: printf
     76          };
   \   000094   7F06         MOV       R7,#0x6
   \   000096   02....       LJMP      ?BANKED_LEAVE_SP
     77          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     78          static inline void mode_1_receive_process(void){
   \                     ??mode_1_receive_process:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
     79            LOW(PIN1);
   \   000005   C290         CLR       0x90.0
     80            struct frame *fr = recv_sync();
   \   000007                ; Setup parameters for call to function recv_sync
   \   000007   12....       LCALL     `??recv_sync::?relay`; Banked call to: recv_sync
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   AE..         MOV       R6,?V0
   \   000010   AF..         MOV       R7,?V1
     81            if (!fr)
   \   000012   EE           MOV       A,R6
   \   000013   4F           ORL       A,R7
   \   000014   7003         JNZ       $+5
   \   000016   02....       LJMP      ??mode_1_receive_process_1 & 0xFFFF
     82              return;
     83            
     84            struct sync *sync = (struct sync*)(fr->payload);
   \   000019   EE           MOV       A,R6
   \   00001A   2415         ADD       A,#0x15
   \   00001C   F5..         MOV       ?V4,A
   \   00001E   E4           CLR       A
   \   00001F   3F           ADDC      A,R7
   \   000020   F5..         MOV       ?V5,A
     85            if (!validate_sync(sync)){
   \   000022                ; Setup parameters for call to function validate_sync
   \   000022   AA..         MOV       R2,?V4
   \   000024   AB..         MOV       R3,?V5
   \   000026   12....       LCALL     `??validate_sync::?relay`; Banked call to: validate_sync
   \   000029   400A         JC        ??mode_1_receive_process_2
     86              FR_delete(fr);
   \   00002B                ; Setup parameters for call to function FR_delete
   \   00002B   EE           MOV       A,R6
   \   00002C   FA           MOV       R2,A
   \   00002D   EF           MOV       A,R7
   \   00002E   FB           MOV       R3,A
   \   00002F   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
     87              return;
   \   000032   02....       LJMP      ??mode_1_receive_process_1 & 0xFFFF
     88            }
     89            syncronize_timer(fr);
   \                     ??mode_1_receive_process_2:
   \   000035                ; Setup parameters for call to function syncronize_timer
   \   000035   EE           MOV       A,R6
   \   000036   FA           MOV       R2,A
   \   000037   EF           MOV       A,R7
   \   000038   FB           MOV       R3,A
   \   000039   12....       LCALL     `??syncronize_timer::?relay`; Banked call to: syncronize_timer
     90            accept_sync_data(sync);
   \   00003C                ; Setup parameters for call to function accept_sync_data
   \   00003C   AA..         MOV       R2,?V4
   \   00003E   AB..         MOV       R3,?V5
   \   000040   12....       LCALL     `??accept_sync_data::?relay`; Banked call to: accept_sync_data
     91            FR_delete(fr);
   \   000043                ; Setup parameters for call to function FR_delete
   \   000043   EE           MOV       A,R6
   \   000044   FA           MOV       R2,A
   \   000045   EF           MOV       A,R7
   \   000046   FB           MOV       R3,A
   \   000047   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
     92            LOG_ON("Sichronize sync RSSI = %d", fr->meta.RSSI_SIG);
   \   00004A                ; Setup parameters for call to function printf
   \   00004A   74..         MOV       A,#??__FUNCTION___6 & 0xff
   \   00004C   C0E0         PUSH      A
   \   00004E   74..         MOV       A,#(??__FUNCTION___6 >> 8) & 0xff
   \   000050   C0E0         PUSH      A
   \   000052   745C         MOV       A,#0x5c
   \   000054   C0E0         PUSH      A
   \   000056   7400         MOV       A,#0x0
   \   000058   C0E0         PUSH      A
   \   00005A   74..         MOV       A,#`?<Constant "sync.c">` & 0xff
   \   00005C   C0E0         PUSH      A
   \   00005E   74..         MOV       A,#(`?<Constant "sync.c">` >> 8) & 0xff
   \   000060   C0E0         PUSH      A
   \   000062   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_2` & 0xff
   \   000064   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_2` >> 8) & 0xff
   \   000066   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000069   74FA         MOV       A,#-0x6
   \   00006B   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00006E                ; Setup parameters for call to function printf
   \   00006E   8E82         MOV       DPL,R6
   \   000070   8F83         MOV       DPH,R7
   \   000072   A3           INC       DPTR
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   E0           MOVX      A,@DPTR
   \   000076   F582         MOV       DPL,A
   \   000078   33           RLC       A
   \   000079   95E0         SUBB      A,0xE0 /* A   */
   \   00007B   F583         MOV       DPH,A
   \   00007D   C082         PUSH      DPL
   \   00007F   C083         PUSH      DPH
   \   000081   7A..         MOV       R2,#`?<Constant "Sichronize sync RSSI ...">` & 0xff
   \   000083   7B..         MOV       R3,#(`?<Constant "Sichronize sync RSSI ...">` >> 8) & 0xff
   \   000085   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000088   D0E0         POP       A
   \   00008A   D0E0         POP       A
   \   00008C                ; Setup parameters for call to function printf
   \   00008C   7A..         MOV       R2,#`?<Constant "\\r\\n">_2` & 0xff
   \   00008E   7B..         MOV       R3,#(`?<Constant "\\r\\n">_2` >> 8) & 0xff
   \   000090   12....       LCALL     `??printf::?relay`; Banked call to: printf
     93            retransmite = RETRANSMITE_TRY;
   \   000093   90....       MOV       DPTR,#??retransmite
   \   000096   7403         MOV       A,#0x3
   \   000098   F0           MOVX      @DPTR,A
     94            MODEL.SYNC.next_time_recv = MODEL.RTC.uptime + SEND_PERIOD;
   \   000099   90....       MOV       DPTR,#MODEL + 4
   \   00009C   78..         MOV       R0,#?V0
   \   00009E   12....       LCALL     ?L_MOV_X
   \   0000A1   90....       MOV       DPTR,#__Constant_a
   \   0000A4   78..         MOV       R0,#?V0
   \   0000A6   12....       LCALL     ?L_ADD_X
   \   0000A9   AA..         MOV       R2,?V0
   \   0000AB   AB..         MOV       R3,?V1
   \   0000AD   AC..         MOV       R4,?V2
   \   0000AF   AD..         MOV       R5,?V3
   \   0000B1   90....       MOV       DPTR,#MODEL + 141
   \   0000B4   EA           MOV       A,R2
   \   0000B5   F0           MOVX      @DPTR,A
   \   0000B6   A3           INC       DPTR
   \   0000B7   EB           MOV       A,R3
   \   0000B8   F0           MOVX      @DPTR,A
   \   0000B9   A3           INC       DPTR
   \   0000BA   EC           MOV       A,R4
   \   0000BB   F0           MOVX      @DPTR,A
   \   0000BC   A3           INC       DPTR
   \   0000BD   ED           MOV       A,R5
   \   0000BE   F0           MOVX      @DPTR,A
     95            MODEL.SYNC.last_time_recv = MODEL.RTC.uptime;   
   \   0000BF   90....       MOV       DPTR,#MODEL + 4
   \   0000C2   12....       LCALL     ?XLOAD_R0123
   \   0000C5   90....       MOV       DPTR,#MODEL + 145
   \   0000C8   12....       LCALL     ?XSTORE_R0123
     96            HIGH(PIN1);
   \   0000CB   D290         SETB      0x90.0
     97          }
   \                     ??mode_1_receive_process_1:
   \   0000CD   7F06         MOV       R7,#0x6
   \   0000CF   02....       LJMP      ?BANKED_LEAVE_SP
   \   0000D2                REQUIRE _A_P1
     98          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     99          static inline bool _throw_dice(void){
   \                     ??_throw_dice:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    100            return  ((rand() % 100) <= PROBABILIT) ? true : false;
   \   000004                ; Setup parameters for call to function rand
   \   000004   12....       LCALL     `??rand::?relay` ; Banked call to: rand
   \   000007   EA           MOV       A,R2
   \   000008   F8           MOV       R0,A
   \   000009   EB           MOV       A,R3
   \   00000A   F9           MOV       R1,A
   \   00000B   7A64         MOV       R2,#0x64
   \   00000D   7B00         MOV       R3,#0x0
   \   00000F   12....       LCALL     ?S_DIV_MOD
   \   000012   8A..         MOV       ?V0,R2
   \   000014   8B..         MOV       ?V1,R3
   \   000016   C3           CLR       C
   \   000017   E5..         MOV       A,?V0
   \   000019   9429         SUBB      A,#0x29
   \   00001B   E5..         MOV       A,?V1
   \   00001D   9400         SUBB      A,#0x0
   \   00001F   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000021   65D0         XRL       A,PSW
   \   000023   33           RLC       A
   \   000024   5004         JNC       ??_throw_dice_1
   \   000026   D2F0         SETB      B.0
   \   000028   8002         SJMP      ??_throw_dice_2
   \                     ??_throw_dice_1:
   \   00002A   C2F0         CLR       B.0
   \                     ??_throw_dice_2:
   \   00002C   A2F0         MOV       C,B.0
   \   00002E   D0..         POP       ?V1
   \   000030   D0..         POP       ?V0
   \   000032   02....       LJMP      ?BRET
    101          };
    102          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    103          static inline void mode_1_retransmition_process(void){
   \                     ??mode_1_retransmition_process:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    104            retransmite--;
   \   000000   90....       MOV       DPTR,#??retransmite
   \   000003   E0           MOVX      A,@DPTR
   \   000004   24FF         ADD       A,#-0x1
   \   000006   F0           MOVX      @DPTR,A
    105            if (!_throw_dice())
   \   000007                ; Setup parameters for call to function _throw_dice
   \   000007   12....       LCALL     `??_throw_dice::?relay`; Banked call to: _throw_dice
   \   00000A   5009         JNC       ??mode_1_retransmition_process_1
    106              return;
    107            send_sync();
   \   00000C                ; Setup parameters for call to function send_sync
   \   00000C   12....       LCALL     `??send_sync::?relay`; Banked call to: send_sync
    108            retransmite = 0;
   \   00000F   90....       MOV       DPTR,#??retransmite
   \   000012   7400         MOV       A,#0x0
   \   000014   F0           MOVX      @DPTR,A
    109          }
   \                     ??mode_1_retransmition_process_1:
   \   000015   02....       LJMP      ?BRET
    110          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    111          static void mode_1_process(){
   \                     ??mode_1_process:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004   C0..         PUSH      ?V2
   \   000006   C0..         PUSH      ?V3
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
    112           // Прием, ретрансляция, синхронизация   
    113            if ( MODEL.RTC.uptime >= MODEL.SYNC.next_time_recv)
   \   000008   90....       MOV       DPTR,#MODEL + 141
   \   00000B   78..         MOV       R0,#?V0
   \   00000D   12....       LCALL     ?L_MOV_X
   \   000010   90....       MOV       DPTR,#MODEL + 4
   \   000013   78..         MOV       R0,#?V0
   \   000015   12....       LCALL     ?UL_GT_X
   \   000018   4005         JC        ??mode_1_process_1
    114              mode_1_receive_process();
   \   00001A                ; Setup parameters for call to function mode_1_receive_process
   \   00001A   12....       LCALL     `??mode_1_receive_process::?relay`; Banked call to: mode_1_receive_process
   \   00001D   8009         SJMP      ??mode_1_process_2
    115            else if(retransmite)
   \                     ??mode_1_process_1:
   \   00001F   90....       MOV       DPTR,#??retransmite
   \   000022   E0           MOVX      A,@DPTR
   \   000023   6003         JZ        ??mode_1_process_2
    116              mode_1_retransmition_process();
   \   000025                ; Setup parameters for call to function mode_1_retransmition_process
   \   000025   12....       LCALL     `??mode_1_retransmition_process::?relay`; Banked call to: mode_1_retransmition_process
    117            
    118            if (MODEL.RTC.uptime - MODEL.SYNC.last_time_recv > UNSYNC_TIME){
   \                     ??mode_1_process_2:
   \   000028   90....       MOV       DPTR,#__Constant_3d
   \   00002B   C082         PUSH      DPL
   \   00002D   C083         PUSH      DPH
   \   00002F   90....       MOV       DPTR,#MODEL + 4
   \   000032   78..         MOV       R0,#?V0
   \   000034   12....       LCALL     ?L_MOV_X
   \   000037   90....       MOV       DPTR,#MODEL + 145
   \   00003A   78..         MOV       R0,#?V0
   \   00003C   12....       LCALL     ?L_SUB_X
   \   00003F   D083         POP       DPH
   \   000041   D082         POP       DPL
   \   000043   78..         MOV       R0,#?V0
   \   000045   12....       LCALL     ?UL_GE_X
   \   000048   5044         JNC       ??mode_1_process_3
    119              MODEL.SYNC.synced = false;
   \   00004A   7400         MOV       A,#0x0
   \   00004C   90....       MOV       DPTR,#MODEL + 132
   \   00004F   F0           MOVX      @DPTR,A
    120              MODEL.SYNC.mode = 0;
   \   000050   90....       MOV       DPTR,#MODEL + 131
   \   000053   7400         MOV       A,#0x0
   \   000055   F0           MOVX      @DPTR,A
    121              MODEL.TM.MODE = 0;
   \   000056   90....       MOV       DPTR,#MODEL + 12
   \   000059   7400         MOV       A,#0x0
   \   00005B   F0           MOVX      @DPTR,A
    122              LOG_ON("unsynced");
   \   00005C                ; Setup parameters for call to function printf
   \   00005C   74..         MOV       A,#??__FUNCTION___7 & 0xff
   \   00005E   C0E0         PUSH      A
   \   000060   74..         MOV       A,#(??__FUNCTION___7 >> 8) & 0xff
   \   000062   C0E0         PUSH      A
   \   000064   747A         MOV       A,#0x7a
   \   000066   C0E0         PUSH      A
   \   000068   7400         MOV       A,#0x0
   \   00006A   C0E0         PUSH      A
   \   00006C   74..         MOV       A,#`?<Constant "sync.c">` & 0xff
   \   00006E   C0E0         PUSH      A
   \   000070   74..         MOV       A,#(`?<Constant "sync.c">` >> 8) & 0xff
   \   000072   C0E0         PUSH      A
   \   000074   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_2` & 0xff
   \   000076   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_2` >> 8) & 0xff
   \   000078   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00007B   74FA         MOV       A,#-0x6
   \   00007D   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000080                ; Setup parameters for call to function printf
   \   000080   7A..         MOV       R2,#`?<Constant "unsynced">` & 0xff
   \   000082   7B..         MOV       R3,#(`?<Constant "unsynced">` >> 8) & 0xff
   \   000084   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000087                ; Setup parameters for call to function printf
   \   000087   7A..         MOV       R2,#`?<Constant "\\r\\n">_2` & 0xff
   \   000089   7B..         MOV       R3,#(`?<Constant "\\r\\n">_2` >> 8) & 0xff
   \   00008B   12....       LCALL     `??printf::?relay`; Banked call to: printf
    123            }
    124          }
   \                     ??mode_1_process_3:
   \   00008E   D0..         POP       ?V3
   \   000090   D0..         POP       ?V2
   \   000092   D0..         POP       ?V1
   \   000094   D0..         POP       ?V0
   \   000096   02....       LJMP      ?BRET
    125          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    126          static void mode_2_process(){
   \                     ??mode_2_process:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004   C0..         PUSH      ?V2
   \   000006   C0..         PUSH      ?V3
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
    127            // Периодическое вещание
    128            if ( MODEL.RTC.uptime < MODEL.SYNC.next_sync_send)
   \   000008   90....       MOV       DPTR,#MODEL + 137
   \   00000B   78..         MOV       R0,#?V0
   \   00000D   12....       LCALL     ?L_MOV_X
   \   000010   90....       MOV       DPTR,#MODEL + 4
   \   000013   78..         MOV       R0,#?V0
   \   000015   12....       LCALL     ?UL_GT_X
   \   000018   401F         JC        ??mode_2_process_1
    129              return;
    130            MODEL.SYNC.next_sync_send = MODEL.RTC.uptime + SEND_PERIOD;
   \   00001A   90....       MOV       DPTR,#MODEL + 4
   \   00001D   78..         MOV       R0,#?V0
   \   00001F   12....       LCALL     ?L_MOV_X
   \   000022   90....       MOV       DPTR,#__Constant_a
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?L_ADD_X
   \   00002A   90....       MOV       DPTR,#MODEL + 137
   \   00002D   78..         MOV       R0,#?V0
   \   00002F   12....       LCALL     ?L_MOV_TO_X
    131            LOW(PIN1);
   \   000032   C290         CLR       0x90.0
    132            send_sync();
   \   000034                ; Setup parameters for call to function send_sync
   \   000034   12....       LCALL     `??send_sync::?relay`; Banked call to: send_sync
    133            HIGH(PIN1);
   \   000037   D290         SETB      0x90.0
    134          }
   \                     ??mode_2_process_1:
   \   000039   D0..         POP       ?V3
   \   00003B   D0..         POP       ?V2
   \   00003D   D0..         POP       ?V1
   \   00003F   D0..         POP       ?V0
   \   000041   02....       LJMP      ?BRET
   \   000044                REQUIRE _A_P1
    135          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    136          static void Hot_Start(void){
   \                     ??Hot_Start_3:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    137            if (MODEL.TM.timeslot != SYNC_TS)
   \   000000   90....       MOV       DPTR,#MODEL + 13
   \   000003   E0           MOVX      A,@DPTR
   \   000004   7046         JNZ       ??Hot_Start_7
    138              return;
    139            switch(MODEL.SYNC.mode){
   \   000006   90....       MOV       DPTR,#MODEL + 131
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   6040         JZ        ??Hot_Start_7
   \   00000C   14           DEC       A
   \   00000D   6005         JZ        ??Hot_Start_8
   \   00000F   14           DEC       A
   \   000010   6007         JZ        ??Hot_Start_9
   \   000012   800A         SJMP      ??Hot_Start_10
    140              case MODE_0: break;
    141              case MODE_1: mode_1_process(); break;
   \                     ??Hot_Start_8:
   \   000014                ; Setup parameters for call to function mode_1_process
   \   000014   12....       LCALL     `??mode_1_process::?relay`; Banked call to: mode_1_process
   \   000017   8033         SJMP      ??Hot_Start_7
    142              case MODE_2: mode_2_process(); break;
   \                     ??Hot_Start_9:
   \   000019                ; Setup parameters for call to function mode_2_process
   \   000019   12....       LCALL     `??mode_2_process::?relay`; Banked call to: mode_2_process
   \   00001C   802E         SJMP      ??Hot_Start_7
    143              default:
    144              HALT("Wrong mode");
   \                     ??Hot_Start_10:
   \   00001E                ; Setup parameters for call to function printf
   \   00001E   74..         MOV       A,#??__FUNCTION___8 & 0xff
   \   000020   C0E0         PUSH      A
   \   000022   74..         MOV       A,#(??__FUNCTION___8 >> 8) & 0xff
   \   000024   C0E0         PUSH      A
   \   000026   7490         MOV       A,#-0x70
   \   000028   C0E0         PUSH      A
   \   00002A   7400         MOV       A,#0x0
   \   00002C   C0E0         PUSH      A
   \   00002E   74..         MOV       A,#`?<Constant "sync.c">` & 0xff
   \   000030   C0E0         PUSH      A
   \   000032   74..         MOV       A,#(`?<Constant "sync.c">` >> 8) & 0xff
   \   000034   C0E0         PUSH      A
   \   000036   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_2` & 0xff
   \   000038   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_2` >> 8) & 0xff
   \   00003A   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00003D   74FA         MOV       A,#-0x6
   \   00003F   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000042                ; Setup parameters for call to function printf
   \   000042   7A..         MOV       R2,#`?<Constant "Wrong mode">` & 0xff
   \   000044   7B..         MOV       R3,#(`?<Constant "Wrong mode">` >> 8) & 0xff
   \   000046   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000049                ; Setup parameters for call to function DBG_CORE_HALT
   \   000049   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    145            }
    146          };
   \                     ??Hot_Start_7:
   \   00004C   02....       LJMP      ?BRET
    147          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    148          static struct frame* recv_sync(void){
   \                     ??recv_sync:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 50
   \   000005   7432         MOV       A,#0x32
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
    149            if(!RI_SetChannel(MODEL.SYNC.sync_channel))
   \   00000A                ; Setup parameters for call to function RI_SetChannel
   \   00000A   90....       MOV       DPTR,#MODEL + 134
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   F9           MOV       R1,A
   \   00000F   12....       LCALL     `??RI_SetChannel::?relay`; Banked call to: RI_SetChannel
   \   000012   402E         JC        ??recv_sync_1
    150              HALT("Wrong channel");
   \   000014                ; Setup parameters for call to function printf
   \   000014   74..         MOV       A,#??__FUNCTION___9 & 0xff
   \   000016   C0E0         PUSH      A
   \   000018   74..         MOV       A,#(??__FUNCTION___9 >> 8) & 0xff
   \   00001A   C0E0         PUSH      A
   \   00001C   7496         MOV       A,#-0x6a
   \   00001E   C0E0         PUSH      A
   \   000020   7400         MOV       A,#0x0
   \   000022   C0E0         PUSH      A
   \   000024   74..         MOV       A,#`?<Constant "sync.c">` & 0xff
   \   000026   C0E0         PUSH      A
   \   000028   74..         MOV       A,#(`?<Constant "sync.c">` >> 8) & 0xff
   \   00002A   C0E0         PUSH      A
   \   00002C   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_2` & 0xff
   \   00002E   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_2` >> 8) & 0xff
   \   000030   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000033   74FA         MOV       A,#-0x6
   \   000035   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000038                ; Setup parameters for call to function printf
   \   000038   7A..         MOV       R2,#`?<Constant "Wrong channel">_1` & 0xff
   \   00003A   7B..         MOV       R3,#(`?<Constant "Wrong channel">_1` >> 8) & 0xff
   \   00003C   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00003F                ; Setup parameters for call to function DBG_CORE_HALT
   \   00003F   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    151            struct frame *frame;
    152            
    153            AT_wait(SYNC_TIME - NEG_RECV_OFFSET);
   \                     ??recv_sync_1:
   \   000042                ; Setup parameters for call to function AT_wait
   \   000042   7A82         MOV       R2,#-0x7e
   \   000044   7B00         MOV       R3,#0x0
   \   000046   12....       LCALL     `??AT_wait::?relay`; Banked call to: AT_wait
    154            ustime_t recv_time = NWTIME_TO_US(NEG_RECV_OFFSET + POS_RECV_OFFSET);
   \   000049   75..FE       MOV       ?V0,#-0x2
   \   00004C   75..07       MOV       ?V1,#0x7
   \   00004F   75..00       MOV       ?V2,#0x0
   \   000052   75..00       MOV       ?V3,#0x0
    155            TRY{
   \   000055   90FFCD       MOV       DPTR,#-0x33
   \   000058   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00005B   7408         MOV       A,#0x8
   \   00005D                REQUIRE ?V7
   \   00005D   12....       LCALL     ?SETJMP_XDATA
   \   000060   8A..         MOV       ?V4,R2
   \   000062   8B..         MOV       ?V5,R3
   \   000064   78..         MOV       R0,#?V4
   \   000066   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for recv_sync>_0`:
   \   000069   0000         DW        0
   \   00006B   02           DB        2
   \   00006C   ....         DW        ??recv_sync_2
   \   00006E   ....         DW        ??recv_sync_3
   \   000070   ....         DW        ??recv_sync_4
   \   000072   ....         DW        ??recv_sync_5
    156              frame = RI_Receive(recv_time);
   \                     ??recv_sync_3:
   \   000074                ; Setup parameters for call to function RI_Receive
   \   000074   AA..         MOV       R2,?V0
   \   000076   AB..         MOV       R3,?V1
   \   000078   AC..         MOV       R4,?V2
   \   00007A   AD..         MOV       R5,?V3
   \   00007C   12....       LCALL     `??RI_Receive::?relay`; Banked call to: RI_Receive
   \   00007F   8A..         MOV       ?V4,R2
   \   000081   8B..         MOV       ?V5,R3
   \   000083   AE..         MOV       R6,?V4
   \   000085   AF..         MOV       R7,?V5
    157              if (!frame)
   \   000087   EE           MOV       A,R6
   \   000088   4F           ORL       A,R7
   \   000089   700F         JNZ       ??recv_sync_6
    158                THROW(1);
   \   00008B   7A01         MOV       R2,#0x1
   \   00008D   7B00         MOV       R3,#0x0
   \   00008F   90FFCD       MOV       DPTR,#-0x33
   \   000092   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000095   7408         MOV       A,#0x8
   \   000097                REQUIRE ?V7
   \   000097   02....       LJMP      ?LONGJMP_XDATA
    159              if (frame->len != sizeof(struct sync))
   \                     ??recv_sync_6:
   \   00009A   8E82         MOV       DPL,R6
   \   00009C   8F83         MOV       DPH,R7
   \   00009E   E0           MOVX      A,@DPTR
   \   00009F   640B         XRL       A,#0xb
   \   0000A1   600F         JZ        ??recv_sync_7
    160                THROW(2);
   \   0000A3   7A02         MOV       R2,#0x2
   \   0000A5   7B00         MOV       R3,#0x0
   \   0000A7   90FFCD       MOV       DPTR,#-0x33
   \   0000AA   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000AD   7408         MOV       A,#0x8
   \   0000AF                REQUIRE ?V7
   \   0000AF   02....       LJMP      ?LONGJMP_XDATA
    161              AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
   \                     ??recv_sync_7:
   \   0000B2                ; Setup parameters for call to function AES_StreamCoder
   \   0000B2   8E82         MOV       DPL,R6
   \   0000B4   8F83         MOV       DPH,R7
   \   0000B6   E0           MOVX      A,@DPTR
   \   0000B7   F9           MOV       R1,A
   \   0000B8   EE           MOV       A,R6
   \   0000B9   2415         ADD       A,#0x15
   \   0000BB   FC           MOV       R4,A
   \   0000BC   E4           CLR       A
   \   0000BD   3F           ADDC      A,R7
   \   0000BE   FD           MOV       R5,A
   \   0000BF   EE           MOV       A,R6
   \   0000C0   2415         ADD       A,#0x15
   \   0000C2   FA           MOV       R2,A
   \   0000C3   E4           CLR       A
   \   0000C4   3F           ADDC      A,R7
   \   0000C5   FB           MOV       R3,A
   \   0000C6   C2F0         CLR       B.0
   \   0000C8   12....       LCALL     `??AES_StreamCoder::?relay`; Banked call to: AES_StreamCoder
    162              return frame;
   \   0000CB   EE           MOV       A,R6
   \   0000CC   FA           MOV       R2,A
   \   0000CD   EF           MOV       A,R7
   \   0000CE   FB           MOV       R3,A
   \   0000CF   8017         SJMP      ??recv_sync_8
    163            }
    164            CATCH(1){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    165              return NULL;
   \                     ??recv_sync_4:
   \   0000D1   7A00         MOV       R2,#0x0
   \   0000D3   7B00         MOV       R3,#0x0
   \   0000D5   8011         SJMP      ??recv_sync_8
    166            }
    167            CATCH(2){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    168              FR_delete(frame);
   \                     ??recv_sync_5:
   \   0000D7                ; Setup parameters for call to function FR_delete
   \   0000D7   EE           MOV       A,R6
   \   0000D8   FA           MOV       R2,A
   \   0000D9   EF           MOV       A,R7
   \   0000DA   FB           MOV       R3,A
   \   0000DB   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
    169              return NULL;
   \   0000DE   7A00         MOV       R2,#0x0
   \   0000E0   7B00         MOV       R3,#0x0
   \   0000E2   8004         SJMP      ??recv_sync_8
    170            }
    171            ETRY;
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    172            return frame;
   \                     ??recv_sync_2:
   \   0000E4   EE           MOV       A,R6
   \   0000E5   FA           MOV       R2,A
   \   0000E6   EF           MOV       A,R7
   \   0000E7   FB           MOV       R3,A
   \                     ??recv_sync_8:
   \   0000E8   74CE         MOV       A,#-0x32
   \   0000EA   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000ED   7F06         MOV       R7,#0x6
   \   0000EF   02....       LJMP      ?BANKED_LEAVE_SP
    173          }
    174          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    175          static bool send_sync(void){
   \                     ??send_sync:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   7402         MOV       A,#0x2
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 5
   \   000005                ; Auto size: 11
   \   000005   740B         MOV       A,#0xb
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
    176            struct sync sync;
    177            sync.sys_ch = MODEL.SYNC.sys_channel;
   \   00000A   90....       MOV       DPTR,#MODEL + 133
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   C0E0         PUSH      A
   \   000010   90FFF3       MOV       DPTR,#-0xd
   \   000013   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000016   D0E0         POP       A
   \   000018   F0           MOVX      @DPTR,A
    178            sync.tx_power = MODEL.RADIO.power_tx;
   \   000019   90....       MOV       DPTR,#MODEL + 95
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   C0E0         PUSH      A
   \   00001F   90FFF4       MOV       DPTR,#-0xc
   \   000022   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000025   D0E0         POP       A
   \   000027   F0           MOVX      @DPTR,A
    179            sync.panid = MODEL.SYNC.panid;
   \   000028   90....       MOV       DPTR,#MODEL + 149
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   C0E0         PUSH      A
   \   00002E   90FFF5       MOV       DPTR,#-0xb
   \   000031   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000034   D0E0         POP       A
   \   000036   F0           MOVX      @DPTR,A
    180            sync.rtc = MODEL.RTC.rtc;
   \   000037   90....       MOV       DPTR,#MODEL + 8
   \   00003A   12....       LCALL     ?XLOAD_R0123
   \   00003D   90FFF7       MOV       DPTR,#-0x9
   \   000040   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000043   12....       LCALL     ?XSTORE_R0123
    181            sync.magic = MAGIC;
   \   000046   90FFFB       MOV       DPTR,#-0x5
   \   000049   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00004C   7491         MOV       A,#-0x6f
   \   00004E   F0           MOVX      @DPTR,A
   \   00004F   A3           INC       DPTR
   \   000050   7438         MOV       A,#0x38
   \   000052   F0           MOVX      @DPTR,A
   \   000053   A3           INC       DPTR
   \   000054   7483         MOV       A,#-0x7d
   \   000056   F0           MOVX      @DPTR,A
   \   000057   A3           INC       DPTR
   \   000058   7419         MOV       A,#0x19
   \   00005A   F0           MOVX      @DPTR,A
    182            
    183            struct frame *fr = FR_create();
   \   00005B                ; Setup parameters for call to function FR_create
   \   00005B   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   00005E   8A..         MOV       ?V0,R2
   \   000060   8B..         MOV       ?V1,R3
   \   000062   AE..         MOV       R6,?V0
   \   000064   AF..         MOV       R7,?V1
    184            ASSERT(fr);
   \   000066   EE           MOV       A,R6
   \   000067   4F           ORL       A,R7
   \   000068   701F         JNZ       ??send_sync_1
   \   00006A                ; Setup parameters for call to function printf
   \   00006A   74B8         MOV       A,#-0x48
   \   00006C   C0E0         PUSH      A
   \   00006E   7400         MOV       A,#0x0
   \   000070   C0E0         PUSH      A
   \   000072   74..         MOV       A,#`?<Constant "sync.c">` & 0xff
   \   000074   C0E0         PUSH      A
   \   000076   74..         MOV       A,#(`?<Constant "sync.c">` >> 8) & 0xff
   \   000078   C0E0         PUSH      A
   \   00007A   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_6` & 0xff
   \   00007C   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_6` >> 8) & 0xff
   \   00007E   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000081   74FC         MOV       A,#-0x4
   \   000083   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000086                ; Setup parameters for call to function DBG_CORE_HALT
   \   000086   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    185            FR_add_header(fr, &sync, sizeof(struct sync));
   \                     ??send_sync_1:
   \   000089                ; Setup parameters for call to function FR_add_header
   \   000089   790B         MOV       R1,#0xb
   \   00008B   90FFF4       MOV       DPTR,#-0xc
   \   00008E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000091   AC82         MOV       R4,DPL
   \   000093   AD83         MOV       R5,DPH
   \   000095   EE           MOV       A,R6
   \   000096   FA           MOV       R2,A
   \   000097   EF           MOV       A,R7
   \   000098   FB           MOV       R3,A
   \   000099   12....       LCALL     `??FR_add_header::?relay`; Banked call to: FR_add_header
    186            
    187            fr->meta.SEND_TIME = (nwtime_t)SYNC_TIME;
   \   00009C   EE           MOV       A,R6
   \   00009D   2413         ADD       A,#0x13
   \   00009F   F582         MOV       DPL,A
   \   0000A1   E4           CLR       A
   \   0000A2   3F           ADDC      A,R7
   \   0000A3   F583         MOV       DPH,A
   \   0000A5   74A3         MOV       A,#-0x5d
   \   0000A7   F0           MOVX      @DPTR,A
   \   0000A8   A3           INC       DPTR
   \   0000A9   7400         MOV       A,#0x0
   \   0000AB   F0           MOVX      @DPTR,A
    188            AES_StreamCoder(true, fr->payload, fr->payload, fr->len);
   \   0000AC                ; Setup parameters for call to function AES_StreamCoder
   \   0000AC   8E82         MOV       DPL,R6
   \   0000AE   8F83         MOV       DPH,R7
   \   0000B0   E0           MOVX      A,@DPTR
   \   0000B1   F9           MOV       R1,A
   \   0000B2   EE           MOV       A,R6
   \   0000B3   2415         ADD       A,#0x15
   \   0000B5   FC           MOV       R4,A
   \   0000B6   E4           CLR       A
   \   0000B7   3F           ADDC      A,R7
   \   0000B8   FD           MOV       R5,A
   \   0000B9   EE           MOV       A,R6
   \   0000BA   2415         ADD       A,#0x15
   \   0000BC   FA           MOV       R2,A
   \   0000BD   E4           CLR       A
   \   0000BE   3F           ADDC      A,R7
   \   0000BF   FB           MOV       R3,A
   \   0000C0   D2F0         SETB      B.0
   \   0000C2   12....       LCALL     `??AES_StreamCoder::?relay`; Banked call to: AES_StreamCoder
    189            
    190            bool set_ch_res = RI_SetChannel(MODEL.SYNC.sync_channel);
   \   0000C5                ; Setup parameters for call to function RI_SetChannel
   \   0000C5   90....       MOV       DPTR,#MODEL + 134
   \   0000C8   E0           MOVX      A,@DPTR
   \   0000C9   F9           MOV       R1,A
   \   0000CA   12....       LCALL     `??RI_SetChannel::?relay`; Banked call to: RI_SetChannel
   \   0000CD   92..         MOV       ?VB.0,C
    191            ASSERT(set_ch_res);
   \   0000CF   A2..         MOV       C,?VB.0
   \   0000D1   401F         JC        ??send_sync_2
   \   0000D3                ; Setup parameters for call to function printf
   \   0000D3   74BF         MOV       A,#-0x41
   \   0000D5   C0E0         PUSH      A
   \   0000D7   7400         MOV       A,#0x0
   \   0000D9   C0E0         PUSH      A
   \   0000DB   74..         MOV       A,#`?<Constant "sync.c">` & 0xff
   \   0000DD   C0E0         PUSH      A
   \   0000DF   74..         MOV       A,#(`?<Constant "sync.c">` >> 8) & 0xff
   \   0000E1   C0E0         PUSH      A
   \   0000E3   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_6` & 0xff
   \   0000E5   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_6` >> 8) & 0xff
   \   0000E7   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0000EA   74FC         MOV       A,#-0x4
   \   0000EC   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000EF                ; Setup parameters for call to function DBG_CORE_HALT
   \   0000EF   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    192            bool res = RI_Send(fr);
   \                     ??send_sync_2:
   \   0000F2                ; Setup parameters for call to function RI_Send
   \   0000F2   EE           MOV       A,R6
   \   0000F3   FA           MOV       R2,A
   \   0000F4   EF           MOV       A,R7
   \   0000F5   FB           MOV       R3,A
   \   0000F6   12....       LCALL     `??RI_Send::?relay`; Banked call to: RI_Send
   \   0000F9   92..         MOV       ?VB.1,C
    193            FR_delete(fr);
   \   0000FB                ; Setup parameters for call to function FR_delete
   \   0000FB   EE           MOV       A,R6
   \   0000FC   FA           MOV       R2,A
   \   0000FD   EF           MOV       A,R7
   \   0000FE   FB           MOV       R3,A
   \   0000FF   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
    194            LOG_ON("SYNC sended, res = %d", res);
   \   000102                ; Setup parameters for call to function printf
   \   000102   74..         MOV       A,#??__FUNCTION___10 & 0xff
   \   000104   C0E0         PUSH      A
   \   000106   74..         MOV       A,#(??__FUNCTION___10 >> 8) & 0xff
   \   000108   C0E0         PUSH      A
   \   00010A   74C2         MOV       A,#-0x3e
   \   00010C   C0E0         PUSH      A
   \   00010E   7400         MOV       A,#0x0
   \   000110   C0E0         PUSH      A
   \   000112   74..         MOV       A,#`?<Constant "sync.c">` & 0xff
   \   000114   C0E0         PUSH      A
   \   000116   74..         MOV       A,#(`?<Constant "sync.c">` >> 8) & 0xff
   \   000118   C0E0         PUSH      A
   \   00011A   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_2` & 0xff
   \   00011C   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_2` >> 8) & 0xff
   \   00011E   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000121   74FA         MOV       A,#-0x6
   \   000123   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000126                ; Setup parameters for call to function printf
   \   000126   A2..         MOV       C,?VB.1
   \   000128   E4           CLR       A
   \   000129   33           RLC       A
   \   00012A   F582         MOV       DPL,A
   \   00012C   758300       MOV       DPH,#0x0
   \   00012F   C082         PUSH      DPL
   \   000131   C083         PUSH      DPH
   \   000133   7A..         MOV       R2,#`?<Constant "SYNC sended, res = %d">` & 0xff
   \   000135   7B..         MOV       R3,#(`?<Constant "SYNC sended, res = %d">` >> 8) & 0xff
   \   000137   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00013A   D0E0         POP       A
   \   00013C   D0E0         POP       A
   \   00013E                ; Setup parameters for call to function printf
   \   00013E   7A..         MOV       R2,#`?<Constant "\\r\\n">_2` & 0xff
   \   000140   7B..         MOV       R3,#(`?<Constant "\\r\\n">_2` >> 8) & 0xff
   \   000142   12....       LCALL     `??printf::?relay`; Banked call to: printf
    195            return res;
   \   000145   A2..         MOV       C,?VB.1
   \   000147   74F5         MOV       A,#-0xb
   \   000149   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00014C   7F02         MOV       R7,#0x2
   \   00014E   02....       LJMP      ?BANKED_LEAVE_SP
    196          }
    197          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    198          static struct frame* network_recv_sync(ustime_t timeout){
   \                     ??network_recv_sync:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   7406         MOV       A,#0x6
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 50
   \   000005   7432         MOV       A,#0x32
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   8C..         MOV       ?V2,R4
   \   000010   8D..         MOV       ?V3,R5
    199            if(!RI_SetChannel(MODEL.SYNC.sync_channel))
   \   000012                ; Setup parameters for call to function RI_SetChannel
   \   000012   90....       MOV       DPTR,#MODEL + 134
   \   000015   E0           MOVX      A,@DPTR
   \   000016   F9           MOV       R1,A
   \   000017   12....       LCALL     `??RI_SetChannel::?relay`; Banked call to: RI_SetChannel
   \   00001A   402E         JC        ??network_recv_sync_1
    200              HALT("Wrong channel");
   \   00001C                ; Setup parameters for call to function printf
   \   00001C   74..         MOV       A,#??__FUNCTION___11 & 0xff
   \   00001E   C0E0         PUSH      A
   \   000020   74..         MOV       A,#(??__FUNCTION___11 >> 8) & 0xff
   \   000022   C0E0         PUSH      A
   \   000024   74C8         MOV       A,#-0x38
   \   000026   C0E0         PUSH      A
   \   000028   7400         MOV       A,#0x0
   \   00002A   C0E0         PUSH      A
   \   00002C   74..         MOV       A,#`?<Constant "sync.c">` & 0xff
   \   00002E   C0E0         PUSH      A
   \   000030   74..         MOV       A,#(`?<Constant "sync.c">` >> 8) & 0xff
   \   000032   C0E0         PUSH      A
   \   000034   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_2` & 0xff
   \   000036   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_2` >> 8) & 0xff
   \   000038   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00003B   74FA         MOV       A,#-0x6
   \   00003D   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000040                ; Setup parameters for call to function printf
   \   000040   7A..         MOV       R2,#`?<Constant "Wrong channel">_1` & 0xff
   \   000042   7B..         MOV       R3,#(`?<Constant "Wrong channel">_1` >> 8) & 0xff
   \   000044   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000047                ; Setup parameters for call to function DBG_CORE_HALT
   \   000047   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    201            
    202            struct frame *frame = NULL;
   \                     ??network_recv_sync_1:
   \   00004A   7E00         MOV       R6,#0x0
   \   00004C   7F00         MOV       R7,#0x0
    203            TRY{
   \   00004E   90FFCD       MOV       DPTR,#-0x33
   \   000051   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000054   7408         MOV       A,#0x8
   \   000056                REQUIRE ?V7
   \   000056   12....       LCALL     ?SETJMP_XDATA
   \   000059   8A..         MOV       ?V4,R2
   \   00005B   8B..         MOV       ?V5,R3
   \   00005D   78..         MOV       R0,#?V4
   \   00005F   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for network_recv_sync>_0`:
   \   000062   0000         DW        0
   \   000064   02           DB        2
   \   000065   ....         DW        ??network_recv_sync_2
   \   000067   ....         DW        ??network_recv_sync_3
   \   000069   ....         DW        ??network_recv_sync_4
   \   00006B   ....         DW        ??network_recv_sync_5
    204              frame = RI_Receive(timeout);
   \                     ??network_recv_sync_3:
   \   00006D                ; Setup parameters for call to function RI_Receive
   \   00006D   AA..         MOV       R2,?V0
   \   00006F   AB..         MOV       R3,?V1
   \   000071   AC..         MOV       R4,?V2
   \   000073   AD..         MOV       R5,?V3
   \   000075   12....       LCALL     `??RI_Receive::?relay`; Banked call to: RI_Receive
   \   000078   8A..         MOV       ?V4,R2
   \   00007A   8B..         MOV       ?V5,R3
   \   00007C   AE..         MOV       R6,?V4
   \   00007E   AF..         MOV       R7,?V5
    205              if (!frame)
   \   000080   EE           MOV       A,R6
   \   000081   4F           ORL       A,R7
   \   000082   700F         JNZ       ??network_recv_sync_6
    206                THROW(1);
   \   000084   7A01         MOV       R2,#0x1
   \   000086   7B00         MOV       R3,#0x0
   \   000088   90FFCD       MOV       DPTR,#-0x33
   \   00008B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00008E   7408         MOV       A,#0x8
   \   000090                REQUIRE ?V7
   \   000090   02....       LJMP      ?LONGJMP_XDATA
    207              if (frame->len != sizeof(struct sync))
   \                     ??network_recv_sync_6:
   \   000093   8E82         MOV       DPL,R6
   \   000095   8F83         MOV       DPH,R7
   \   000097   E0           MOVX      A,@DPTR
   \   000098   640B         XRL       A,#0xb
   \   00009A   600F         JZ        ??network_recv_sync_7
    208                THROW(2);
   \   00009C   7A02         MOV       R2,#0x2
   \   00009E   7B00         MOV       R3,#0x0
   \   0000A0   90FFCD       MOV       DPTR,#-0x33
   \   0000A3   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A6   7408         MOV       A,#0x8
   \   0000A8                REQUIRE ?V7
   \   0000A8   02....       LJMP      ?LONGJMP_XDATA
    209              AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
   \                     ??network_recv_sync_7:
   \   0000AB                ; Setup parameters for call to function AES_StreamCoder
   \   0000AB   8E82         MOV       DPL,R6
   \   0000AD   8F83         MOV       DPH,R7
   \   0000AF   E0           MOVX      A,@DPTR
   \   0000B0   F9           MOV       R1,A
   \   0000B1   EE           MOV       A,R6
   \   0000B2   2415         ADD       A,#0x15
   \   0000B4   FC           MOV       R4,A
   \   0000B5   E4           CLR       A
   \   0000B6   3F           ADDC      A,R7
   \   0000B7   FD           MOV       R5,A
   \   0000B8   EE           MOV       A,R6
   \   0000B9   2415         ADD       A,#0x15
   \   0000BB   FA           MOV       R2,A
   \   0000BC   E4           CLR       A
   \   0000BD   3F           ADDC      A,R7
   \   0000BE   FB           MOV       R3,A
   \   0000BF   C2F0         CLR       B.0
   \   0000C1   12....       LCALL     `??AES_StreamCoder::?relay`; Banked call to: AES_StreamCoder
    210              return frame;
   \   0000C4   EE           MOV       A,R6
   \   0000C5   FA           MOV       R2,A
   \   0000C6   EF           MOV       A,R7
   \   0000C7   FB           MOV       R3,A
   \   0000C8   8017         SJMP      ??network_recv_sync_8
    211            }
    212            CATCH(1){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    213              return NULL;
   \                     ??network_recv_sync_4:
   \   0000CA   7A00         MOV       R2,#0x0
   \   0000CC   7B00         MOV       R3,#0x0
   \   0000CE   8011         SJMP      ??network_recv_sync_8
    214            }
    215            CATCH(2){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    216              FR_delete(frame);
   \                     ??network_recv_sync_5:
   \   0000D0                ; Setup parameters for call to function FR_delete
   \   0000D0   EE           MOV       A,R6
   \   0000D1   FA           MOV       R2,A
   \   0000D2   EF           MOV       A,R7
   \   0000D3   FB           MOV       R3,A
   \   0000D4   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
    217              return NULL;
   \   0000D7   7A00         MOV       R2,#0x0
   \   0000D9   7B00         MOV       R3,#0x0
   \   0000DB   8004         SJMP      ??network_recv_sync_8
    218            }
    219            ETRY;
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    220            return frame;
   \                     ??network_recv_sync_2:
   \   0000DD   EE           MOV       A,R6
   \   0000DE   FA           MOV       R2,A
   \   0000DF   EF           MOV       A,R7
   \   0000E0   FB           MOV       R3,A
   \                     ??network_recv_sync_8:
   \   0000E1   74CE         MOV       A,#-0x32
   \   0000E3   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000E6   7F06         MOV       R7,#0x6
   \   0000E8   02....       LJMP      ?BANKED_LEAVE_SP
    221          }
    222          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    223          bool network_sync(ustime_t timeout){  
   \                     network_sync:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 58
   \   000005   743A         MOV       A,#0x3a
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   90FFF7       MOV       DPTR,#-0x9
   \   00000D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   EC           MOV       A,R4
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   ED           MOV       A,R5
   \   00001A   F0           MOVX      @DPTR,A
    224            stamp_t now = UST_now();
   \   00001B                ; Setup parameters for call to function UST_now
   \   00001B   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   00001E   8A..         MOV       ?V0,R2
   \   000020   8B..         MOV       ?V1,R3
   \   000022   8C..         MOV       ?V2,R4
   \   000024   8D..         MOV       ?V3,R5
    225            struct frame *frame;
    226            struct sync *sync;
    227            
    228            TRY{
   \   000026   90FFC5       MOV       DPTR,#-0x3b
   \   000029   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00002C   7408         MOV       A,#0x8
   \   00002E                REQUIRE ?V7
   \   00002E   12....       LCALL     ?SETJMP_XDATA
   \   000031   8A..         MOV       ?V4,R2
   \   000033   8B..         MOV       ?V5,R3
   \   000035   78..         MOV       R0,#?V4
   \   000037   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for network_sync>_0`:
   \   00003A   0000         DW        0
   \   00003C   01           DB        1
   \   00003D   ....         DW        ??network_sync_0
   \   00003F   ....         DW        ??network_sync_1
   \   000041   ....         DW        ??network_sync_2
    229              while(true){
    230                if(UST_time_over(now, timeout))
   \                     ??network_sync_1:
   \   000043                ; Setup parameters for call to function UST_time_over
   \   000043   90FFF7       MOV       DPTR,#-0x9
   \   000046   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000049   78..         MOV       R0,#?V4
   \   00004B   12....       LCALL     ?L_MOV_X
   \   00004E   78..         MOV       R0,#?V4
   \   000050   12....       LCALL     ?PUSH_ISTACK_I_FOUR
   \   000053   AA..         MOV       R2,?V0
   \   000055   AB..         MOV       R3,?V1
   \   000057   AC..         MOV       R4,?V2
   \   000059   AD..         MOV       R5,?V3
   \   00005B   12....       LCALL     `??UST_time_over::?relay`; Banked call to: UST_time_over
   \   00005E   74FC         MOV       A,#-0x4
   \   000060   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000063   500F         JNC       ??network_sync_3
    231                   THROW(1);
   \   000065   7A01         MOV       R2,#0x1
   \   000067   7B00         MOV       R3,#0x0
   \   000069   90FFC5       MOV       DPTR,#-0x3b
   \   00006C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00006F   7408         MOV       A,#0x8
   \   000071                REQUIRE ?V7
   \   000071   02....       LJMP      ?LONGJMP_XDATA
    232                
    233                frame = network_recv_sync(timeout);
   \                     ??network_sync_3:
   \   000074                ; Setup parameters for call to function network_recv_sync
   \   000074   90FFF7       MOV       DPTR,#-0x9
   \   000077   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00007A   12....       LCALL     ?XLOAD_R2345
   \   00007D   12....       LCALL     `??network_recv_sync::?relay`; Banked call to: network_recv_sync
   \   000080   90FFFD       MOV       DPTR,#-0x3
   \   000083   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000086   EA           MOV       A,R2
   \   000087   F0           MOVX      @DPTR,A
   \   000088   A3           INC       DPTR
   \   000089   EB           MOV       A,R3
   \   00008A   F0           MOVX      @DPTR,A
    234                if (!frame)
   \   00008B   90FFFD       MOV       DPTR,#-0x3
   \   00008E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000091   E0           MOVX      A,@DPTR
   \   000092   F8           MOV       R0,A
   \   000093   A3           INC       DPTR
   \   000094   E0           MOVX      A,@DPTR
   \   000095   F9           MOV       R1,A
   \   000096   E8           MOV       A,R0
   \   000097   49           ORL       A,R1
   \   000098   60A9         JZ        ??network_sync_1
    235                   continue;
    236                
    237                sync = (struct sync*)frame->payload;
   \   00009A   90FFFD       MOV       DPTR,#-0x3
   \   00009D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A0   E0           MOVX      A,@DPTR
   \   0000A1   2415         ADD       A,#0x15
   \   0000A3   F8           MOV       R0,A
   \   0000A4   A3           INC       DPTR
   \   0000A5   E0           MOVX      A,@DPTR
   \   0000A6   3400         ADDC      A,#0x0
   \   0000A8   F9           MOV       R1,A
   \   0000A9   90FFFB       MOV       DPTR,#-0x5
   \   0000AC   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000AF   E8           MOV       A,R0
   \   0000B0   F0           MOVX      @DPTR,A
   \   0000B1   A3           INC       DPTR
   \   0000B2   E9           MOV       A,R1
   \   0000B3   F0           MOVX      @DPTR,A
    238                if (sync->magic != MAGIC){
   \   0000B4   90....       MOV       DPTR,#__Constant_19833891
   \   0000B7   78..         MOV       R0,#?V4
   \   0000B9   12....       LCALL     ?L_MOV_X
   \   0000BC   90FFFB       MOV       DPTR,#-0x5
   \   0000BF   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000C2   E0           MOVX      A,@DPTR
   \   0000C3   F8           MOV       R0,A
   \   0000C4   A3           INC       DPTR
   \   0000C5   E0           MOVX      A,@DPTR
   \   0000C6   C8           XCH       A,R0
   \   0000C7   2407         ADD       A,#0x7
   \   0000C9   F582         MOV       DPL,A
   \   0000CB   C8           XCH       A,R0
   \   0000CC   3400         ADDC      A,#0x0
   \   0000CE   F583         MOV       DPH,A
   \   0000D0   78..         MOV       R0,#?V4
   \   0000D2   12....       LCALL     ?L_EQ_X
   \   0000D5   6011         JZ        ??network_sync_4
    239                  FR_delete(frame);
   \   0000D7                ; Setup parameters for call to function FR_delete
   \   0000D7   90FFFD       MOV       DPTR,#-0x3
   \   0000DA   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000DD   E0           MOVX      A,@DPTR
   \   0000DE   FA           MOV       R2,A
   \   0000DF   A3           INC       DPTR
   \   0000E0   E0           MOVX      A,@DPTR
   \   0000E1   FB           MOV       R3,A
   \   0000E2   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
    240                  continue;
   \   0000E5   02....       LJMP      ??network_sync_1 & 0xFFFF
    241                }
    242               
    243                syncronize_timer(frame);
   \                     ??network_sync_4:
   \   0000E8                ; Setup parameters for call to function syncronize_timer
   \   0000E8   90FFFD       MOV       DPTR,#-0x3
   \   0000EB   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000EE   E0           MOVX      A,@DPTR
   \   0000EF   FA           MOV       R2,A
   \   0000F0   A3           INC       DPTR
   \   0000F1   E0           MOVX      A,@DPTR
   \   0000F2   FB           MOV       R3,A
   \   0000F3   12....       LCALL     `??syncronize_timer::?relay`; Banked call to: syncronize_timer
    244                
    245                MODEL.SYNC.synced = true;
   \   0000F6   7401         MOV       A,#0x1
   \   0000F8   90....       MOV       DPTR,#MODEL + 132
   \   0000FB   F0           MOVX      @DPTR,A
    246                MODEL.SYNC.sys_channel = sync->sys_ch;
   \   0000FC   90FFFB       MOV       DPTR,#-0x5
   \   0000FF   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000102   E0           MOVX      A,@DPTR
   \   000103   F8           MOV       R0,A
   \   000104   A3           INC       DPTR
   \   000105   E0           MOVX      A,@DPTR
   \   000106   F583         MOV       DPH,A
   \   000108   8882         MOV       DPL,R0
   \   00010A   E0           MOVX      A,@DPTR
   \   00010B   90....       MOV       DPTR,#MODEL + 133
   \   00010E   F0           MOVX      @DPTR,A
    247                MODEL.SYNC.panid = sync->panid;
   \   00010F   90FFFB       MOV       DPTR,#-0x5
   \   000112   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000115   E0           MOVX      A,@DPTR
   \   000116   F8           MOV       R0,A
   \   000117   A3           INC       DPTR
   \   000118   E0           MOVX      A,@DPTR
   \   000119   F583         MOV       DPH,A
   \   00011B   8882         MOV       DPL,R0
   \   00011D   A3           INC       DPTR
   \   00011E   A3           INC       DPTR
   \   00011F   E0           MOVX      A,@DPTR
   \   000120   90....       MOV       DPTR,#MODEL + 149
   \   000123   F0           MOVX      @DPTR,A
    248                MODEL.RADIO.power_tx = sync->tx_power;
   \   000124   90FFFB       MOV       DPTR,#-0x5
   \   000127   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00012A   E0           MOVX      A,@DPTR
   \   00012B   F8           MOV       R0,A
   \   00012C   A3           INC       DPTR
   \   00012D   E0           MOVX      A,@DPTR
   \   00012E   F583         MOV       DPH,A
   \   000130   8882         MOV       DPL,R0
   \   000132   A3           INC       DPTR
   \   000133   E0           MOVX      A,@DPTR
   \   000134   90....       MOV       DPTR,#MODEL + 95
   \   000137   F0           MOVX      @DPTR,A
    249                MODEL.RTC.rtc = sync->rtc;
   \   000138   90FFFB       MOV       DPTR,#-0x5
   \   00013B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00013E   E0           MOVX      A,@DPTR
   \   00013F   F8           MOV       R0,A
   \   000140   A3           INC       DPTR
   \   000141   E0           MOVX      A,@DPTR
   \   000142   F583         MOV       DPH,A
   \   000144   8882         MOV       DPL,R0
   \   000146   A3           INC       DPTR
   \   000147   A3           INC       DPTR
   \   000148   A3           INC       DPTR
   \   000149   12....       LCALL     ?XLOAD_R0123
   \   00014C   90....       MOV       DPTR,#MODEL + 8
   \   00014F   12....       LCALL     ?XSTORE_R0123
    250                
    251                retransmite = RETRANSMITE_TRY;
   \   000152   90....       MOV       DPTR,#??retransmite
   \   000155   7403         MOV       A,#0x3
   \   000157   F0           MOVX      @DPTR,A
    252                MODEL.SYNC.next_time_recv = MODEL.RTC.uptime +  SEND_PERIOD ;
   \   000158   90....       MOV       DPTR,#MODEL + 4
   \   00015B   78..         MOV       R0,#?V4
   \   00015D   12....       LCALL     ?L_MOV_X
   \   000160   90....       MOV       DPTR,#__Constant_a
   \   000163   78..         MOV       R0,#?V4
   \   000165   12....       LCALL     ?L_ADD_X
   \   000168   90....       MOV       DPTR,#MODEL + 141
   \   00016B   78..         MOV       R0,#?V4
   \   00016D   12....       LCALL     ?L_MOV_TO_X
    253                MODEL.SYNC.last_time_recv = MODEL.RTC.uptime;     
   \   000170   90....       MOV       DPTR,#MODEL + 4
   \   000173   12....       LCALL     ?XLOAD_R0123
   \   000176   90....       MOV       DPTR,#MODEL + 145
   \   000179   12....       LCALL     ?XSTORE_R0123
    254                break;
    255              }
    256            }
    257            CATCH(1){
   \   00017C   8011         SJMP      ??network_sync_0
    258              FR_delete(frame);
   \                     ??network_sync_2:
   \   00017E                ; Setup parameters for call to function FR_delete
   \   00017E   90FFFD       MOV       DPTR,#-0x3
   \   000181   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000184   E0           MOVX      A,@DPTR
   \   000185   FA           MOV       R2,A
   \   000186   A3           INC       DPTR
   \   000187   E0           MOVX      A,@DPTR
   \   000188   FB           MOV       R3,A
   \   000189   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
    259              return false; // timeout
   \   00018C   C3           CLR       C
   \   00018D   800F         SJMP      ??network_sync_5
    260            }
    261            FINALLY{
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\sync.c"
    262              FR_delete(frame);
   \                     ??network_sync_0:
   \   00018F                ; Setup parameters for call to function FR_delete
   \   00018F   90FFFD       MOV       DPTR,#-0x3
   \   000192   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000195   E0           MOVX      A,@DPTR
   \   000196   FA           MOV       R2,A
   \   000197   A3           INC       DPTR
   \   000198   E0           MOVX      A,@DPTR
   \   000199   FB           MOV       R3,A
   \   00019A   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
    263            }
    264            ETRY;
    265            return true;  
   \   00019D   D3           SETB      C
   \                     ??network_sync_5:
   \   00019E   74C6         MOV       A,#-0x3a
   \   0001A0   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001A3   7F08         MOV       R7,#0x8
   \   0001A5   02....       LJMP      ?BANKED_LEAVE_SP
    266          }
E:\Neocore\Hardware\STACK_CORE_SRC\time_manager.c
      1          #include "time_manager.h"
      2          #include "model.h"
      3          #include "action_manager.h"
      4          #include "debug.h"
      5          #include "cpu.h"

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   static __banked_func __ext_stack_reentrant char __cli(void)
   \                     ??__cli_3:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   C2AF         CLR       0xa8.7
   \   000002   7901         MOV       R1,#0x1
   \   000004   02....       LJMP      ?BRET
   \   000007                REQUIRE _A_IEN0
      6          #include "macros.h"
      7          
      8          /**
      9          @file
     10          */
     11          
     12          #define MAX_TIME_SLOTS 50
     13          
     14          #define ACTIVE_INTERVAL (nwtime_t)327 // 9.979 мс
     15          #define SLEEP_INTERVAL (nwtime_t)327  // 9.979 мс
     16          #define UNACCOUNTED 68 // Остаток времени после 50ого интервала.
     17          #define FULL_INTERVAL (ACTIVE_INTERVAL + SLEEP_INTERVAL)
     18          #define SLOT_TO_NWTIME(slot) ((nwtime_t)((slot) * FULL_INTERVAL)) 
     19          #define NWTIME_TO_SLOT(nwtime) ((timeslot_t)((time)/FULL_INTERVAL))
     20           
     21          //!< Список задач менеджера. Индекс - номер слота, значение-действие

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     22          static char ALARMS[MAX_TIME_SLOTS];
   \                     ??ALARMS:
   \   000000                DS 50
   \   000032                REQUIRE __INIT_XDATA_Z
     23          
     24          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     25          void TM_SetAlarm(timeslot_t slot, char alarm){
   \                     TM_SetAlarm:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
   \   000006   E9           MOV       A,R1
   \   000007   FE           MOV       R6,A
   \   000008   EA           MOV       A,R2
   \   000009   FF           MOV       R7,A
     26            ASSERT(slot < MAX_TIME_SLOTS);
   \   00000A   EE           MOV       A,R6
   \   00000B   C3           CLR       C
   \   00000C   9432         SUBB      A,#0x32
   \   00000E   401F         JC        ??TM_SetAlarm_0
   \   000010                ; Setup parameters for call to function printf
   \   000010   741A         MOV       A,#0x1a
   \   000012   C0E0         PUSH      A
   \   000014   7400         MOV       A,#0x0
   \   000016   C0E0         PUSH      A
   \   000018   74..         MOV       A,#`?<Constant "time_manager.c">` & 0xff
   \   00001A   C0E0         PUSH      A
   \   00001C   74..         MOV       A,#(`?<Constant "time_manager.c">` >> 8) & 0xff
   \   00001E   C0E0         PUSH      A
   \   000020   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_7` & 0xff
   \   000022   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_7` >> 8) & 0xff
   \   000024   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000027   74FC         MOV       A,#-0x4
   \   000029   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002C                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002C   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     27            ALARMS[slot] |= alarm;
   \                     ??TM_SetAlarm_0:
   \   00002F   EE           MOV       A,R6
   \   000030   F8           MOV       R0,A
   \   000031   7900         MOV       R1,#0x0
   \   000033   74..         MOV       A,#??ALARMS & 0xff
   \   000035   28           ADD       A,R0
   \   000036   F582         MOV       DPL,A
   \   000038   74..         MOV       A,#(??ALARMS >> 8) & 0xff
   \   00003A   39           ADDC      A,R1
   \   00003B   F583         MOV       DPH,A
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   4F           ORL       A,R7
   \   00003F   F0           MOVX      @DPTR,A
     28          }
   \   000040   D0E0         POP       A
   \   000042   FF           MOV       R7,A
   \   000043   D0E0         POP       A
   \   000045   FE           MOV       R6,A
   \   000046   02....       LJMP      ?BRET
     29          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     30          void TM_ClrAlarm(timeslot_t slot, char alarm){
   \                     TM_ClrAlarm:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
   \   000006   E9           MOV       A,R1
   \   000007   FE           MOV       R6,A
   \   000008   EA           MOV       A,R2
   \   000009   FF           MOV       R7,A
     31            ASSERT(slot < MAX_TIME_SLOTS);
   \   00000A   EE           MOV       A,R6
   \   00000B   C3           CLR       C
   \   00000C   9432         SUBB      A,#0x32
   \   00000E   401F         JC        ??TM_ClrAlarm_0
   \   000010                ; Setup parameters for call to function printf
   \   000010   741F         MOV       A,#0x1f
   \   000012   C0E0         PUSH      A
   \   000014   7400         MOV       A,#0x0
   \   000016   C0E0         PUSH      A
   \   000018   74..         MOV       A,#`?<Constant "time_manager.c">` & 0xff
   \   00001A   C0E0         PUSH      A
   \   00001C   74..         MOV       A,#(`?<Constant "time_manager.c">` >> 8) & 0xff
   \   00001E   C0E0         PUSH      A
   \   000020   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_7` & 0xff
   \   000022   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_7` >> 8) & 0xff
   \   000024   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000027   74FC         MOV       A,#-0x4
   \   000029   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00002C                ; Setup parameters for call to function DBG_CORE_HALT
   \   00002C   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     32            ALARMS[slot] &= ~alarm;
   \                     ??TM_ClrAlarm_0:
   \   00002F   EF           MOV       A,R7
   \   000030   F4           CPL       A
   \   000031   FA           MOV       R2,A
   \   000032   EE           MOV       A,R6
   \   000033   F8           MOV       R0,A
   \   000034   7900         MOV       R1,#0x0
   \   000036   74..         MOV       A,#??ALARMS & 0xff
   \   000038   28           ADD       A,R0
   \   000039   F582         MOV       DPL,A
   \   00003B   74..         MOV       A,#(??ALARMS >> 8) & 0xff
   \   00003D   39           ADDC      A,R1
   \   00003E   F583         MOV       DPH,A
   \   000040   E0           MOVX      A,@DPTR
   \   000041   5A           ANL       A,R2
   \   000042   F0           MOVX      @DPTR,A
     33          }
   \   000043   D0E0         POP       A
   \   000045   FF           MOV       R7,A
   \   000046   D0E0         POP       A
   \   000048   FE           MOV       R6,A
   \   000049   02....       LJMP      ?BRET
     34          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     35          static inline timeslot_t _inc_timeslot(timeslot_t slot){
   \                     ??_inc_timeslot:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV       A,R1
   \   000001   F8           MOV       R0,A
     36            slot++;
   \   000002   08           INC       R0
     37            return (slot >= MAX_TIME_SLOTS) ? 0 : slot;
   \   000003   E8           MOV       A,R0
   \   000004   C3           CLR       C
   \   000005   9432         SUBB      A,#0x32
   \   000007   4004         JC        ??_inc_timeslot_1
   \   000009   7900         MOV       R1,#0x0
   \   00000B   8002         SJMP      ??_inc_timeslot_2
   \                     ??_inc_timeslot_1:
   \   00000D   E8           MOV       A,R0
   \   00000E   F9           MOV       R1,A
   \                     ??_inc_timeslot_2:
   \   00000F   02....       LJMP      ?BRET
     38          }
     39          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     40          static inline timeslot_t _find_next_active(timeslot_t slot){
   \                     ??_find_next_active:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
   \   000003   E9           MOV       A,R1
   \   000004   FE           MOV       R6,A
     41            slot = _inc_timeslot(slot);
   \   000005                ; Setup parameters for call to function _inc_timeslot
   \   000005   EE           MOV       A,R6
   \   000006   F9           MOV       R1,A
   \   000007   12....       LCALL     `??_inc_timeslot::?relay`; Banked call to: _inc_timeslot
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
     42            while (slot && !ALARMS[slot])
   \                     ??_find_next_active_1:
   \   00000C   EE           MOV       A,R6
   \   00000D   601A         JZ        ??_find_next_active_2
   \   00000F   EE           MOV       A,R6
   \   000010   F8           MOV       R0,A
   \   000011   7900         MOV       R1,#0x0
   \   000013   74..         MOV       A,#??ALARMS & 0xff
   \   000015   28           ADD       A,R0
   \   000016   F582         MOV       DPL,A
   \   000018   74..         MOV       A,#(??ALARMS >> 8) & 0xff
   \   00001A   39           ADDC      A,R1
   \   00001B   F583         MOV       DPH,A
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   7009         JNZ       ??_find_next_active_2
     43              slot = _inc_timeslot(slot);
   \   000020                ; Setup parameters for call to function _inc_timeslot
   \   000020   EE           MOV       A,R6
   \   000021   F9           MOV       R1,A
   \   000022   12....       LCALL     `??_inc_timeslot::?relay`; Banked call to: _inc_timeslot
   \   000025   E9           MOV       A,R1
   \   000026   FE           MOV       R6,A
   \   000027   80E3         SJMP      ??_find_next_active_1
     44            return slot;
   \                     ??_find_next_active_2:
   \   000029   EE           MOV       A,R6
   \   00002A   F9           MOV       R1,A
   \   00002B   D0E0         POP       A
   \   00002D   FE           MOV       R6,A
   \   00002E   02....       LJMP      ?BRET
     45          }
     46          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     47          static void scheulder_next_alarm(nwtime_t time){
   \                     ??scheulder_next_alarm:
   \   000000                REQUIRE ?V0
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006   C0..         PUSH      ?V0
   \   000008                ; Saved register size: 3
   \   000008                ; Auto size: 0
   \   000008   EA           MOV       A,R2
   \   000009   FE           MOV       R6,A
   \   00000A   EB           MOV       A,R3
   \   00000B   FF           MOV       R7,A
     48            timeslot_t slot = NWTIME_TO_SLOT(time);
   \   00000C   EE           MOV       A,R6
   \   00000D   F8           MOV       R0,A
   \   00000E   EF           MOV       A,R7
   \   00000F   F9           MOV       R1,A
   \   000010   7A8E         MOV       R2,#-0x72
   \   000012   7B02         MOV       R3,#0x2
   \   000014   12....       LCALL     ?US_DIV_MOD
   \   000017   E8           MOV       A,R0
   \   000018   F5..         MOV       ?V0,A
     49            slot = _find_next_active(slot);
   \   00001A                ; Setup parameters for call to function _find_next_active
   \   00001A   A9..         MOV       R1,?V0
   \   00001C   12....       LCALL     `??_find_next_active::?relay`; Banked call to: _find_next_active
   \   00001F   E9           MOV       A,R1
   \   000020   F5..         MOV       ?V0,A
     50            AT_set_alarm(SLOT_TO_NWTIME(slot));
   \   000022                ; Setup parameters for call to function AT_set_alarm
   \   000022   E5..         MOV       A,?V0
   \   000024   FA           MOV       R2,A
   \   000025   7B00         MOV       R3,#0x0
   \   000027   EA           MOV       A,R2
   \   000028   75F08E       MOV       B,#-0x72
   \   00002B   A4           MUL       AB
   \   00002C   CA           XCH       A,R2
   \   00002D   A8F0         MOV       R0,B
   \   00002F   75F002       MOV       B,#0x2
   \   000032   A4           MUL       AB
   \   000033   28           ADD       A,R0
   \   000034   F8           MOV       R0,A
   \   000035   75F08E       MOV       B,#-0x72
   \   000038   EB           MOV       A,R3
   \   000039   A4           MUL       AB
   \   00003A   28           ADD       A,R0
   \   00003B   FB           MOV       R3,A
   \   00003C   12....       LCALL     `??AT_set_alarm::?relay`; Banked call to: AT_set_alarm
     51          }
   \   00003F   D0..         POP       ?V0
   \   000041   D0E0         POP       A
   \   000043   FF           MOV       R7,A
   \   000044   D0E0         POP       A
   \   000046   FE           MOV       R6,A
   \   000047   02....       LJMP      ?BRET
     52          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     53          void TM_IRQ(nwtime_t time){
   \                     TM_IRQ:
   \   000000                REQUIRE ?V0
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006   C0..         PUSH      ?V0
   \   000008                ; Saved register size: 3
   \   000008                ; Auto size: 0
   \   000008   EA           MOV       A,R2
   \   000009   FE           MOV       R6,A
   \   00000A   EB           MOV       A,R3
   \   00000B   FF           MOV       R7,A
     54            if (MODEL.TM.MODE == 0){
   \   00000C   90....       MOV       DPTR,#MODEL + 12
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   7007         JNZ       ??TM_IRQ_0
     55              AT_enable(false);
   \   000012                ; Setup parameters for call to function AT_enable
   \   000012   C2F0         CLR       B.0
   \   000014   12....       LCALL     `??AT_enable::?relay`; Banked call to: AT_enable
     56              return;
   \   000017   8053         SJMP      ??TM_IRQ_1
     57            }
     58            
     59            ATOMIC_BLOCK_RESTORE{     
   \                     ??TM_IRQ_0:
   \   000019   A2AF         MOV       C,0xa8.7
   \   00001B   E4           CLR       A
   \   00001C   33           RLC       A
   \   00001D   F5..         MOV       ?V0,A
   \   00001F                ; Setup parameters for call to function __cli
   \   00001F   12....       LCALL     `??__cli::?relay_3`; Banked call to: __cli
   \   000022   E9           MOV       A,R1
   \   000023   F8           MOV       R0,A
   \                     ??TM_IRQ_2:
   \   000024   E8           MOV       A,R0
   \   000025   6045         JZ        ??TM_IRQ_1
     60              MODEL.TM.timeslot = NWTIME_TO_SLOT(time);
   \   000027   EE           MOV       A,R6
   \   000028   F8           MOV       R0,A
   \   000029   EF           MOV       A,R7
   \   00002A   F9           MOV       R1,A
   \   00002B   7A8E         MOV       R2,#-0x72
   \   00002D   7B02         MOV       R3,#0x2
   \   00002F   12....       LCALL     ?US_DIV_MOD
   \   000032   E8           MOV       A,R0
   \   000033   90....       MOV       DPTR,#MODEL + 13
   \   000036   F0           MOVX      @DPTR,A
     61              MODEL.TM.time = time;
   \   000037   90....       MOV       DPTR,#MODEL + 15
   \   00003A   EE           MOV       A,R6
   \   00003B   F0           MOVX      @DPTR,A
   \   00003C   A3           INC       DPTR
   \   00003D   EF           MOV       A,R7
   \   00003E   F0           MOVX      @DPTR,A
     62              MODEL.TM.alarm = ALARMS[ MODEL.TM.timeslot];
   \   00003F   90....       MOV       DPTR,#MODEL + 13
   \   000042   E0           MOVX      A,@DPTR
   \   000043   F8           MOV       R0,A
   \   000044   7900         MOV       R1,#0x0
   \   000046   74..         MOV       A,#??ALARMS & 0xff
   \   000048   28           ADD       A,R0
   \   000049   F582         MOV       DPL,A
   \   00004B   74..         MOV       A,#(??ALARMS >> 8) & 0xff
   \   00004D   39           ADDC      A,R1
   \   00004E   F583         MOV       DPH,A
   \   000050   E0           MOVX      A,@DPTR
   \   000051   90....       MOV       DPTR,#MODEL + 14
   \   000054   F0           MOVX      @DPTR,A
     63              scheulder_next_alarm(time);
   \   000055                ; Setup parameters for call to function scheulder_next_alarm
   \   000055   EE           MOV       A,R6
   \   000056   FA           MOV       R2,A
   \   000057   EF           MOV       A,R7
   \   000058   FB           MOV       R3,A
   \   000059   12....       LCALL     `??scheulder_next_alarm::?relay`; Banked call to: scheulder_next_alarm
     64              AM_Hot_start();
   \   00005C                ; Setup parameters for call to function AM_Hot_start
   \   00005C   12....       LCALL     `??AM_Hot_start::?relay`; Banked call to: AM_Hot_start
     65              AM_Cold_start();
   \   00005F                ; Setup parameters for call to function AM_Cold_start
   \   00005F   12....       LCALL     `??AM_Cold_start::?relay`; Banked call to: AM_Cold_start
     66            };
   \   000062   7800         MOV       R0,#0x0
   \   000064   E5..         MOV       A,?V0
   \   000066   A2E0         MOV       C,0xE0 /* A   */.0
   \   000068   92AF         MOV       0xa8.7,C
   \   00006A   80B8         SJMP      ??TM_IRQ_2
     67          }
   \                     ??TM_IRQ_1:
   \   00006C   D0..         POP       ?V0
   \   00006E   D0E0         POP       A
   \   000070   FF           MOV       R7,A
   \   000071   D0E0         POP       A
   \   000073   FE           MOV       R6,A
   \   000074   02....       LJMP      ?BRET
   \   000077                REQUIRE _A_IEN0
     68          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     69          static inline void mcu_sleep(void){
   \                     ??mcu_sleep:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     70            SLEEPCMD = 2; // Режим PM2
   \   000000   75BE02       MOV       0xbe,#0x2
     71            PCON = 1;
   \   000003   758701       MOV       0x87,#0x1
     72          }
   \   000006   02....       LJMP      ?BRET
   \   000009                REQUIRE SLEEPCMD
   \   000009                REQUIRE PCON
     73          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     74          static inline void _clr_all(void){
   \                     ??_clr_all:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     75            for_each_type(char, ALARMS, i)
   \   000000   7582..       MOV       DPL,#??ALARMS & 0xff
   \   000003   7583..       MOV       DPH,#(??ALARMS >> 8) & 0xff
   \                     ??_clr_all_1:
   \   000006   C3           CLR       C
   \   000007   E582         MOV       A,DPL
   \   000009   94..         SUBB      A,#(??ALARMS + 50) & 0xff
   \   00000B   E583         MOV       A,DPH
   \   00000D   94..         SUBB      A,#((??ALARMS + 50) >> 8) & 0xff
   \   00000F   5006         JNC       ??_clr_all_2
     76              *i = 0;
   \   000011   7400         MOV       A,#0x0
   \   000013   F0           MOVX      @DPTR,A
   \   000014   A3           INC       DPTR
   \   000015   80EF         SJMP      ??_clr_all_1
     77          }
   \                     ??_clr_all_2:
   \   000017   02....       LJMP      ?BRET
     78          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     79          static void init(void){
   \                     ??init:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     80            _clr_all();
   \   000000                ; Setup parameters for call to function _clr_all
   \   000000   12....       LCALL     `??_clr_all::?relay`; Banked call to: _clr_all
     81            scheulder_next_alarm(0);
   \   000003                ; Setup parameters for call to function scheulder_next_alarm
   \   000003   7A00         MOV       R2,#0x0
   \   000005   7B00         MOV       R3,#0x0
   \   000007   12....       LCALL     `??scheulder_next_alarm::?relay`; Banked call to: scheulder_next_alarm
     82            AT_enable(true);
   \   00000A                ; Setup parameters for call to function AT_enable
   \   00000A   D2F0         SETB      B.0
   \   00000C   12....       LCALL     `??AT_enable::?relay`; Banked call to: AT_enable
     83          }
   \   00000F   02....       LJMP      ?BRET
     84          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     85          static void start_mode_1(void){
   \                     ??start_mode_1:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     86            AM_IRQ_Init();
   \   000000                ; Setup parameters for call to function AM_IRQ_Init
   \   000000   12....       LCALL     `??AM_IRQ_Init::?relay`; Banked call to: AM_IRQ_Init
     87            init();
   \   000003                ; Setup parameters for call to function init
   \   000003   12....       LCALL     `??init::?relay` ; Banked call to: init
     88            while (true){
     89              mcu_sleep();
   \                     ??start_mode_1_1:
   \   000006                ; Setup parameters for call to function mcu_sleep
   \   000006   12....       LCALL     `??mcu_sleep::?relay`; Banked call to: mcu_sleep
     90              if (MODEL.TM.MODE == 0){
   \   000009   90....       MOV       DPTR,#MODEL + 12
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   7007         JNZ       ??start_mode_1_2
     91                AT_enable(false);
   \   00000F                ; Setup parameters for call to function AT_enable
   \   00000F   C2F0         CLR       B.0
   \   000011   12....       LCALL     `??AT_enable::?relay`; Banked call to: AT_enable
     92                break;
     93              }
     94              
     95              AM_Callback();    
     96            }  
     97          }
   \   000014   8005         SJMP      ??start_mode_1_3
   \                     ??start_mode_1_2:
   \   000016                ; Setup parameters for call to function AM_Callback
   \   000016   12....       LCALL     `??AM_Callback::?relay`; Banked call to: AM_Callback
   \   000019   80EB         SJMP      ??start_mode_1_1
   \                     ??start_mode_1_3:
   \   00001B   02....       LJMP      ?BRET
     98          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     99          static void start_mode_2(void){
   \                     ??start_mode_2:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    100            AM_IRQ_Init();
   \   000000                ; Setup parameters for call to function AM_IRQ_Init
   \   000000   12....       LCALL     `??AM_IRQ_Init::?relay`; Banked call to: AM_IRQ_Init
    101            init();
   \   000003                ; Setup parameters for call to function init
   \   000003   12....       LCALL     `??init::?relay` ; Banked call to: init
    102          }
   \   000006   02....       LJMP      ?BRET
    103          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    104          void Neocore_start(void){
   \                     Neocore_start:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    105            switch (MODEL.TM.MODE){
   \   000000   90....       MOV       DPTR,#MODEL + 12
   \   000003   E0           MOVX      A,@DPTR
   \   000004   6040         JZ        ??Neocore_start_0
   \   000006   14           DEC       A
   \   000007   6005         JZ        ??Neocore_start_1
   \   000009   14           DEC       A
   \   00000A   6007         JZ        ??Neocore_start_2
   \   00000C   800A         SJMP      ??Neocore_start_3
    106            case 0:
    107              return;
    108            case 1:
    109              start_mode_1();
   \                     ??Neocore_start_1:
   \   00000E                ; Setup parameters for call to function start_mode_1
   \   00000E   12....       LCALL     `??start_mode_1::?relay`; Banked call to: start_mode_1
    110              break;
   \   000011   8033         SJMP      ??Neocore_start_0
    111            case 2:
    112              start_mode_2();
   \                     ??Neocore_start_2:
   \   000013                ; Setup parameters for call to function start_mode_2
   \   000013   12....       LCALL     `??start_mode_2::?relay`; Banked call to: start_mode_2
    113              break;
   \   000016   802E         SJMP      ??Neocore_start_0
    114            default: 
    115              HALT("Incorrect MODEL.TM.MODE");
   \                     ??Neocore_start_3:
   \   000018                ; Setup parameters for call to function printf
   \   000018   74..         MOV       A,#??__FUNCTION___12 & 0xff
   \   00001A   C0E0         PUSH      A
   \   00001C   74..         MOV       A,#(??__FUNCTION___12 >> 8) & 0xff
   \   00001E   C0E0         PUSH      A
   \   000020   7473         MOV       A,#0x73
   \   000022   C0E0         PUSH      A
   \   000024   7400         MOV       A,#0x0
   \   000026   C0E0         PUSH      A
   \   000028   74..         MOV       A,#`?<Constant "time_manager.c">` & 0xff
   \   00002A   C0E0         PUSH      A
   \   00002C   74..         MOV       A,#(`?<Constant "time_manager.c">` >> 8) & 0xff
   \   00002E   C0E0         PUSH      A
   \   000030   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_3` & 0xff
   \   000032   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_3` >> 8) & 0xff
   \   000034   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000037   74FA         MOV       A,#-0x6
   \   000039   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00003C                ; Setup parameters for call to function printf
   \   00003C   7A..         MOV       R2,#`?<Constant "Incorrect MODEL.TM.MODE">` & 0xff
   \   00003E   7B..         MOV       R3,#(`?<Constant "Incorrect MODEL.TM.MODE">` >> 8) & 0xff
   \   000040   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000043                ; Setup parameters for call to function DBG_CORE_HALT
   \   000043   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
    116            }
    117          }
   \                     ??Neocore_start_0:
   \   000046   02....       LJMP      ?BRET
E:\Neocore\Hardware\PRJ Test\u_alarm_timer.c
      1          #include "debug.h"
      2          #include "alarm_timer.h"
      3          #include "cpu.h"
      4          
      5          // тестирование вставками. Теперь переопределить функции нельзя
      6          // void TM_IRQ(nwtime_t time) теперь вручную мониторить

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
      7          void u_alarm_timer(void){
   \                     u_alarm_timer:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
      8            nwtime_t alarm = 500;
   \   000006   7EF4         MOV       R6,#-0xc
   \   000008   7F01         MOV       R7,#0x1
      9            INTERRUPT_ENABLE();
   \   00000A   D2AF         SETB      0xa8.7
     10            AT_set_alarm(alarm);
   \   00000C                ; Setup parameters for call to function AT_set_alarm
   \   00000C   EE           MOV       A,R6
   \   00000D   FA           MOV       R2,A
   \   00000E   EF           MOV       A,R7
   \   00000F   FB           MOV       R3,A
   \   000010   12....       LCALL     `??AT_set_alarm::?relay`; Banked call to: AT_set_alarm
     11            while(1);
   \                     ??u_alarm_timer_0:
   \   000013   80FE         SJMP      ??u_alarm_timer_0
   \   000015                REQUIRE _A_IEN0
     12          }
E:\Neocore\Hardware\PRJ Test\u_buffer.c
      1          #include "utest.h"
      2          #include "stddef.h"
      3          
      4          static int test1(void);
      5          static int test2(void);
      6          static int test3(void);

   \                                 In  segment XDATA_I, align 1, keep-with-next
      7          struct test_unit UT_BF_1 = {.name = "BF:push tx", .fun = test1};
   \                     UT_BF_1:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_BF_1>`
   \   000022                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
      8          struct test_unit UT_BF_2 = {.name = "BF:push-pop tx all", .fun = test2};
   \                     UT_BF_2:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_BF_2>`
   \   000022                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
      9          struct test_unit UT_BF_3 = {.name = "BF:mix rx-tx bufs", .fun = test3};
   \                     UT_BF_3:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_BF_3>`
   \   000022                REQUIRE __INIT_XDATA_I
     10          
     11          #include "buffer.h"
     12          #include "frame.h"
     13          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     14          static int test3(void){
   \                     ??test3:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 42
   \   000005   742A         MOV       A,#0x2a
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
     15            int test_res = 0;
   \   00000A   7E00         MOV       R6,#0x0
   \   00000C   7F00         MOV       R7,#0x0
     16            struct frame* fr_rx[10];
     17            struct frame* fr_tx[10];
     18            struct frame* content;
     19            
     20            
     21            if (BF_rx_busy() != 0)
   \   00000E                ; Setup parameters for call to function BF_rx_busy
   \   00000E   12....       LCALL     `??BF_rx_busy::?relay`; Banked call to: BF_rx_busy
   \   000011   8A..         MOV       ?V0,R2
   \   000013   8B..         MOV       ?V1,R3
   \   000015   E5..         MOV       A,?V0
   \   000017   45..         ORL       A,?V1
   \   000019   6004         JZ        ??test3_3
     22              test_res = 31;
   \   00001B   7E1F         MOV       R6,#0x1f
   \   00001D   7F00         MOV       R7,#0x0
     23          
     24            if (BF_tx_busy() != 0)
   \                     ??test3_3:
   \   00001F                ; Setup parameters for call to function BF_tx_busy
   \   00001F   12....       LCALL     `??BF_tx_busy::?relay`; Banked call to: BF_tx_busy
   \   000022   8A..         MOV       ?V0,R2
   \   000024   8B..         MOV       ?V1,R3
   \   000026   E5..         MOV       A,?V0
   \   000028   45..         ORL       A,?V1
   \   00002A   6004         JZ        ??test3_4
     25              test_res = 32;
   \   00002C   7E20         MOV       R6,#0x20
   \   00002E   7F00         MOV       R7,#0x0
     26          
     27            if (BF_available()!=20)
   \                     ??test3_4:
   \   000030                ; Setup parameters for call to function BF_available
   \   000030   12....       LCALL     `??BF_available::?relay`; Banked call to: BF_available
   \   000033   8A..         MOV       ?V0,R2
   \   000035   8B..         MOV       ?V1,R3
   \   000037   7414         MOV       A,#0x14
   \   000039   65..         XRL       A,?V0
   \   00003B   7004         JNZ       ??test3_5
   \   00003D   7400         MOV       A,#0x0
   \   00003F   65..         XRL       A,?V1
   \                     ??test3_5:
   \   000041   6004         JZ        ??test3_6
     28              test_res = 33;
   \   000043   7E21         MOV       R6,#0x21
   \   000045   7F00         MOV       R7,#0x0
     29            
     30            for (int i = 0; i < 10; i++){
   \                     ??test3_6:
   \   000047   75..00       MOV       ?V0,#0x0
   \   00004A   75..00       MOV       ?V1,#0x0
   \                     ??test3_7:
   \   00004D   C3           CLR       C
   \   00004E   E5..         MOV       A,?V0
   \   000050   940A         SUBB      A,#0xa
   \   000052   E5..         MOV       A,?V1
   \   000054   9400         SUBB      A,#0x0
   \   000056   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000058   65D0         XRL       A,PSW
   \   00005A   33           RLC       A
   \   00005B   4003         JC        $+5
   \   00005D   02....       LJMP      ??test3_8 & 0xFFFF
     31              fr_rx[i] = FR_create();
   \   000060                ; Setup parameters for call to function FR_create
   \   000060   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   000063   A8..         MOV       R0,?V0
   \   000065   A9..         MOV       R1,?V1
   \   000067   E8           MOV       A,R0
   \   000068   75F002       MOV       B,#0x2
   \   00006B   A4           MUL       AB
   \   00006C   C8           XCH       A,R0
   \   00006D   ACF0         MOV       R4,B
   \   00006F   75F000       MOV       B,#0x0
   \   000072   A4           MUL       AB
   \   000073   2C           ADD       A,R4
   \   000074   FC           MOV       R4,A
   \   000075   75F002       MOV       B,#0x2
   \   000078   E9           MOV       A,R1
   \   000079   A4           MUL       AB
   \   00007A   2C           ADD       A,R4
   \   00007B   F9           MOV       R1,A
   \   00007C   90FFD5       MOV       DPTR,#-0x2b
   \   00007F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000082   E582         MOV       A,DPL
   \   000084   28           ADD       A,R0
   \   000085   F582         MOV       DPL,A
   \   000087   E583         MOV       A,DPH
   \   000089   39           ADDC      A,R1
   \   00008A   F583         MOV       DPH,A
   \   00008C   EA           MOV       A,R2
   \   00008D   F0           MOVX      @DPTR,A
   \   00008E   A3           INC       DPTR
   \   00008F   EB           MOV       A,R3
   \   000090   F0           MOVX      @DPTR,A
     32              fr_tx[i] = FR_create();
   \   000091                ; Setup parameters for call to function FR_create
   \   000091   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   000094   A8..         MOV       R0,?V0
   \   000096   A9..         MOV       R1,?V1
   \   000098   E8           MOV       A,R0
   \   000099   75F002       MOV       B,#0x2
   \   00009C   A4           MUL       AB
   \   00009D   C8           XCH       A,R0
   \   00009E   ACF0         MOV       R4,B
   \   0000A0   75F000       MOV       B,#0x0
   \   0000A3   A4           MUL       AB
   \   0000A4   2C           ADD       A,R4
   \   0000A5   FC           MOV       R4,A
   \   0000A6   75F002       MOV       B,#0x2
   \   0000A9   E9           MOV       A,R1
   \   0000AA   A4           MUL       AB
   \   0000AB   2C           ADD       A,R4
   \   0000AC   F9           MOV       R1,A
   \   0000AD   90FFE9       MOV       DPTR,#-0x17
   \   0000B0   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000B3   E582         MOV       A,DPL
   \   0000B5   28           ADD       A,R0
   \   0000B6   F582         MOV       DPL,A
   \   0000B8   E583         MOV       A,DPH
   \   0000BA   39           ADDC      A,R1
   \   0000BB   F583         MOV       DPH,A
   \   0000BD   EA           MOV       A,R2
   \   0000BE   F0           MOVX      @DPTR,A
   \   0000BF   A3           INC       DPTR
   \   0000C0   EB           MOV       A,R3
   \   0000C1   F0           MOVX      @DPTR,A
     33              if (!BF_push_tx(fr_tx[i]))
   \   0000C2                ; Setup parameters for call to function BF_push_tx
   \   0000C2   A8..         MOV       R0,?V0
   \   0000C4   A9..         MOV       R1,?V1
   \   0000C6   E8           MOV       A,R0
   \   0000C7   75F002       MOV       B,#0x2
   \   0000CA   A4           MUL       AB
   \   0000CB   C8           XCH       A,R0
   \   0000CC   AAF0         MOV       R2,B
   \   0000CE   75F000       MOV       B,#0x0
   \   0000D1   A4           MUL       AB
   \   0000D2   2A           ADD       A,R2
   \   0000D3   FA           MOV       R2,A
   \   0000D4   75F002       MOV       B,#0x2
   \   0000D7   E9           MOV       A,R1
   \   0000D8   A4           MUL       AB
   \   0000D9   2A           ADD       A,R2
   \   0000DA   F9           MOV       R1,A
   \   0000DB   90FFE9       MOV       DPTR,#-0x17
   \   0000DE   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000E1   E582         MOV       A,DPL
   \   0000E3   28           ADD       A,R0
   \   0000E4   F582         MOV       DPL,A
   \   0000E6   E583         MOV       A,DPH
   \   0000E8   39           ADDC      A,R1
   \   0000E9   F583         MOV       DPH,A
   \   0000EB   E0           MOVX      A,@DPTR
   \   0000EC   FA           MOV       R2,A
   \   0000ED   A3           INC       DPTR
   \   0000EE   E0           MOVX      A,@DPTR
   \   0000EF   FB           MOV       R3,A
   \   0000F0   12....       LCALL     `??BF_push_tx::?relay`; Banked call to: BF_push_tx
   \   0000F3   4004         JC        ??test3_9
     34                test_res = 1;
   \   0000F5   7E01         MOV       R6,#0x1
   \   0000F7   7F00         MOV       R7,#0x0
     35              if (!BF_push_rx(fr_rx[i]))
   \                     ??test3_9:
   \   0000F9                ; Setup parameters for call to function BF_push_rx
   \   0000F9   A8..         MOV       R0,?V0
   \   0000FB   A9..         MOV       R1,?V1
   \   0000FD   E8           MOV       A,R0
   \   0000FE   75F002       MOV       B,#0x2
   \   000101   A4           MUL       AB
   \   000102   C8           XCH       A,R0
   \   000103   AAF0         MOV       R2,B
   \   000105   75F000       MOV       B,#0x0
   \   000108   A4           MUL       AB
   \   000109   2A           ADD       A,R2
   \   00010A   FA           MOV       R2,A
   \   00010B   75F002       MOV       B,#0x2
   \   00010E   E9           MOV       A,R1
   \   00010F   A4           MUL       AB
   \   000110   2A           ADD       A,R2
   \   000111   F9           MOV       R1,A
   \   000112   90FFD5       MOV       DPTR,#-0x2b
   \   000115   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000118   E582         MOV       A,DPL
   \   00011A   28           ADD       A,R0
   \   00011B   F582         MOV       DPL,A
   \   00011D   E583         MOV       A,DPH
   \   00011F   39           ADDC      A,R1
   \   000120   F583         MOV       DPH,A
   \   000122   E0           MOVX      A,@DPTR
   \   000123   FA           MOV       R2,A
   \   000124   A3           INC       DPTR
   \   000125   E0           MOVX      A,@DPTR
   \   000126   FB           MOV       R3,A
   \   000127   12....       LCALL     `??BF_push_rx::?relay`; Banked call to: BF_push_rx
   \   00012A   4004         JC        ??test3_10
     36                test_res = 2;    
   \   00012C   7E02         MOV       R6,#0x2
   \   00012E   7F00         MOV       R7,#0x0
     37            } 
   \                     ??test3_10:
   \   000130   05..         INC       ?V0
   \   000132   E5..         MOV       A,?V0
   \   000134   7002         JNZ       ??test3_11
   \   000136   05..         INC       ?V1
   \                     ??test3_11:
   \   000138   02....       LJMP      ??test3_7 & 0xFFFF
     38           
     39            if (BF_rx_busy() != 10)
   \                     ??test3_8:
   \   00013B                ; Setup parameters for call to function BF_rx_busy
   \   00013B   12....       LCALL     `??BF_rx_busy::?relay`; Banked call to: BF_rx_busy
   \   00013E   8A..         MOV       ?V0,R2
   \   000140   8B..         MOV       ?V1,R3
   \   000142   740A         MOV       A,#0xa
   \   000144   65..         XRL       A,?V0
   \   000146   7004         JNZ       ??test3_12
   \   000148   7400         MOV       A,#0x0
   \   00014A   65..         XRL       A,?V1
   \                     ??test3_12:
   \   00014C   6004         JZ        ??test3_13
     40              test_res = 21;
   \   00014E   7E15         MOV       R6,#0x15
   \   000150   7F00         MOV       R7,#0x0
     41          
     42            if (BF_tx_busy() != 10)
   \                     ??test3_13:
   \   000152                ; Setup parameters for call to function BF_tx_busy
   \   000152   12....       LCALL     `??BF_tx_busy::?relay`; Banked call to: BF_tx_busy
   \   000155   8A..         MOV       ?V0,R2
   \   000157   8B..         MOV       ?V1,R3
   \   000159   740A         MOV       A,#0xa
   \   00015B   65..         XRL       A,?V0
   \   00015D   7004         JNZ       ??test3_14
   \   00015F   7400         MOV       A,#0x0
   \   000161   65..         XRL       A,?V1
   \                     ??test3_14:
   \   000163   6004         JZ        ??test3_15
     43              test_res = 22;
   \   000165   7E16         MOV       R6,#0x16
   \   000167   7F00         MOV       R7,#0x0
     44          
     45            if (BF_available()!=0)
   \                     ??test3_15:
   \   000169                ; Setup parameters for call to function BF_available
   \   000169   12....       LCALL     `??BF_available::?relay`; Banked call to: BF_available
   \   00016C   8A..         MOV       ?V0,R2
   \   00016E   8B..         MOV       ?V1,R3
   \   000170   E5..         MOV       A,?V0
   \   000172   45..         ORL       A,?V1
   \   000174   6004         JZ        ??test3_16
     46              test_res = 23;
   \   000176   7E17         MOV       R6,#0x17
   \   000178   7F00         MOV       R7,#0x0
     47            
     48            void *cursor = BF_cursor_tx();
   \                     ??test3_16:
   \   00017A                ; Setup parameters for call to function BF_cursor_tx
   \   00017A   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   00017D   8A..         MOV       ?V2,R2
   \   00017F   8B..         MOV       ?V3,R3
   \   000181   85....       MOV       ?V0,?V2
   \   000184   85....       MOV       ?V1,?V3
     49            for (int i = 0; i < 10; i++){
   \   000187   75..00       MOV       ?V2,#0x0
   \   00018A   75..00       MOV       ?V3,#0x0
   \                     ??test3_17:
   \   00018D   C3           CLR       C
   \   00018E   E5..         MOV       A,?V2
   \   000190   940A         SUBB      A,#0xa
   \   000192   E5..         MOV       A,?V3
   \   000194   9400         SUBB      A,#0x0
   \   000196   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000198   65D0         XRL       A,PSW
   \   00019A   33           RLC       A
   \   00019B   507B         JNC       ??test3_18
     50                content = BF_content(cursor);
   \   00019D                ; Setup parameters for call to function BF_content
   \   00019D   AA..         MOV       R2,?V0
   \   00019F   AB..         MOV       R3,?V1
   \   0001A1   12....       LCALL     `??BF_content::?relay`; Banked call to: BF_content
   \   0001A4   90FFFD       MOV       DPTR,#-0x3
   \   0001A7   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001AA   EA           MOV       A,R2
   \   0001AB   F0           MOVX      @DPTR,A
   \   0001AC   A3           INC       DPTR
   \   0001AD   EB           MOV       A,R3
   \   0001AE   F0           MOVX      @DPTR,A
     51                if (content != fr_tx[9-i])
   \   0001AF   90FFFD       MOV       DPTR,#-0x3
   \   0001B2   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001B5   E0           MOVX      A,@DPTR
   \   0001B6   FA           MOV       R2,A
   \   0001B7   A3           INC       DPTR
   \   0001B8   E0           MOVX      A,@DPTR
   \   0001B9   FB           MOV       R3,A
   \   0001BA   C3           CLR       C
   \   0001BB   E4           CLR       A
   \   0001BC   95..         SUBB      A,?V2
   \   0001BE   F8           MOV       R0,A
   \   0001BF   E4           CLR       A
   \   0001C0   95..         SUBB      A,?V3
   \   0001C2   F9           MOV       R1,A
   \   0001C3   E8           MOV       A,R0
   \   0001C4   75F002       MOV       B,#0x2
   \   0001C7   A4           MUL       AB
   \   0001C8   C8           XCH       A,R0
   \   0001C9   ACF0         MOV       R4,B
   \   0001CB   75F000       MOV       B,#0x0
   \   0001CE   A4           MUL       AB
   \   0001CF   2C           ADD       A,R4
   \   0001D0   FC           MOV       R4,A
   \   0001D1   75F002       MOV       B,#0x2
   \   0001D4   E9           MOV       A,R1
   \   0001D5   A4           MUL       AB
   \   0001D6   2C           ADD       A,R4
   \   0001D7   F9           MOV       R1,A
   \   0001D8   90FFE9       MOV       DPTR,#-0x17
   \   0001DB   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001DE   E582         MOV       A,DPL
   \   0001E0   28           ADD       A,R0
   \   0001E1   F8           MOV       R0,A
   \   0001E2   E583         MOV       A,DPH
   \   0001E4   39           ADDC      A,R1
   \   0001E5   F9           MOV       R1,A
   \   0001E6   E8           MOV       A,R0
   \   0001E7   2412         ADD       A,#0x12
   \   0001E9   F582         MOV       DPL,A
   \   0001EB   E4           CLR       A
   \   0001EC   39           ADDC      A,R1
   \   0001ED   F583         MOV       DPH,A
   \   0001EF   E0           MOVX      A,@DPTR
   \   0001F0   6A           XRL       A,R2
   \   0001F1   7003         JNZ       ??test3_19
   \   0001F3   A3           INC       DPTR
   \   0001F4   E0           MOVX      A,@DPTR
   \   0001F5   6B           XRL       A,R3
   \                     ??test3_19:
   \   0001F6   6004         JZ        ??test3_20
     52                  test_res = 3;
   \   0001F8   7E03         MOV       R6,#0x3
   \   0001FA   7F00         MOV       R7,#0x0
     53                cursor = BF_cursor_next(cursor);
   \                     ??test3_20:
   \   0001FC                ; Setup parameters for call to function BF_cursor_next
   \   0001FC   AA..         MOV       R2,?V0
   \   0001FE   AB..         MOV       R3,?V1
   \   000200   12....       LCALL     `??BF_cursor_next::?relay`; Banked call to: BF_cursor_next
   \   000203   8A..         MOV       ?V4,R2
   \   000205   8B..         MOV       ?V5,R3
   \   000207   85....       MOV       ?V0,?V4
   \   00020A   85....       MOV       ?V1,?V5
     54            }  
   \   00020D   05..         INC       ?V2
   \   00020F   E5..         MOV       A,?V2
   \   000211   7002         JNZ       ??test3_21
   \   000213   05..         INC       ?V3
   \                     ??test3_21:
   \   000215   02....       LJMP      ??test3_17 & 0xFFFF
     55          
     56            cursor = BF_cursor_rx();
   \                     ??test3_18:
   \   000218                ; Setup parameters for call to function BF_cursor_rx
   \   000218   12....       LCALL     `??BF_cursor_rx::?relay`; Banked call to: BF_cursor_rx
   \   00021B   8A..         MOV       ?V2,R2
   \   00021D   8B..         MOV       ?V3,R3
   \   00021F   85....       MOV       ?V0,?V2
   \   000222   85....       MOV       ?V1,?V3
     57            for (int i = 0; i < 10; i++){
   \   000225   75..00       MOV       ?V2,#0x0
   \   000228   75..00       MOV       ?V3,#0x0
   \                     ??test3_22:
   \   00022B   C3           CLR       C
   \   00022C   E5..         MOV       A,?V2
   \   00022E   940A         SUBB      A,#0xa
   \   000230   E5..         MOV       A,?V3
   \   000232   9400         SUBB      A,#0x0
   \   000234   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000236   65D0         XRL       A,PSW
   \   000238   33           RLC       A
   \   000239   507B         JNC       ??test3_23
     58                content = BF_content(cursor);
   \   00023B                ; Setup parameters for call to function BF_content
   \   00023B   AA..         MOV       R2,?V0
   \   00023D   AB..         MOV       R3,?V1
   \   00023F   12....       LCALL     `??BF_content::?relay`; Banked call to: BF_content
   \   000242   90FFFD       MOV       DPTR,#-0x3
   \   000245   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000248   EA           MOV       A,R2
   \   000249   F0           MOVX      @DPTR,A
   \   00024A   A3           INC       DPTR
   \   00024B   EB           MOV       A,R3
   \   00024C   F0           MOVX      @DPTR,A
     59                if (content != fr_rx[9-i])
   \   00024D   90FFFD       MOV       DPTR,#-0x3
   \   000250   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000253   E0           MOVX      A,@DPTR
   \   000254   FA           MOV       R2,A
   \   000255   A3           INC       DPTR
   \   000256   E0           MOVX      A,@DPTR
   \   000257   FB           MOV       R3,A
   \   000258   C3           CLR       C
   \   000259   E4           CLR       A
   \   00025A   95..         SUBB      A,?V2
   \   00025C   F8           MOV       R0,A
   \   00025D   E4           CLR       A
   \   00025E   95..         SUBB      A,?V3
   \   000260   F9           MOV       R1,A
   \   000261   E8           MOV       A,R0
   \   000262   75F002       MOV       B,#0x2
   \   000265   A4           MUL       AB
   \   000266   C8           XCH       A,R0
   \   000267   ACF0         MOV       R4,B
   \   000269   75F000       MOV       B,#0x0
   \   00026C   A4           MUL       AB
   \   00026D   2C           ADD       A,R4
   \   00026E   FC           MOV       R4,A
   \   00026F   75F002       MOV       B,#0x2
   \   000272   E9           MOV       A,R1
   \   000273   A4           MUL       AB
   \   000274   2C           ADD       A,R4
   \   000275   F9           MOV       R1,A
   \   000276   90FFD5       MOV       DPTR,#-0x2b
   \   000279   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00027C   E582         MOV       A,DPL
   \   00027E   28           ADD       A,R0
   \   00027F   F8           MOV       R0,A
   \   000280   E583         MOV       A,DPH
   \   000282   39           ADDC      A,R1
   \   000283   F9           MOV       R1,A
   \   000284   E8           MOV       A,R0
   \   000285   2412         ADD       A,#0x12
   \   000287   F582         MOV       DPL,A
   \   000289   E4           CLR       A
   \   00028A   39           ADDC      A,R1
   \   00028B   F583         MOV       DPH,A
   \   00028D   E0           MOVX      A,@DPTR
   \   00028E   6A           XRL       A,R2
   \   00028F   7003         JNZ       ??test3_24
   \   000291   A3           INC       DPTR
   \   000292   E0           MOVX      A,@DPTR
   \   000293   6B           XRL       A,R3
   \                     ??test3_24:
   \   000294   6004         JZ        ??test3_25
     60                  test_res = 4;
   \   000296   7E04         MOV       R6,#0x4
   \   000298   7F00         MOV       R7,#0x0
     61                cursor = BF_cursor_next(cursor);
   \                     ??test3_25:
   \   00029A                ; Setup parameters for call to function BF_cursor_next
   \   00029A   AA..         MOV       R2,?V0
   \   00029C   AB..         MOV       R3,?V1
   \   00029E   12....       LCALL     `??BF_cursor_next::?relay`; Banked call to: BF_cursor_next
   \   0002A1   8A..         MOV       ?V4,R2
   \   0002A3   8B..         MOV       ?V5,R3
   \   0002A5   85....       MOV       ?V0,?V4
   \   0002A8   85....       MOV       ?V1,?V5
     62            }    
   \   0002AB   05..         INC       ?V2
   \   0002AD   E5..         MOV       A,?V2
   \   0002AF   7002         JNZ       ??test3_26
   \   0002B1   05..         INC       ?V3
   \                     ??test3_26:
   \   0002B3   02....       LJMP      ??test3_22 & 0xFFFF
     63            
     64            void *del_cursor;
     65            cursor = BF_cursor_tx();
   \                     ??test3_23:
   \   0002B6                ; Setup parameters for call to function BF_cursor_tx
   \   0002B6   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   0002B9   8A..         MOV       ?V2,R2
   \   0002BB   8B..         MOV       ?V3,R3
   \   0002BD   85....       MOV       ?V0,?V2
   \   0002C0   85....       MOV       ?V1,?V3
     66            for (int i = 0; i < 10; i++){
   \   0002C3   75..00       MOV       ?V2,#0x0
   \   0002C6   75..00       MOV       ?V3,#0x0
   \                     ??test3_27:
   \   0002C9   C3           CLR       C
   \   0002CA   E5..         MOV       A,?V2
   \   0002CC   940A         SUBB      A,#0xa
   \   0002CE   E5..         MOV       A,?V3
   \   0002D0   9400         SUBB      A,#0x0
   \   0002D2   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0002D4   65D0         XRL       A,PSW
   \   0002D6   33           RLC       A
   \   0002D7   5065         JNC       ??test3_28
     67                if (!FR_delete(fr_tx[i]))
   \   0002D9                ; Setup parameters for call to function FR_delete
   \   0002D9   A8..         MOV       R0,?V2
   \   0002DB   A9..         MOV       R1,?V3
   \   0002DD   E8           MOV       A,R0
   \   0002DE   75F002       MOV       B,#0x2
   \   0002E1   A4           MUL       AB
   \   0002E2   C8           XCH       A,R0
   \   0002E3   AAF0         MOV       R2,B
   \   0002E5   75F000       MOV       B,#0x0
   \   0002E8   A4           MUL       AB
   \   0002E9   2A           ADD       A,R2
   \   0002EA   FA           MOV       R2,A
   \   0002EB   75F002       MOV       B,#0x2
   \   0002EE   E9           MOV       A,R1
   \   0002EF   A4           MUL       AB
   \   0002F0   2A           ADD       A,R2
   \   0002F1   F9           MOV       R1,A
   \   0002F2   90FFE9       MOV       DPTR,#-0x17
   \   0002F5   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0002F8   E582         MOV       A,DPL
   \   0002FA   28           ADD       A,R0
   \   0002FB   F582         MOV       DPL,A
   \   0002FD   E583         MOV       A,DPH
   \   0002FF   39           ADDC      A,R1
   \   000300   F583         MOV       DPH,A
   \   000302   E0           MOVX      A,@DPTR
   \   000303   FA           MOV       R2,A
   \   000304   A3           INC       DPTR
   \   000305   E0           MOVX      A,@DPTR
   \   000306   FB           MOV       R3,A
   \   000307   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
   \   00030A   4004         JC        ??test3_29
     68                  test_res = 5;
   \   00030C   7E05         MOV       R6,#0x5
   \   00030E   7F00         MOV       R7,#0x0
     69                del_cursor = cursor;
   \                     ??test3_29:
   \   000310   85....       MOV       ?V6,?V0
   \   000313   85....       MOV       ?V7,?V1
     70                cursor = BF_cursor_next(cursor);
   \   000316                ; Setup parameters for call to function BF_cursor_next
   \   000316   AA..         MOV       R2,?V0
   \   000318   AB..         MOV       R3,?V1
   \   00031A   12....       LCALL     `??BF_cursor_next::?relay`; Banked call to: BF_cursor_next
   \   00031D   8A..         MOV       ?V4,R2
   \   00031F   8B..         MOV       ?V5,R3
   \   000321   85....       MOV       ?V0,?V4
   \   000324   85....       MOV       ?V1,?V5
     71                if (!BF_remove_tx(del_cursor))
   \   000327                ; Setup parameters for call to function BF_remove_tx
   \   000327   AA..         MOV       R2,?V6
   \   000329   AB..         MOV       R3,?V7
   \   00032B   12....       LCALL     `??BF_remove_tx::?relay`; Banked call to: BF_remove_tx
   \   00032E   4004         JC        ??test3_30
     72                  test_res = 6;
   \   000330   7E06         MOV       R6,#0x6
   \   000332   7F00         MOV       R7,#0x0
     73            }  
   \                     ??test3_30:
   \   000334   05..         INC       ?V2
   \   000336   E5..         MOV       A,?V2
   \   000338   708F         JNZ       ??test3_27
   \   00033A   05..         INC       ?V3
   \   00033C   808B         SJMP      ??test3_27
     74          
     75          
     76            cursor = BF_cursor_rx();
   \                     ??test3_28:
   \   00033E                ; Setup parameters for call to function BF_cursor_rx
   \   00033E   12....       LCALL     `??BF_cursor_rx::?relay`; Banked call to: BF_cursor_rx
   \   000341   8A..         MOV       ?V2,R2
   \   000343   8B..         MOV       ?V3,R3
   \   000345   85....       MOV       ?V0,?V2
   \   000348   85....       MOV       ?V1,?V3
     77            for (int i = 0; i < 10; i++){
   \   00034B   75..00       MOV       ?V2,#0x0
   \   00034E   75..00       MOV       ?V3,#0x0
   \                     ??test3_31:
   \   000351   C3           CLR       C
   \   000352   E5..         MOV       A,?V2
   \   000354   940A         SUBB      A,#0xa
   \   000356   E5..         MOV       A,?V3
   \   000358   9400         SUBB      A,#0x0
   \   00035A   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00035C   65D0         XRL       A,PSW
   \   00035E   33           RLC       A
   \   00035F   5065         JNC       ??test3_32
     78                if (!FR_delete(fr_rx[i]))
   \   000361                ; Setup parameters for call to function FR_delete
   \   000361   A8..         MOV       R0,?V2
   \   000363   A9..         MOV       R1,?V3
   \   000365   E8           MOV       A,R0
   \   000366   75F002       MOV       B,#0x2
   \   000369   A4           MUL       AB
   \   00036A   C8           XCH       A,R0
   \   00036B   AAF0         MOV       R2,B
   \   00036D   75F000       MOV       B,#0x0
   \   000370   A4           MUL       AB
   \   000371   2A           ADD       A,R2
   \   000372   FA           MOV       R2,A
   \   000373   75F002       MOV       B,#0x2
   \   000376   E9           MOV       A,R1
   \   000377   A4           MUL       AB
   \   000378   2A           ADD       A,R2
   \   000379   F9           MOV       R1,A
   \   00037A   90FFD5       MOV       DPTR,#-0x2b
   \   00037D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000380   E582         MOV       A,DPL
   \   000382   28           ADD       A,R0
   \   000383   F582         MOV       DPL,A
   \   000385   E583         MOV       A,DPH
   \   000387   39           ADDC      A,R1
   \   000388   F583         MOV       DPH,A
   \   00038A   E0           MOVX      A,@DPTR
   \   00038B   FA           MOV       R2,A
   \   00038C   A3           INC       DPTR
   \   00038D   E0           MOVX      A,@DPTR
   \   00038E   FB           MOV       R3,A
   \   00038F   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
   \   000392   4004         JC        ??test3_33
     79                  test_res = 7;
   \   000394   7E07         MOV       R6,#0x7
   \   000396   7F00         MOV       R7,#0x0
     80                del_cursor = cursor;
   \                     ??test3_33:
   \   000398   85....       MOV       ?V6,?V0
   \   00039B   85....       MOV       ?V7,?V1
     81                cursor = BF_cursor_next(cursor);
   \   00039E                ; Setup parameters for call to function BF_cursor_next
   \   00039E   AA..         MOV       R2,?V0
   \   0003A0   AB..         MOV       R3,?V1
   \   0003A2   12....       LCALL     `??BF_cursor_next::?relay`; Banked call to: BF_cursor_next
   \   0003A5   8A..         MOV       ?V4,R2
   \   0003A7   8B..         MOV       ?V5,R3
   \   0003A9   85....       MOV       ?V0,?V4
   \   0003AC   85....       MOV       ?V1,?V5
     82                if (!BF_remove_tx(del_cursor))
   \   0003AF                ; Setup parameters for call to function BF_remove_tx
   \   0003AF   AA..         MOV       R2,?V6
   \   0003B1   AB..         MOV       R3,?V7
   \   0003B3   12....       LCALL     `??BF_remove_tx::?relay`; Banked call to: BF_remove_tx
   \   0003B6   4004         JC        ??test3_34
     83                  test_res = 8;
   \   0003B8   7E08         MOV       R6,#0x8
   \   0003BA   7F00         MOV       R7,#0x0
     84            }
   \                     ??test3_34:
   \   0003BC   05..         INC       ?V2
   \   0003BE   E5..         MOV       A,?V2
   \   0003C0   708F         JNZ       ??test3_31
   \   0003C2   05..         INC       ?V3
   \   0003C4   808B         SJMP      ??test3_31
     85            
     86            cursor = BF_cursor_tx();
   \                     ??test3_32:
   \   0003C6                ; Setup parameters for call to function BF_cursor_tx
   \   0003C6   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   0003C9   8A..         MOV       ?V2,R2
   \   0003CB   8B..         MOV       ?V3,R3
   \   0003CD   85....       MOV       ?V0,?V2
   \   0003D0   85....       MOV       ?V1,?V3
     87            if (cursor)
   \   0003D3   E5..         MOV       A,?V0
   \   0003D5   45..         ORL       A,?V1
   \   0003D7   6006         JZ        ??test3_35
     88                return 9; 
   \   0003D9   7A09         MOV       R2,#0x9
   \   0003DB   7B00         MOV       R3,#0x0
   \   0003DD   801D         SJMP      ??test3_36
     89          
     90            cursor = BF_cursor_rx();
   \                     ??test3_35:
   \   0003DF                ; Setup parameters for call to function BF_cursor_rx
   \   0003DF   12....       LCALL     `??BF_cursor_rx::?relay`; Banked call to: BF_cursor_rx
   \   0003E2   8A..         MOV       ?V2,R2
   \   0003E4   8B..         MOV       ?V3,R3
   \   0003E6   85....       MOV       ?V0,?V2
   \   0003E9   85....       MOV       ?V1,?V3
     91            if (cursor)
   \   0003EC   E5..         MOV       A,?V0
   \   0003EE   45..         ORL       A,?V1
   \   0003F0   6006         JZ        ??test3_37
     92                return 9;
   \   0003F2   7A09         MOV       R2,#0x9
   \   0003F4   7B00         MOV       R3,#0x0
   \   0003F6   8004         SJMP      ??test3_36
     93            
     94           return test_res;
   \                     ??test3_37:
   \   0003F8   EE           MOV       A,R6
   \   0003F9   FA           MOV       R2,A
   \   0003FA   EF           MOV       A,R7
   \   0003FB   FB           MOV       R3,A
   \                     ??test3_36:
   \   0003FC   74D6         MOV       A,#-0x2a
   \   0003FE   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000401   7F08         MOV       R7,#0x8
   \   000403   02....       LJMP      ?BANKED_LEAVE_SP
     95          }
     96          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     97          static int test2(void){
   \                     ??test2:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 42
   \   000005   742A         MOV       A,#0x2a
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
     98            int test_res = 0;
   \   00000A   7E00         MOV       R6,#0x0
   \   00000C   7F00         MOV       R7,#0x0
     99            
    100            struct frame* fr[20];
    101            struct frame* content;
    102            
    103            for (int i = 0; i < 20; i++){
   \   00000E   75..00       MOV       ?V0,#0x0
   \   000011   75..00       MOV       ?V1,#0x0
   \                     ??test2_4:
   \   000014   C3           CLR       C
   \   000015   E5..         MOV       A,?V0
   \   000017   9414         SUBB      A,#0x14
   \   000019   E5..         MOV       A,?V1
   \   00001B   9400         SUBB      A,#0x0
   \   00001D   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00001F   65D0         XRL       A,PSW
   \   000021   33           RLC       A
   \   000022   5073         JNC       ??test2_5
    104              fr[i] = FR_create();
   \   000024                ; Setup parameters for call to function FR_create
   \   000024   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   000027   A8..         MOV       R0,?V0
   \   000029   A9..         MOV       R1,?V1
   \   00002B   E8           MOV       A,R0
   \   00002C   75F002       MOV       B,#0x2
   \   00002F   A4           MUL       AB
   \   000030   C8           XCH       A,R0
   \   000031   ACF0         MOV       R4,B
   \   000033   75F000       MOV       B,#0x0
   \   000036   A4           MUL       AB
   \   000037   2C           ADD       A,R4
   \   000038   FC           MOV       R4,A
   \   000039   75F002       MOV       B,#0x2
   \   00003C   E9           MOV       A,R1
   \   00003D   A4           MUL       AB
   \   00003E   2C           ADD       A,R4
   \   00003F   F9           MOV       R1,A
   \   000040   90FFD5       MOV       DPTR,#-0x2b
   \   000043   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000046   E582         MOV       A,DPL
   \   000048   28           ADD       A,R0
   \   000049   F582         MOV       DPL,A
   \   00004B   E583         MOV       A,DPH
   \   00004D   39           ADDC      A,R1
   \   00004E   F583         MOV       DPH,A
   \   000050   EA           MOV       A,R2
   \   000051   F0           MOVX      @DPTR,A
   \   000052   A3           INC       DPTR
   \   000053   EB           MOV       A,R3
   \   000054   F0           MOVX      @DPTR,A
    105              if (!BF_push_tx(fr[i]))
   \   000055                ; Setup parameters for call to function BF_push_tx
   \   000055   A8..         MOV       R0,?V0
   \   000057   A9..         MOV       R1,?V1
   \   000059   E8           MOV       A,R0
   \   00005A   75F002       MOV       B,#0x2
   \   00005D   A4           MUL       AB
   \   00005E   C8           XCH       A,R0
   \   00005F   AAF0         MOV       R2,B
   \   000061   75F000       MOV       B,#0x0
   \   000064   A4           MUL       AB
   \   000065   2A           ADD       A,R2
   \   000066   FA           MOV       R2,A
   \   000067   75F002       MOV       B,#0x2
   \   00006A   E9           MOV       A,R1
   \   00006B   A4           MUL       AB
   \   00006C   2A           ADD       A,R2
   \   00006D   F9           MOV       R1,A
   \   00006E   90FFD5       MOV       DPTR,#-0x2b
   \   000071   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000074   E582         MOV       A,DPL
   \   000076   28           ADD       A,R0
   \   000077   F582         MOV       DPL,A
   \   000079   E583         MOV       A,DPH
   \   00007B   39           ADDC      A,R1
   \   00007C   F583         MOV       DPH,A
   \   00007E   E0           MOVX      A,@DPTR
   \   00007F   FA           MOV       R2,A
   \   000080   A3           INC       DPTR
   \   000081   E0           MOVX      A,@DPTR
   \   000082   FB           MOV       R3,A
   \   000083   12....       LCALL     `??BF_push_tx::?relay`; Banked call to: BF_push_tx
   \   000086   4004         JC        ??test2_6
    106                test_res = 1;
   \   000088   7E01         MOV       R6,#0x1
   \   00008A   7F00         MOV       R7,#0x0
    107            }
   \                     ??test2_6:
   \   00008C   05..         INC       ?V0
   \   00008E   E5..         MOV       A,?V0
   \   000090   7082         JNZ       ??test2_4
   \   000092   05..         INC       ?V1
   \   000094   02....       LJMP      ??test2_4 & 0xFFFF
    108            
    109            void *cursor = BF_cursor_tx();
   \                     ??test2_5:
   \   000097                ; Setup parameters for call to function BF_cursor_tx
   \   000097   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   00009A   8A..         MOV       ?V2,R2
   \   00009C   8B..         MOV       ?V3,R3
   \   00009E   85....       MOV       ?V0,?V2
   \   0000A1   85....       MOV       ?V1,?V3
    110            for (int i = 0; i <20; i++){
   \   0000A4   75..00       MOV       ?V2,#0x0
   \   0000A7   75..00       MOV       ?V3,#0x0
   \                     ??test2_7:
   \   0000AA   C3           CLR       C
   \   0000AB   E5..         MOV       A,?V2
   \   0000AD   9414         SUBB      A,#0x14
   \   0000AF   E5..         MOV       A,?V3
   \   0000B1   9400         SUBB      A,#0x0
   \   0000B3   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0000B5   65D0         XRL       A,PSW
   \   0000B7   33           RLC       A
   \   0000B8   507B         JNC       ??test2_8
    111                content = BF_content(cursor);
   \   0000BA                ; Setup parameters for call to function BF_content
   \   0000BA   AA..         MOV       R2,?V0
   \   0000BC   AB..         MOV       R3,?V1
   \   0000BE   12....       LCALL     `??BF_content::?relay`; Banked call to: BF_content
   \   0000C1   90FFFD       MOV       DPTR,#-0x3
   \   0000C4   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000C7   EA           MOV       A,R2
   \   0000C8   F0           MOVX      @DPTR,A
   \   0000C9   A3           INC       DPTR
   \   0000CA   EB           MOV       A,R3
   \   0000CB   F0           MOVX      @DPTR,A
    112                if (content != fr[19-i])
   \   0000CC   90FFFD       MOV       DPTR,#-0x3
   \   0000CF   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000D2   E0           MOVX      A,@DPTR
   \   0000D3   FA           MOV       R2,A
   \   0000D4   A3           INC       DPTR
   \   0000D5   E0           MOVX      A,@DPTR
   \   0000D6   FB           MOV       R3,A
   \   0000D7   C3           CLR       C
   \   0000D8   E4           CLR       A
   \   0000D9   95..         SUBB      A,?V2
   \   0000DB   F8           MOV       R0,A
   \   0000DC   E4           CLR       A
   \   0000DD   95..         SUBB      A,?V3
   \   0000DF   F9           MOV       R1,A
   \   0000E0   E8           MOV       A,R0
   \   0000E1   75F002       MOV       B,#0x2
   \   0000E4   A4           MUL       AB
   \   0000E5   C8           XCH       A,R0
   \   0000E6   ACF0         MOV       R4,B
   \   0000E8   75F000       MOV       B,#0x0
   \   0000EB   A4           MUL       AB
   \   0000EC   2C           ADD       A,R4
   \   0000ED   FC           MOV       R4,A
   \   0000EE   75F002       MOV       B,#0x2
   \   0000F1   E9           MOV       A,R1
   \   0000F2   A4           MUL       AB
   \   0000F3   2C           ADD       A,R4
   \   0000F4   F9           MOV       R1,A
   \   0000F5   90FFD5       MOV       DPTR,#-0x2b
   \   0000F8   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000FB   E582         MOV       A,DPL
   \   0000FD   28           ADD       A,R0
   \   0000FE   F8           MOV       R0,A
   \   0000FF   E583         MOV       A,DPH
   \   000101   39           ADDC      A,R1
   \   000102   F9           MOV       R1,A
   \   000103   E8           MOV       A,R0
   \   000104   2426         ADD       A,#0x26
   \   000106   F582         MOV       DPL,A
   \   000108   E4           CLR       A
   \   000109   39           ADDC      A,R1
   \   00010A   F583         MOV       DPH,A
   \   00010C   E0           MOVX      A,@DPTR
   \   00010D   6A           XRL       A,R2
   \   00010E   7003         JNZ       ??test2_9
   \   000110   A3           INC       DPTR
   \   000111   E0           MOVX      A,@DPTR
   \   000112   6B           XRL       A,R3
   \                     ??test2_9:
   \   000113   6004         JZ        ??test2_10
    113                  test_res = 2;
   \   000115   7E02         MOV       R6,#0x2
   \   000117   7F00         MOV       R7,#0x0
    114                cursor = BF_cursor_next(cursor);
   \                     ??test2_10:
   \   000119                ; Setup parameters for call to function BF_cursor_next
   \   000119   AA..         MOV       R2,?V0
   \   00011B   AB..         MOV       R3,?V1
   \   00011D   12....       LCALL     `??BF_cursor_next::?relay`; Banked call to: BF_cursor_next
   \   000120   8A..         MOV       ?V4,R2
   \   000122   8B..         MOV       ?V5,R3
   \   000124   85....       MOV       ?V0,?V4
   \   000127   85....       MOV       ?V1,?V5
    115            }
   \   00012A   05..         INC       ?V2
   \   00012C   E5..         MOV       A,?V2
   \   00012E   7002         JNZ       ??test2_11
   \   000130   05..         INC       ?V3
   \                     ??test2_11:
   \   000132   02....       LJMP      ??test2_7 & 0xFFFF
    116            
    117            void *del_cursor;
    118            cursor = BF_cursor_tx();
   \                     ??test2_8:
   \   000135                ; Setup parameters for call to function BF_cursor_tx
   \   000135   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   000138   8A..         MOV       ?V2,R2
   \   00013A   8B..         MOV       ?V3,R3
   \   00013C   85....       MOV       ?V0,?V2
   \   00013F   85....       MOV       ?V1,?V3
    119            for (int i = 0; i < 20; i++){
   \   000142   75..00       MOV       ?V2,#0x0
   \   000145   75..00       MOV       ?V3,#0x0
   \                     ??test2_12:
   \   000148   C3           CLR       C
   \   000149   E5..         MOV       A,?V2
   \   00014B   9414         SUBB      A,#0x14
   \   00014D   E5..         MOV       A,?V3
   \   00014F   9400         SUBB      A,#0x0
   \   000151   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000153   65D0         XRL       A,PSW
   \   000155   33           RLC       A
   \   000156   5065         JNC       ??test2_13
    120                if (!FR_delete(fr[i]))
   \   000158                ; Setup parameters for call to function FR_delete
   \   000158   A8..         MOV       R0,?V2
   \   00015A   A9..         MOV       R1,?V3
   \   00015C   E8           MOV       A,R0
   \   00015D   75F002       MOV       B,#0x2
   \   000160   A4           MUL       AB
   \   000161   C8           XCH       A,R0
   \   000162   AAF0         MOV       R2,B
   \   000164   75F000       MOV       B,#0x0
   \   000167   A4           MUL       AB
   \   000168   2A           ADD       A,R2
   \   000169   FA           MOV       R2,A
   \   00016A   75F002       MOV       B,#0x2
   \   00016D   E9           MOV       A,R1
   \   00016E   A4           MUL       AB
   \   00016F   2A           ADD       A,R2
   \   000170   F9           MOV       R1,A
   \   000171   90FFD5       MOV       DPTR,#-0x2b
   \   000174   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000177   E582         MOV       A,DPL
   \   000179   28           ADD       A,R0
   \   00017A   F582         MOV       DPL,A
   \   00017C   E583         MOV       A,DPH
   \   00017E   39           ADDC      A,R1
   \   00017F   F583         MOV       DPH,A
   \   000181   E0           MOVX      A,@DPTR
   \   000182   FA           MOV       R2,A
   \   000183   A3           INC       DPTR
   \   000184   E0           MOVX      A,@DPTR
   \   000185   FB           MOV       R3,A
   \   000186   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
   \   000189   4004         JC        ??test2_14
    121                  test_res = 3;
   \   00018B   7E03         MOV       R6,#0x3
   \   00018D   7F00         MOV       R7,#0x0
    122                del_cursor = cursor;
   \                     ??test2_14:
   \   00018F   85....       MOV       ?V6,?V0
   \   000192   85....       MOV       ?V7,?V1
    123                cursor = BF_cursor_next(cursor);
   \   000195                ; Setup parameters for call to function BF_cursor_next
   \   000195   AA..         MOV       R2,?V0
   \   000197   AB..         MOV       R3,?V1
   \   000199   12....       LCALL     `??BF_cursor_next::?relay`; Banked call to: BF_cursor_next
   \   00019C   8A..         MOV       ?V4,R2
   \   00019E   8B..         MOV       ?V5,R3
   \   0001A0   85....       MOV       ?V0,?V4
   \   0001A3   85....       MOV       ?V1,?V5
    124                if (!BF_remove_tx(del_cursor))
   \   0001A6                ; Setup parameters for call to function BF_remove_tx
   \   0001A6   AA..         MOV       R2,?V6
   \   0001A8   AB..         MOV       R3,?V7
   \   0001AA   12....       LCALL     `??BF_remove_tx::?relay`; Banked call to: BF_remove_tx
   \   0001AD   4004         JC        ??test2_15
    125                  test_res = 4;
   \   0001AF   7E04         MOV       R6,#0x4
   \   0001B1   7F00         MOV       R7,#0x0
    126            }
   \                     ??test2_15:
   \   0001B3   05..         INC       ?V2
   \   0001B5   E5..         MOV       A,?V2
   \   0001B7   708F         JNZ       ??test2_12
   \   0001B9   05..         INC       ?V3
   \   0001BB   808B         SJMP      ??test2_12
    127            
    128            cursor = BF_cursor_tx();
   \                     ??test2_13:
   \   0001BD                ; Setup parameters for call to function BF_cursor_tx
   \   0001BD   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   0001C0   8A..         MOV       ?V2,R2
   \   0001C2   8B..         MOV       ?V3,R3
   \   0001C4   85....       MOV       ?V0,?V2
   \   0001C7   85....       MOV       ?V1,?V3
    129            if (cursor)
   \   0001CA   E5..         MOV       A,?V0
   \   0001CC   45..         ORL       A,?V1
   \   0001CE   6004         JZ        ??test2_16
    130                test_res =  5; 
   \   0001D0   7E05         MOV       R6,#0x5
   \   0001D2   7F00         MOV       R7,#0x0
    131            
    132            return test_res;
   \                     ??test2_16:
   \   0001D4   EE           MOV       A,R6
   \   0001D5   FA           MOV       R2,A
   \   0001D6   EF           MOV       A,R7
   \   0001D7   FB           MOV       R3,A
   \   0001D8   74D6         MOV       A,#-0x2a
   \   0001DA   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001DD   7F08         MOV       R7,#0x8
   \   0001DF   02....       LJMP      ?BANKED_LEAVE_SP
    133          }
    134          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    135          static int test1(void){
   \                     ??test1:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   C0E0         PUSH      A
   \   000007   C0E0         PUSH      A
    136            int test_res = 0;
   \   000009   7E00         MOV       R6,#0x0
   \   00000B   7F00         MOV       R7,#0x0
    137            struct frame *fr = FR_create();
   \   00000D                ; Setup parameters for call to function FR_create
   \   00000D   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   000010   8A..         MOV       ?V0,R2
   \   000012   8B..         MOV       ?V1,R3
   \   000014   85....       MOV       ?V2,?V0
   \   000017   85....       MOV       ?V3,?V1
    138            
    139            if (!BF_push_tx(fr))
   \   00001A                ; Setup parameters for call to function BF_push_tx
   \   00001A   AA..         MOV       R2,?V2
   \   00001C   AB..         MOV       R3,?V3
   \   00001E   12....       LCALL     `??BF_push_tx::?relay`; Banked call to: BF_push_tx
   \   000021   4004         JC        ??test1_4
    140              test_res = 1;
   \   000023   7E01         MOV       R6,#0x1
   \   000025   7F00         MOV       R7,#0x0
    141          
    142            void *cursor = BF_cursor_tx();
   \                     ??test1_4:
   \   000027                ; Setup parameters for call to function BF_cursor_tx
   \   000027   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   00002A   8A..         MOV       ?V4,R2
   \   00002C   8B..         MOV       ?V5,R3
   \   00002E   85....       MOV       ?V0,?V4
   \   000031   85....       MOV       ?V1,?V5
    143            if (!cursor)
   \   000034   E5..         MOV       A,?V0
   \   000036   45..         ORL       A,?V1
   \   000038   7004         JNZ       ??test1_5
    144              test_res = 2;
   \   00003A   7E02         MOV       R6,#0x2
   \   00003C   7F00         MOV       R7,#0x0
    145            
    146            struct frame *n_fr = BF_content(cursor);
   \                     ??test1_5:
   \   00003E                ; Setup parameters for call to function BF_content
   \   00003E   AA..         MOV       R2,?V0
   \   000040   AB..         MOV       R3,?V1
   \   000042   12....       LCALL     `??BF_content::?relay`; Banked call to: BF_content
   \   000045   90FFFD       MOV       DPTR,#-0x3
   \   000048   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00004B   EA           MOV       A,R2
   \   00004C   F0           MOVX      @DPTR,A
   \   00004D   A3           INC       DPTR
   \   00004E   EB           MOV       A,R3
   \   00004F   F0           MOVX      @DPTR,A
    147            if (fr != n_fr)
   \   000050   90FFFD       MOV       DPTR,#-0x3
   \   000053   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000056   E0           MOVX      A,@DPTR
   \   000057   F8           MOV       R0,A
   \   000058   A3           INC       DPTR
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   F9           MOV       R1,A
   \   00005B   E5..         MOV       A,?V2
   \   00005D   68           XRL       A,R0
   \   00005E   7003         JNZ       ??test1_6
   \   000060   E5..         MOV       A,?V3
   \   000062   69           XRL       A,R1
   \                     ??test1_6:
   \   000063   6004         JZ        ??test1_7
    148              test_res = 3;
   \   000065   7E03         MOV       R6,#0x3
   \   000067   7F00         MOV       R7,#0x0
    149            
    150            struct frame *fr2 = FR_create();
   \                     ??test1_7:
   \   000069                ; Setup parameters for call to function FR_create
   \   000069   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   00006C   8A..         MOV       ?V4,R2
   \   00006E   8B..         MOV       ?V5,R3
   \   000070   85....       MOV       ?V6,?V4
   \   000073   85....       MOV       ?V7,?V5
    151            if (!BF_push_tx(fr2))
   \   000076                ; Setup parameters for call to function BF_push_tx
   \   000076   AA..         MOV       R2,?V6
   \   000078   AB..         MOV       R3,?V7
   \   00007A   12....       LCALL     `??BF_push_tx::?relay`; Banked call to: BF_push_tx
   \   00007D   4004         JC        ??test1_8
    152              test_res = 4;
   \   00007F   7E04         MOV       R6,#0x4
   \   000081   7F00         MOV       R7,#0x0
    153            
    154            cursor = BF_cursor_tx();
   \                     ??test1_8:
   \   000083                ; Setup parameters for call to function BF_cursor_tx
   \   000083   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   000086   8A..         MOV       ?V4,R2
   \   000088   8B..         MOV       ?V5,R3
   \   00008A   85....       MOV       ?V0,?V4
   \   00008D   85....       MOV       ?V1,?V5
    155            if (!cursor)
   \   000090   E5..         MOV       A,?V0
   \   000092   45..         ORL       A,?V1
   \   000094   7004         JNZ       ??test1_9
    156              test_res = 5;
   \   000096   7E05         MOV       R6,#0x5
   \   000098   7F00         MOV       R7,#0x0
    157            
    158            cursor = BF_cursor_next(cursor);  
   \                     ??test1_9:
   \   00009A                ; Setup parameters for call to function BF_cursor_next
   \   00009A   AA..         MOV       R2,?V0
   \   00009C   AB..         MOV       R3,?V1
   \   00009E   12....       LCALL     `??BF_cursor_next::?relay`; Banked call to: BF_cursor_next
   \   0000A1   8A..         MOV       ?V4,R2
   \   0000A3   8B..         MOV       ?V5,R3
   \   0000A5   85....       MOV       ?V0,?V4
   \   0000A8   85....       MOV       ?V1,?V5
    159            if (!cursor)
   \   0000AB   E5..         MOV       A,?V0
   \   0000AD   45..         ORL       A,?V1
   \   0000AF   7004         JNZ       ??test1_10
    160              test_res = 6;
   \   0000B1   7E06         MOV       R6,#0x6
   \   0000B3   7F00         MOV       R7,#0x0
    161              
    162            cursor = BF_cursor_tx();
   \                     ??test1_10:
   \   0000B5                ; Setup parameters for call to function BF_cursor_tx
   \   0000B5   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   0000B8   8A..         MOV       ?V4,R2
   \   0000BA   8B..         MOV       ?V5,R3
   \   0000BC   85....       MOV       ?V0,?V4
   \   0000BF   85....       MOV       ?V1,?V5
    163            if (!BF_remove_tx(cursor))
   \   0000C2                ; Setup parameters for call to function BF_remove_tx
   \   0000C2   AA..         MOV       R2,?V0
   \   0000C4   AB..         MOV       R3,?V1
   \   0000C6   12....       LCALL     `??BF_remove_tx::?relay`; Banked call to: BF_remove_tx
   \   0000C9   4006         JC        ??test1_11
    164                return 8;
   \   0000CB   7A08         MOV       R2,#0x8
   \   0000CD   7B00         MOV       R3,#0x0
   \   0000CF   8057         SJMP      ??test1_12
    165            
    166            cursor = BF_cursor_tx();
   \                     ??test1_11:
   \   0000D1                ; Setup parameters for call to function BF_cursor_tx
   \   0000D1   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   0000D4   8A..         MOV       ?V4,R2
   \   0000D6   8B..         MOV       ?V5,R3
   \   0000D8   85....       MOV       ?V0,?V4
   \   0000DB   85....       MOV       ?V1,?V5
    167            if (!BF_remove_tx(cursor))
   \   0000DE                ; Setup parameters for call to function BF_remove_tx
   \   0000DE   AA..         MOV       R2,?V0
   \   0000E0   AB..         MOV       R3,?V1
   \   0000E2   12....       LCALL     `??BF_remove_tx::?relay`; Banked call to: BF_remove_tx
   \   0000E5   4006         JC        ??test1_13
    168                return 9;
   \   0000E7   7A09         MOV       R2,#0x9
   \   0000E9   7B00         MOV       R3,#0x0
   \   0000EB   803B         SJMP      ??test1_12
    169          
    170            cursor = BF_cursor_tx();
   \                     ??test1_13:
   \   0000ED                ; Setup parameters for call to function BF_cursor_tx
   \   0000ED   12....       LCALL     `??BF_cursor_tx::?relay`; Banked call to: BF_cursor_tx
   \   0000F0   8A..         MOV       ?V4,R2
   \   0000F2   8B..         MOV       ?V5,R3
   \   0000F4   85....       MOV       ?V0,?V4
   \   0000F7   85....       MOV       ?V1,?V5
    171            if (cursor)
   \   0000FA   E5..         MOV       A,?V0
   \   0000FC   45..         ORL       A,?V1
   \   0000FE   6006         JZ        ??test1_14
    172                return 10;  
   \   000100   7A0A         MOV       R2,#0xa
   \   000102   7B00         MOV       R3,#0x0
   \   000104   8022         SJMP      ??test1_12
    173            
    174            if (!FR_delete(fr))
   \                     ??test1_14:
   \   000106                ; Setup parameters for call to function FR_delete
   \   000106   AA..         MOV       R2,?V2
   \   000108   AB..         MOV       R3,?V3
   \   00010A   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
   \   00010D   4006         JC        ??test1_15
    175              return 11;
   \   00010F   7A0B         MOV       R2,#0xb
   \   000111   7B00         MOV       R3,#0x0
   \   000113   8013         SJMP      ??test1_12
    176          
    177            if (!FR_delete(fr2))
   \                     ??test1_15:
   \   000115                ; Setup parameters for call to function FR_delete
   \   000115   AA..         MOV       R2,?V6
   \   000117   AB..         MOV       R3,?V7
   \   000119   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
   \   00011C   4006         JC        ??test1_16
    178              return 12;
   \   00011E   7A0C         MOV       R2,#0xc
   \   000120   7B00         MOV       R3,#0x0
   \   000122   8004         SJMP      ??test1_12
    179            
    180            return test_res;
   \                     ??test1_16:
   \   000124   EE           MOV       A,R6
   \   000125   FA           MOV       R2,A
   \   000126   EF           MOV       A,R7
   \   000127   FB           MOV       R3,A
   \                     ??test1_12:
   \   000128   D0E0         POP       A
   \   00012A   D0E0         POP       A
   \   00012C   7F08         MOV       R7,#0x8
   \   00012E   02....       LJMP      ?BANKED_LEAVE_SP
    181          }
E:\Neocore\Hardware\PRJ Test\u_debug.c
      1          #include "utest.h"
      2          

   \                                 In  segment XDATA_I, align 1, keep-with-next
      3          struct test_unit UTEST_DEBUG = {.name = "DEBUG MODUL"};
   \                     UTEST_DEBUG:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UTEST_DEBUG>`
   \   000022                REQUIRE __INIT_XDATA_I
      4          
      5          static void u_test(void){
      6          
      7          }
E:\Neocore\Hardware\PRJ Test\u_frame.c
      1          #include "utest.h"
      2          #include "stddef.h"
      3          #include "stdbool.h"
      4          
      5          static int test1(void);
      6          static int test2(void);
      7          static int test3(void);

   \                                 In  segment XDATA_I, align 1, keep-with-next
      8          struct test_unit UT_FR_1 = {.name = "FR:create-delete", .fun = test1};
   \                     UT_FR_1:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_FR_1>`
   \   000022                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
      9          struct test_unit UT_FR_2 = {.name = "FR:create-full", .fun = test2};
   \                     UT_FR_2:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_FR_2>`
   \   000022                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
     10          struct test_unit UT_FR_3 = {.name = "FR:header manipulation", .fun = test3};
   \                     UT_FR_3:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_FR_3>`
   \   000022                REQUIRE __INIT_XDATA_I
     11          #include "frame.h"
     12          
     13          //struct frame* FR_create();
     14          //void FR_delete(struct frame*);
     15          //void FR_add_header(struct frame*, void *head, char len);
     16          //void FR_del_header(struct frame*, char len);
     17          //int FR_busy();
     18          //int FR_available();
     19          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     20          static bool ch_cmp(void *dst, void *src, size_t len){
   \                     ??ch_cmp:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
   \   000006   90FFF8       MOV       DPTR,#-0x8
   \   000009   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F8           MOV       R0,A
   \   00000E   A3           INC       DPTR
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   F9           MOV       R1,A
     21            while (len-- > 0){
   \                     ??ch_cmp_1:
   \   000011   E8           MOV       A,R0
   \   000012   FE           MOV       R6,A
   \   000013   E9           MOV       A,R1
   \   000014   FF           MOV       R7,A
   \   000015   EE           MOV       A,R6
   \   000016   24FF         ADD       A,#-0x1
   \   000018   F8           MOV       R0,A
   \   000019   EF           MOV       A,R7
   \   00001A   34FF         ADDC      A,#-0x1
   \   00001C   F9           MOV       R1,A
   \   00001D   EE           MOV       A,R6
   \   00001E   4F           ORL       A,R7
   \   00001F   6011         JZ        ??ch_cmp_2
     22              if ( *(char*)dst != *(char*)src)
   \   000021   8A82         MOV       DPL,R2
   \   000023   8B83         MOV       DPH,R3
   \   000025   E0           MOVX      A,@DPTR
   \   000026   FE           MOV       R6,A
   \   000027   8C82         MOV       DPL,R4
   \   000029   8D83         MOV       DPH,R5
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   6E           XRL       A,R6
   \   00002D   60E2         JZ        ??ch_cmp_1
     23                return false;
   \   00002F   C3           CLR       C
   \   000030   8001         SJMP      ??ch_cmp_3
     24            }
     25            return true;
   \                     ??ch_cmp_2:
   \   000032   D3           SETB      C
   \                     ??ch_cmp_3:
   \   000033   D0E0         POP       A
   \   000035   FF           MOV       R7,A
   \   000036   D0E0         POP       A
   \   000038   FE           MOV       R6,A
   \   000039   02....       LJMP      ?BRET
     26          }
     27          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     28          static bool ch_cmp_val(void *dst, char val, size_t len){
   \                     ??ch_cmp_val:
   \   000000   EE           MOV       A,R6
   \   000001   C0E0         PUSH      A
   \   000003   EF           MOV       A,R7
   \   000004   C0E0         PUSH      A
   \   000006                ; Saved register size: 2
   \   000006                ; Auto size: 0
     29            while (len-- > 0){
   \                     ??ch_cmp_val_1:
   \   000006   EC           MOV       A,R4
   \   000007   FE           MOV       R6,A
   \   000008   ED           MOV       A,R5
   \   000009   FF           MOV       R7,A
   \   00000A   EE           MOV       A,R6
   \   00000B   24FF         ADD       A,#-0x1
   \   00000D   FC           MOV       R4,A
   \   00000E   EF           MOV       A,R7
   \   00000F   34FF         ADDC      A,#-0x1
   \   000011   FD           MOV       R5,A
   \   000012   EE           MOV       A,R6
   \   000013   4F           ORL       A,R7
   \   000014   600B         JZ        ??ch_cmp_val_2
     30              if ( *(char*)dst != val)
   \   000016   8A82         MOV       DPL,R2
   \   000018   8B83         MOV       DPH,R3
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   69           XRL       A,R1
   \   00001C   60E8         JZ        ??ch_cmp_val_1
     31                return false;
   \   00001E   C3           CLR       C
   \   00001F   8001         SJMP      ??ch_cmp_val_3
     32            }
     33            return true;
   \                     ??ch_cmp_val_2:
   \   000021   D3           SETB      C
   \                     ??ch_cmp_val_3:
   \   000022   D0E0         POP       A
   \   000024   FF           MOV       R7,A
   \   000025   D0E0         POP       A
   \   000027   FE           MOV       R6,A
   \   000028   02....       LJMP      ?BRET
     34          }
     35          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     36          static int test3(void){
   \                     ??test3_1:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 10
   \   000005   740A         MOV       A,#0xa
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
     37            int test_res = 0;
   \   00000A   7E00         MOV       R6,#0x0
   \   00000C   7F00         MOV       R7,#0x0
     38            struct frame *fr = FR_create();
   \   00000E                ; Setup parameters for call to function FR_create
   \   00000E   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   000011   8A..         MOV       ?V2,R2
   \   000013   8B..         MOV       ?V3,R3
   \   000015   85....       MOV       ?V0,?V2
   \   000018   85....       MOV       ?V1,?V3
     39            char hdr[10] = {1,2,3,4,5,6,7,8,9,10};
   \   00001B   90....       MOV       DPTR,#`?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}>`
   \   00001E   C082         PUSH      DPL
   \   000020   C083         PUSH      DPH
   \   000022   90FFF3       MOV       DPTR,#-0xd
   \   000025   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000028   AC82         MOV       R4,DPL
   \   00002A   AD83         MOV       R5,DPH
   \   00002C   D083         POP       DPH
   \   00002E   D082         POP       DPL
   \   000030   740A         MOV       A,#0xa
   \   000032   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
     40            FR_add_header(fr, hdr, sizeof(hdr));
   \   000035                ; Setup parameters for call to function FR_add_header
   \   000035   790A         MOV       R1,#0xa
   \   000037   90FFF5       MOV       DPTR,#-0xb
   \   00003A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00003D   AC82         MOV       R4,DPL
   \   00003F   AD83         MOV       R5,DPH
   \   000041   AA..         MOV       R2,?V0
   \   000043   AB..         MOV       R3,?V1
   \   000045   12....       LCALL     `??FR_add_header::?relay`; Banked call to: FR_add_header
     41            if (!ch_cmp(hdr, fr->payload, sizeof(hdr)))
   \   000048                ; Setup parameters for call to function ch_cmp
   \   000048   740A         MOV       A,#0xa
   \   00004A   C0E0         PUSH      A
   \   00004C   7400         MOV       A,#0x0
   \   00004E   C0E0         PUSH      A
   \   000050   E5..         MOV       A,?V0
   \   000052   2415         ADD       A,#0x15
   \   000054   FC           MOV       R4,A
   \   000055   E4           CLR       A
   \   000056   35..         ADDC      A,?V1
   \   000058   FD           MOV       R5,A
   \   000059   90FFF3       MOV       DPTR,#-0xd
   \   00005C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00005F   AA82         MOV       R2,DPL
   \   000061   AB83         MOV       R3,DPH
   \   000063   12....       LCALL     `??ch_cmp::?relay`; Banked call to: ch_cmp
   \   000066   D0E0         POP       A
   \   000068   D0E0         POP       A
   \   00006A   4004         JC        ??test3_38
     42                test_res = 1;
   \   00006C   7E01         MOV       R6,#0x1
   \   00006E   7F00         MOV       R7,#0x0
     43            
     44            if (fr->len != sizeof(hdr))
   \                     ??test3_38:
   \   000070   85..82       MOV       DPL,?V0
   \   000073   85..83       MOV       DPH,?V1
   \   000076   E0           MOVX      A,@DPTR
   \   000077   640A         XRL       A,#0xa
   \   000079   6004         JZ        ??test3_39
     45                test_res = 2;
   \   00007B   7E02         MOV       R6,#0x2
   \   00007D   7F00         MOV       R7,#0x0
     46            
     47            FR_del_header(fr, 5);
   \                     ??test3_39:
   \   00007F                ; Setup parameters for call to function FR_del_header
   \   00007F   7905         MOV       R1,#0x5
   \   000081   AA..         MOV       R2,?V0
   \   000083   AB..         MOV       R3,?V1
   \   000085   12....       LCALL     `??FR_del_header::?relay`; Banked call to: FR_del_header
     48            if (!ch_cmp(&hdr[5], fr->payload, sizeof(hdr) - 5))
   \   000088                ; Setup parameters for call to function ch_cmp
   \   000088   7405         MOV       A,#0x5
   \   00008A   C0E0         PUSH      A
   \   00008C   7400         MOV       A,#0x0
   \   00008E   C0E0         PUSH      A
   \   000090   E5..         MOV       A,?V0
   \   000092   2415         ADD       A,#0x15
   \   000094   FC           MOV       R4,A
   \   000095   E4           CLR       A
   \   000096   35..         ADDC      A,?V1
   \   000098   FD           MOV       R5,A
   \   000099   90FFF8       MOV       DPTR,#-0x8
   \   00009C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00009F   AA82         MOV       R2,DPL
   \   0000A1   AB83         MOV       R3,DPH
   \   0000A3   12....       LCALL     `??ch_cmp::?relay`; Banked call to: ch_cmp
   \   0000A6   D0E0         POP       A
   \   0000A8   D0E0         POP       A
   \   0000AA   4004         JC        ??test3_40
     49                test_res = 3;  
   \   0000AC   7E03         MOV       R6,#0x3
   \   0000AE   7F00         MOV       R7,#0x0
     50            
     51            if (fr->len != sizeof(hdr) - 5)
   \                     ??test3_40:
   \   0000B0   85..82       MOV       DPL,?V0
   \   0000B3   85..83       MOV       DPH,?V1
   \   0000B6   E0           MOVX      A,@DPTR
   \   0000B7   6405         XRL       A,#0x5
   \   0000B9   6004         JZ        ??test3_41
     52              test_res = 4;
   \   0000BB   7E04         MOV       R6,#0x4
   \   0000BD   7F00         MOV       R7,#0x0
     53            
     54            if (!ch_cmp_val(&fr->payload[5], 0, MAX_PAYLOAD_SIZE - 5))
   \                     ??test3_41:
   \   0000BF                ; Setup parameters for call to function ch_cmp_val
   \   0000BF   7C7A         MOV       R4,#0x7a
   \   0000C1   7D00         MOV       R5,#0x0
   \   0000C3   7900         MOV       R1,#0x0
   \   0000C5   E5..         MOV       A,?V0
   \   0000C7   241A         ADD       A,#0x1a
   \   0000C9   FA           MOV       R2,A
   \   0000CA   E4           CLR       A
   \   0000CB   35..         ADDC      A,?V1
   \   0000CD   FB           MOV       R3,A
   \   0000CE   12....       LCALL     `??ch_cmp_val::?relay`; Banked call to: ch_cmp_val
   \   0000D1   4004         JC        ??test3_42
     55              test_res = 5;  
   \   0000D3   7E05         MOV       R6,#0x5
   \   0000D5   7F00         MOV       R7,#0x0
     56            
     57            FR_del_header(fr, 5);
   \                     ??test3_42:
   \   0000D7                ; Setup parameters for call to function FR_del_header
   \   0000D7   7905         MOV       R1,#0x5
   \   0000D9   AA..         MOV       R2,?V0
   \   0000DB   AB..         MOV       R3,?V1
   \   0000DD   12....       LCALL     `??FR_del_header::?relay`; Banked call to: FR_del_header
     58            if (!ch_cmp_val(&fr->payload, 0, MAX_PAYLOAD_SIZE))
   \   0000E0                ; Setup parameters for call to function ch_cmp_val
   \   0000E0   7C7F         MOV       R4,#0x7f
   \   0000E2   7D00         MOV       R5,#0x0
   \   0000E4   7900         MOV       R1,#0x0
   \   0000E6   E5..         MOV       A,?V0
   \   0000E8   2415         ADD       A,#0x15
   \   0000EA   FA           MOV       R2,A
   \   0000EB   E4           CLR       A
   \   0000EC   35..         ADDC      A,?V1
   \   0000EE   FB           MOV       R3,A
   \   0000EF   12....       LCALL     `??ch_cmp_val::?relay`; Banked call to: ch_cmp_val
   \   0000F2   4004         JC        ??test3_43
     59              test_res = 6; 
   \   0000F4   7E06         MOV       R6,#0x6
   \   0000F6   7F00         MOV       R7,#0x0
     60            
     61            if (fr->len != 0)
   \                     ??test3_43:
   \   0000F8   85..82       MOV       DPL,?V0
   \   0000FB   85..83       MOV       DPH,?V1
   \   0000FE   E0           MOVX      A,@DPTR
   \   0000FF   6004         JZ        ??test3_44
     62                test_res = 7;
   \   000101   7E07         MOV       R6,#0x7
   \   000103   7F00         MOV       R7,#0x0
     63            
     64            if (FR_add_header(fr, hdr, 200))
   \                     ??test3_44:
   \   000105                ; Setup parameters for call to function FR_add_header
   \   000105   79C8         MOV       R1,#-0x38
   \   000107   90FFF5       MOV       DPTR,#-0xb
   \   00010A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00010D   AC82         MOV       R4,DPL
   \   00010F   AD83         MOV       R5,DPH
   \   000111   AA..         MOV       R2,?V0
   \   000113   AB..         MOV       R3,?V1
   \   000115   12....       LCALL     `??FR_add_header::?relay`; Banked call to: FR_add_header
   \   000118   5004         JNC       ??test3_45
     65              test_res = 8;
   \   00011A   7E08         MOV       R6,#0x8
   \   00011C   7F00         MOV       R7,#0x0
     66           
     67            if (FR_del_header(fr, 200))
   \                     ??test3_45:
   \   00011E                ; Setup parameters for call to function FR_del_header
   \   00011E   79C8         MOV       R1,#-0x38
   \   000120   AA..         MOV       R2,?V0
   \   000122   AB..         MOV       R3,?V1
   \   000124   12....       LCALL     `??FR_del_header::?relay`; Banked call to: FR_del_header
   \   000127   5004         JNC       ??test3_46
     68              test_res = 9;
   \   000129   7E09         MOV       R6,#0x9
   \   00012B   7F00         MOV       R7,#0x0
     69            return test_res;
   \                     ??test3_46:
   \   00012D   EE           MOV       A,R6
   \   00012E   FA           MOV       R2,A
   \   00012F   EF           MOV       A,R7
   \   000130   FB           MOV       R3,A
   \   000131   74F6         MOV       A,#-0xa
   \   000133   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000136   7F04         MOV       R7,#0x4
   \   000138   02....       LJMP      ?BANKED_LEAVE_SP
     70          }
     71          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     72          static int test2(void){
   \                     ??test2_1:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 40
   \   000005   7428         MOV       A,#0x28
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
     73            int test_res = 0;
   \   00000A   7E00         MOV       R6,#0x0
   \   00000C   7F00         MOV       R7,#0x0
     74            struct frame* all[20];
     75            
     76            for (int i = 0; i < 20; i++)
   \   00000E   75..00       MOV       ?V0,#0x0
   \   000011   75..00       MOV       ?V1,#0x0
   \                     ??test2_17:
   \   000014   C3           CLR       C
   \   000015   E5..         MOV       A,?V0
   \   000017   9414         SUBB      A,#0x14
   \   000019   E5..         MOV       A,?V1
   \   00001B   9400         SUBB      A,#0x0
   \   00001D   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00001F   65D0         XRL       A,PSW
   \   000021   33           RLC       A
   \   000022   503B         JNC       ??test2_18
     77              all[i] = FR_create();
   \   000024                ; Setup parameters for call to function FR_create
   \   000024   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   000027   A8..         MOV       R0,?V0
   \   000029   A9..         MOV       R1,?V1
   \   00002B   E8           MOV       A,R0
   \   00002C   75F002       MOV       B,#0x2
   \   00002F   A4           MUL       AB
   \   000030   C8           XCH       A,R0
   \   000031   ACF0         MOV       R4,B
   \   000033   75F000       MOV       B,#0x0
   \   000036   A4           MUL       AB
   \   000037   2C           ADD       A,R4
   \   000038   FC           MOV       R4,A
   \   000039   75F002       MOV       B,#0x2
   \   00003C   E9           MOV       A,R1
   \   00003D   A4           MUL       AB
   \   00003E   2C           ADD       A,R4
   \   00003F   F9           MOV       R1,A
   \   000040   90FFD7       MOV       DPTR,#-0x29
   \   000043   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000046   E582         MOV       A,DPL
   \   000048   28           ADD       A,R0
   \   000049   F582         MOV       DPL,A
   \   00004B   E583         MOV       A,DPH
   \   00004D   39           ADDC      A,R1
   \   00004E   F583         MOV       DPH,A
   \   000050   EA           MOV       A,R2
   \   000051   F0           MOVX      @DPTR,A
   \   000052   A3           INC       DPTR
   \   000053   EB           MOV       A,R3
   \   000054   F0           MOVX      @DPTR,A
   \   000055   05..         INC       ?V0
   \   000057   E5..         MOV       A,?V0
   \   000059   70B9         JNZ       ??test2_17
   \   00005B   05..         INC       ?V1
   \   00005D   80B5         SJMP      ??test2_17
     78          
     79          // Нету NULL  
     80            for(int i = 0; i < 20; i++)
   \                     ??test2_18:
   \   00005F   7800         MOV       R0,#0x0
   \   000061   7900         MOV       R1,#0x0
   \                     ??test2_19:
   \   000063   C3           CLR       C
   \   000064   E8           MOV       A,R0
   \   000065   9414         SUBB      A,#0x14
   \   000067   E9           MOV       A,R1
   \   000068   9400         SUBB      A,#0x0
   \   00006A   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00006C   65D0         XRL       A,PSW
   \   00006E   33           RLC       A
   \   00006F   503D         JNC       ??test2_20
     81              if (all[i] == NULL)
   \   000071   E8           MOV       A,R0
   \   000072   FA           MOV       R2,A
   \   000073   E9           MOV       A,R1
   \   000074   FB           MOV       R3,A
   \   000075   EA           MOV       A,R2
   \   000076   75F002       MOV       B,#0x2
   \   000079   A4           MUL       AB
   \   00007A   CA           XCH       A,R2
   \   00007B   ACF0         MOV       R4,B
   \   00007D   75F000       MOV       B,#0x0
   \   000080   A4           MUL       AB
   \   000081   2C           ADD       A,R4
   \   000082   FC           MOV       R4,A
   \   000083   75F002       MOV       B,#0x2
   \   000086   EB           MOV       A,R3
   \   000087   A4           MUL       AB
   \   000088   2C           ADD       A,R4
   \   000089   FB           MOV       R3,A
   \   00008A   90FFD7       MOV       DPTR,#-0x29
   \   00008D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000090   E582         MOV       A,DPL
   \   000092   2A           ADD       A,R2
   \   000093   F582         MOV       DPL,A
   \   000095   E583         MOV       A,DPH
   \   000097   3B           ADDC      A,R3
   \   000098   F583         MOV       DPH,A
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   FA           MOV       R2,A
   \   00009C   A3           INC       DPTR
   \   00009D   E0           MOVX      A,@DPTR
   \   00009E   FB           MOV       R3,A
   \   00009F   EA           MOV       A,R2
   \   0000A0   4B           ORL       A,R3
   \   0000A1   7004         JNZ       ??test2_21
     82                test_res = 1;
   \   0000A3   7E01         MOV       R6,#0x1
   \   0000A5   7F00         MOV       R7,#0x0
   \                     ??test2_21:
   \   0000A7   08           INC       R0
   \   0000A8   E8           MOV       A,R0
   \   0000A9   70B8         JNZ       ??test2_19
   \   0000AB   09           INC       R1
   \   0000AC   80B5         SJMP      ??test2_19
     83          
     84          // Все слоты должны быть разные 
     85            for(int i = 1; i < 20; i++)
   \                     ??test2_20:
   \   0000AE   7801         MOV       R0,#0x1
   \   0000B0   7900         MOV       R1,#0x0
   \                     ??test2_22:
   \   0000B2   C3           CLR       C
   \   0000B3   E8           MOV       A,R0
   \   0000B4   9414         SUBB      A,#0x14
   \   0000B6   E9           MOV       A,R1
   \   0000B7   9400         SUBB      A,#0x0
   \   0000B9   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0000BB   65D0         XRL       A,PSW
   \   0000BD   33           RLC       A
   \   0000BE   5078         JNC       ??test2_23
     86              if (all[i] == all[i - 1])
   \   0000C0   E8           MOV       A,R0
   \   0000C1   FA           MOV       R2,A
   \   0000C2   E9           MOV       A,R1
   \   0000C3   FB           MOV       R3,A
   \   0000C4   EA           MOV       A,R2
   \   0000C5   75F002       MOV       B,#0x2
   \   0000C8   A4           MUL       AB
   \   0000C9   CA           XCH       A,R2
   \   0000CA   ACF0         MOV       R4,B
   \   0000CC   75F000       MOV       B,#0x0
   \   0000CF   A4           MUL       AB
   \   0000D0   2C           ADD       A,R4
   \   0000D1   FC           MOV       R4,A
   \   0000D2   75F002       MOV       B,#0x2
   \   0000D5   EB           MOV       A,R3
   \   0000D6   A4           MUL       AB
   \   0000D7   2C           ADD       A,R4
   \   0000D8   FB           MOV       R3,A
   \   0000D9   90FFD7       MOV       DPTR,#-0x29
   \   0000DC   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000DF   E582         MOV       A,DPL
   \   0000E1   2A           ADD       A,R2
   \   0000E2   F582         MOV       DPL,A
   \   0000E4   E583         MOV       A,DPH
   \   0000E6   3B           ADDC      A,R3
   \   0000E7   F583         MOV       DPH,A
   \   0000E9   E0           MOVX      A,@DPTR
   \   0000EA   FC           MOV       R4,A
   \   0000EB   A3           INC       DPTR
   \   0000EC   E0           MOVX      A,@DPTR
   \   0000ED   FD           MOV       R5,A
   \   0000EE   E8           MOV       A,R0
   \   0000EF   FA           MOV       R2,A
   \   0000F0   E9           MOV       A,R1
   \   0000F1   FB           MOV       R3,A
   \   0000F2   EA           MOV       A,R2
   \   0000F3   75F002       MOV       B,#0x2
   \   0000F6   A4           MUL       AB
   \   0000F7   CA           XCH       A,R2
   \   0000F8   85F0..       MOV       ?V0,B
   \   0000FB   75F000       MOV       B,#0x0
   \   0000FE   A4           MUL       AB
   \   0000FF   25..         ADD       A,?V0
   \   000101   F5..         MOV       ?V0,A
   \   000103   75F002       MOV       B,#0x2
   \   000106   EB           MOV       A,R3
   \   000107   A4           MUL       AB
   \   000108   25..         ADD       A,?V0
   \   00010A   FB           MOV       R3,A
   \   00010B   90FFD7       MOV       DPTR,#-0x29
   \   00010E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000111   E582         MOV       A,DPL
   \   000113   2A           ADD       A,R2
   \   000114   FA           MOV       R2,A
   \   000115   E583         MOV       A,DPH
   \   000117   3B           ADDC      A,R3
   \   000118   FB           MOV       R3,A
   \   000119   EA           MOV       A,R2
   \   00011A   24FE         ADD       A,#-0x2
   \   00011C   F582         MOV       DPL,A
   \   00011E   EB           MOV       A,R3
   \   00011F   34FF         ADDC      A,#-0x1
   \   000121   F583         MOV       DPH,A
   \   000123   E0           MOVX      A,@DPTR
   \   000124   6C           XRL       A,R4
   \   000125   7003         JNZ       ??test2_24
   \   000127   A3           INC       DPTR
   \   000128   E0           MOVX      A,@DPTR
   \   000129   6D           XRL       A,R5
   \                     ??test2_24:
   \   00012A   7004         JNZ       ??test2_25
     87                test_res = 2;   
   \   00012C   7E02         MOV       R6,#0x2
   \   00012E   7F00         MOV       R7,#0x0
   \                     ??test2_25:
   \   000130   08           INC       R0
   \   000131   E8           MOV       A,R0
   \   000132   7001         JNZ       ??test2_26
   \   000134   09           INC       R1
   \                     ??test2_26:
   \   000135   02....       LJMP      ??test2_22 & 0xFFFF
     88            
     89            if (FR_busy() != 20)
   \                     ??test2_23:
   \   000138                ; Setup parameters for call to function FR_busy
   \   000138   12....       LCALL     `??FR_busy::?relay`; Banked call to: FR_busy
   \   00013B   8A..         MOV       ?V0,R2
   \   00013D   8B..         MOV       ?V1,R3
   \   00013F   7414         MOV       A,#0x14
   \   000141   65..         XRL       A,?V0
   \   000143   7004         JNZ       ??test2_27
   \   000145   7400         MOV       A,#0x0
   \   000147   65..         XRL       A,?V1
   \                     ??test2_27:
   \   000149   6004         JZ        ??test2_28
     90              test_res = 3;
   \   00014B   7E03         MOV       R6,#0x3
   \   00014D   7F00         MOV       R7,#0x0
     91            
     92            if (FR_available() != 0)
   \                     ??test2_28:
   \   00014F                ; Setup parameters for call to function FR_available
   \   00014F   12....       LCALL     `??FR_available::?relay`; Banked call to: FR_available
   \   000152   8A..         MOV       ?V0,R2
   \   000154   8B..         MOV       ?V1,R3
   \   000156   E5..         MOV       A,?V0
   \   000158   45..         ORL       A,?V1
   \   00015A   6004         JZ        ??test2_29
     93              test_res = 4;
   \   00015C   7E04         MOV       R6,#0x4
   \   00015E   7F00         MOV       R7,#0x0
     94           
     95            // Выделяемм еще один. он должен быть NULL
     96            struct frame* fr = FR_create();
   \                     ??test2_29:
   \   000160                ; Setup parameters for call to function FR_create
   \   000160   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   000163   8A..         MOV       ?V0,R2
   \   000165   8B..         MOV       ?V1,R3
   \   000167   85....       MOV       ?V2,?V0
   \   00016A   85....       MOV       ?V3,?V1
     97            if (fr)
   \   00016D   E5..         MOV       A,?V2
   \   00016F   45..         ORL       A,?V3
   \   000171   6004         JZ        ??test2_30
     98              test_res = 5;
   \   000173   7E05         MOV       R6,#0x5
   \   000175   7F00         MOV       R7,#0x0
     99            
    100             if (FR_busy() != 20)
   \                     ??test2_30:
   \   000177                ; Setup parameters for call to function FR_busy
   \   000177   12....       LCALL     `??FR_busy::?relay`; Banked call to: FR_busy
   \   00017A   8A..         MOV       ?V0,R2
   \   00017C   8B..         MOV       ?V1,R3
   \   00017E   7414         MOV       A,#0x14
   \   000180   65..         XRL       A,?V0
   \   000182   7004         JNZ       ??test2_31
   \   000184   7400         MOV       A,#0x0
   \   000186   65..         XRL       A,?V1
   \                     ??test2_31:
   \   000188   6004         JZ        ??test2_32
    101              test_res = 6;
   \   00018A   7E06         MOV       R6,#0x6
   \   00018C   7F00         MOV       R7,#0x0
    102            
    103            if (FR_available() != 0)
   \                     ??test2_32:
   \   00018E                ; Setup parameters for call to function FR_available
   \   00018E   12....       LCALL     `??FR_available::?relay`; Banked call to: FR_available
   \   000191   8A..         MOV       ?V0,R2
   \   000193   8B..         MOV       ?V1,R3
   \   000195   E5..         MOV       A,?V0
   \   000197   45..         ORL       A,?V1
   \   000199   6004         JZ        ??test2_33
    104              test_res = 7; 
   \   00019B   7E07         MOV       R6,#0x7
   \   00019D   7F00         MOV       R7,#0x0
    105            
    106          // Удаляем все что создали и контролим результат
    107            for (int i = 0; i < 20; i++)
   \                     ??test2_33:
   \   00019F   75..00       MOV       ?V0,#0x0
   \   0001A2   75..00       MOV       ?V1,#0x0
   \                     ??test2_34:
   \   0001A5   C3           CLR       C
   \   0001A6   E5..         MOV       A,?V0
   \   0001A8   9414         SUBB      A,#0x14
   \   0001AA   E5..         MOV       A,?V1
   \   0001AC   9400         SUBB      A,#0x0
   \   0001AE   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0001B0   65D0         XRL       A,PSW
   \   0001B2   33           RLC       A
   \   0001B3   5041         JNC       ??test2_35
    108              if (!FR_delete(all[i]))
   \   0001B5                ; Setup parameters for call to function FR_delete
   \   0001B5   A8..         MOV       R0,?V0
   \   0001B7   A9..         MOV       R1,?V1
   \   0001B9   E8           MOV       A,R0
   \   0001BA   75F002       MOV       B,#0x2
   \   0001BD   A4           MUL       AB
   \   0001BE   C8           XCH       A,R0
   \   0001BF   AAF0         MOV       R2,B
   \   0001C1   75F000       MOV       B,#0x0
   \   0001C4   A4           MUL       AB
   \   0001C5   2A           ADD       A,R2
   \   0001C6   FA           MOV       R2,A
   \   0001C7   75F002       MOV       B,#0x2
   \   0001CA   E9           MOV       A,R1
   \   0001CB   A4           MUL       AB
   \   0001CC   2A           ADD       A,R2
   \   0001CD   F9           MOV       R1,A
   \   0001CE   90FFD7       MOV       DPTR,#-0x29
   \   0001D1   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001D4   E582         MOV       A,DPL
   \   0001D6   28           ADD       A,R0
   \   0001D7   F582         MOV       DPL,A
   \   0001D9   E583         MOV       A,DPH
   \   0001DB   39           ADDC      A,R1
   \   0001DC   F583         MOV       DPH,A
   \   0001DE   E0           MOVX      A,@DPTR
   \   0001DF   FA           MOV       R2,A
   \   0001E0   A3           INC       DPTR
   \   0001E1   E0           MOVX      A,@DPTR
   \   0001E2   FB           MOV       R3,A
   \   0001E3   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
   \   0001E6   4004         JC        ??test2_36
    109                test_res = 8;   
   \   0001E8   7E08         MOV       R6,#0x8
   \   0001EA   7F00         MOV       R7,#0x0
   \                     ??test2_36:
   \   0001EC   05..         INC       ?V0
   \   0001EE   E5..         MOV       A,?V0
   \   0001F0   70B3         JNZ       ??test2_34
   \   0001F2   05..         INC       ?V1
   \   0001F4   80AF         SJMP      ??test2_34
    110          
    111             if (FR_busy() != 0)
   \                     ??test2_35:
   \   0001F6                ; Setup parameters for call to function FR_busy
   \   0001F6   12....       LCALL     `??FR_busy::?relay`; Banked call to: FR_busy
   \   0001F9   8A..         MOV       ?V0,R2
   \   0001FB   8B..         MOV       ?V1,R3
   \   0001FD   E5..         MOV       A,?V0
   \   0001FF   45..         ORL       A,?V1
   \   000201   6004         JZ        ??test2_37
    112              test_res = 9;
   \   000203   7E09         MOV       R6,#0x9
   \   000205   7F00         MOV       R7,#0x0
    113            
    114            if (FR_available() != 20)
   \                     ??test2_37:
   \   000207                ; Setup parameters for call to function FR_available
   \   000207   12....       LCALL     `??FR_available::?relay`; Banked call to: FR_available
   \   00020A   8A..         MOV       ?V0,R2
   \   00020C   8B..         MOV       ?V1,R3
   \   00020E   7414         MOV       A,#0x14
   \   000210   65..         XRL       A,?V0
   \   000212   7004         JNZ       ??test2_38
   \   000214   7400         MOV       A,#0x0
   \   000216   65..         XRL       A,?V1
   \                     ??test2_38:
   \   000218   6004         JZ        ??test2_39
    115              test_res = 10;  
   \   00021A   7E0A         MOV       R6,#0xa
   \   00021C   7F00         MOV       R7,#0x0
    116            
    117          // Еще разок пробуем все удалить 
    118            for (int i = 0; i < 20; i++)
   \                     ??test2_39:
   \   00021E   75..00       MOV       ?V0,#0x0
   \   000221   75..00       MOV       ?V1,#0x0
   \                     ??test2_40:
   \   000224   C3           CLR       C
   \   000225   E5..         MOV       A,?V0
   \   000227   9414         SUBB      A,#0x14
   \   000229   E5..         MOV       A,?V1
   \   00022B   9400         SUBB      A,#0x0
   \   00022D   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00022F   65D0         XRL       A,PSW
   \   000231   33           RLC       A
   \   000232   5041         JNC       ??test2_41
    119              if (FR_delete(all[i]))
   \   000234                ; Setup parameters for call to function FR_delete
   \   000234   A8..         MOV       R0,?V0
   \   000236   A9..         MOV       R1,?V1
   \   000238   E8           MOV       A,R0
   \   000239   75F002       MOV       B,#0x2
   \   00023C   A4           MUL       AB
   \   00023D   C8           XCH       A,R0
   \   00023E   AAF0         MOV       R2,B
   \   000240   75F000       MOV       B,#0x0
   \   000243   A4           MUL       AB
   \   000244   2A           ADD       A,R2
   \   000245   FA           MOV       R2,A
   \   000246   75F002       MOV       B,#0x2
   \   000249   E9           MOV       A,R1
   \   00024A   A4           MUL       AB
   \   00024B   2A           ADD       A,R2
   \   00024C   F9           MOV       R1,A
   \   00024D   90FFD7       MOV       DPTR,#-0x29
   \   000250   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000253   E582         MOV       A,DPL
   \   000255   28           ADD       A,R0
   \   000256   F582         MOV       DPL,A
   \   000258   E583         MOV       A,DPH
   \   00025A   39           ADDC      A,R1
   \   00025B   F583         MOV       DPH,A
   \   00025D   E0           MOVX      A,@DPTR
   \   00025E   FA           MOV       R2,A
   \   00025F   A3           INC       DPTR
   \   000260   E0           MOVX      A,@DPTR
   \   000261   FB           MOV       R3,A
   \   000262   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
   \   000265   5004         JNC       ??test2_42
    120                test_res = 11; 
   \   000267   7E0B         MOV       R6,#0xb
   \   000269   7F00         MOV       R7,#0x0
   \                     ??test2_42:
   \   00026B   05..         INC       ?V0
   \   00026D   E5..         MOV       A,?V0
   \   00026F   70B3         JNZ       ??test2_40
   \   000271   05..         INC       ?V1
   \   000273   80AF         SJMP      ??test2_40
    121            
    122             if (FR_busy() != 0)
   \                     ??test2_41:
   \   000275                ; Setup parameters for call to function FR_busy
   \   000275   12....       LCALL     `??FR_busy::?relay`; Banked call to: FR_busy
   \   000278   8A..         MOV       ?V0,R2
   \   00027A   8B..         MOV       ?V1,R3
   \   00027C   E5..         MOV       A,?V0
   \   00027E   45..         ORL       A,?V1
   \   000280   6004         JZ        ??test2_43
    123              test_res = 12;
   \   000282   7E0C         MOV       R6,#0xc
   \   000284   7F00         MOV       R7,#0x0
    124            
    125            if (FR_available() != 20)
   \                     ??test2_43:
   \   000286                ; Setup parameters for call to function FR_available
   \   000286   12....       LCALL     `??FR_available::?relay`; Banked call to: FR_available
   \   000289   8A..         MOV       ?V0,R2
   \   00028B   8B..         MOV       ?V1,R3
   \   00028D   7414         MOV       A,#0x14
   \   00028F   65..         XRL       A,?V0
   \   000291   7004         JNZ       ??test2_44
   \   000293   7400         MOV       A,#0x0
   \   000295   65..         XRL       A,?V1
   \                     ??test2_44:
   \   000297   6004         JZ        ??test2_45
    126              test_res = 13;
   \   000299   7E0D         MOV       R6,#0xd
   \   00029B   7F00         MOV       R7,#0x0
    127            
    128            return test_res;
   \                     ??test2_45:
   \   00029D   EE           MOV       A,R6
   \   00029E   FA           MOV       R2,A
   \   00029F   EF           MOV       A,R7
   \   0002A0   FB           MOV       R3,A
   \   0002A1   74D8         MOV       A,#-0x28
   \   0002A3   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0002A6   7F04         MOV       R7,#0x4
   \   0002A8   02....       LJMP      ?BANKED_LEAVE_SP
    129          }
    130          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    131          static int test1(void){
   \                     ??test1_1:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
    132            int test_res = 0;
   \   000005   7E00         MOV       R6,#0x0
   \   000007   7F00         MOV       R7,#0x0
    133            
    134            if (FR_busy() != 0)
   \   000009                ; Setup parameters for call to function FR_busy
   \   000009   12....       LCALL     `??FR_busy::?relay`; Banked call to: FR_busy
   \   00000C   8A..         MOV       ?V0,R2
   \   00000E   8B..         MOV       ?V1,R3
   \   000010   E5..         MOV       A,?V0
   \   000012   45..         ORL       A,?V1
   \   000014   6004         JZ        ??test1_17
    135              test_res = 1;
   \   000016   7E01         MOV       R6,#0x1
   \   000018   7F00         MOV       R7,#0x0
    136            
    137            if (FR_available() != 20)
   \                     ??test1_17:
   \   00001A                ; Setup parameters for call to function FR_available
   \   00001A   12....       LCALL     `??FR_available::?relay`; Banked call to: FR_available
   \   00001D   8A..         MOV       ?V0,R2
   \   00001F   8B..         MOV       ?V1,R3
   \   000021   7414         MOV       A,#0x14
   \   000023   65..         XRL       A,?V0
   \   000025   7004         JNZ       ??test1_18
   \   000027   7400         MOV       A,#0x0
   \   000029   65..         XRL       A,?V1
   \                     ??test1_18:
   \   00002B   6004         JZ        ??test1_19
    138              test_res = 2;
   \   00002D   7E02         MOV       R6,#0x2
   \   00002F   7F00         MOV       R7,#0x0
    139            
    140            struct frame *fr = FR_create();
   \                     ??test1_19:
   \   000031                ; Setup parameters for call to function FR_create
   \   000031   12....       LCALL     `??FR_create::?relay`; Banked call to: FR_create
   \   000034   8A..         MOV       ?V2,R2
   \   000036   8B..         MOV       ?V3,R3
   \   000038   85....       MOV       ?V0,?V2
   \   00003B   85....       MOV       ?V1,?V3
    141            
    142            if (!fr)
   \   00003E   E5..         MOV       A,?V0
   \   000040   45..         ORL       A,?V1
   \   000042   7004         JNZ       ??test1_20
    143              test_res = 3;
   \   000044   7E03         MOV       R6,#0x3
   \   000046   7F00         MOV       R7,#0x0
    144            
    145            if (FR_busy() != 1)
   \                     ??test1_20:
   \   000048                ; Setup parameters for call to function FR_busy
   \   000048   12....       LCALL     `??FR_busy::?relay`; Banked call to: FR_busy
   \   00004B   8A..         MOV       ?V2,R2
   \   00004D   8B..         MOV       ?V3,R3
   \   00004F   7401         MOV       A,#0x1
   \   000051   65..         XRL       A,?V2
   \   000053   7004         JNZ       ??test1_21
   \   000055   7400         MOV       A,#0x0
   \   000057   65..         XRL       A,?V3
   \                     ??test1_21:
   \   000059   6004         JZ        ??test1_22
    146              test_res = 4;
   \   00005B   7E04         MOV       R6,#0x4
   \   00005D   7F00         MOV       R7,#0x0
    147            
    148            if (FR_available() != 19)
   \                     ??test1_22:
   \   00005F                ; Setup parameters for call to function FR_available
   \   00005F   12....       LCALL     `??FR_available::?relay`; Banked call to: FR_available
   \   000062   8A..         MOV       ?V2,R2
   \   000064   8B..         MOV       ?V3,R3
   \   000066   7413         MOV       A,#0x13
   \   000068   65..         XRL       A,?V2
   \   00006A   7004         JNZ       ??test1_23
   \   00006C   7400         MOV       A,#0x0
   \   00006E   65..         XRL       A,?V3
   \                     ??test1_23:
   \   000070   6004         JZ        ??test1_24
    149              test_res = 5;  
   \   000072   7E05         MOV       R6,#0x5
   \   000074   7F00         MOV       R7,#0x0
    150            
    151            if (!FR_delete(fr))
   \                     ??test1_24:
   \   000076                ; Setup parameters for call to function FR_delete
   \   000076   AA..         MOV       R2,?V0
   \   000078   AB..         MOV       R3,?V1
   \   00007A   12....       LCALL     `??FR_delete::?relay`; Banked call to: FR_delete
   \   00007D   4004         JC        ??test1_25
    152              test_res = 6;
   \   00007F   7E06         MOV       R6,#0x6
   \   000081   7F00         MOV       R7,#0x0
    153            
    154            if (FR_busy() != 0)
   \                     ??test1_25:
   \   000083                ; Setup parameters for call to function FR_busy
   \   000083   12....       LCALL     `??FR_busy::?relay`; Banked call to: FR_busy
   \   000086   8A..         MOV       ?V2,R2
   \   000088   8B..         MOV       ?V3,R3
   \   00008A   E5..         MOV       A,?V2
   \   00008C   45..         ORL       A,?V3
   \   00008E   6004         JZ        ??test1_26
    155              test_res = 7;
   \   000090   7E07         MOV       R6,#0x7
   \   000092   7F00         MOV       R7,#0x0
    156            
    157            if (FR_available() != 20)
   \                     ??test1_26:
   \   000094                ; Setup parameters for call to function FR_available
   \   000094   12....       LCALL     `??FR_available::?relay`; Banked call to: FR_available
   \   000097   8A..         MOV       ?V2,R2
   \   000099   8B..         MOV       ?V3,R3
   \   00009B   7414         MOV       A,#0x14
   \   00009D   65..         XRL       A,?V2
   \   00009F   7004         JNZ       ??test1_27
   \   0000A1   7400         MOV       A,#0x0
   \   0000A3   65..         XRL       A,?V3
   \                     ??test1_27:
   \   0000A5   6004         JZ        ??test1_28
    158              test_res = 8;   
   \   0000A7   7E08         MOV       R6,#0x8
   \   0000A9   7F00         MOV       R7,#0x0
    159            
    160            return test_res;
   \                     ??test1_28:
   \   0000AB   EE           MOV       A,R6
   \   0000AC   FA           MOV       R2,A
   \   0000AD   EF           MOV       A,R7
   \   0000AE   FB           MOV       R3,A
   \   0000AF   7F04         MOV       R7,#0x4
   \   0000B1   02....       LJMP      ?BANKED_LEAVE_SP
    161          }
E:\Neocore\Hardware\PRJ Test\u_macros.c
      1          #include "utest.h"
      2          static int test1(void);
      3          static int test2(void);

   \                                 In  segment XDATA_I, align 1, keep-with-next
      4          struct test_unit UT_MACR_1 = {.name = "MACROS: EXCEPTIOS", .fun = test1};
   \                     UT_MACR_1:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_MACR_1>`
   \   000022                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
      5          struct test_unit UT_MACR_2 = {.name = "MACROS: EXCEPTIOS", .fun = test2};
   \                     UT_MACR_2:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_MACR_2>`
   \   000022                REQUIRE __INIT_XDATA_I
      6          
      7          
      8          #include "stdint.h"
      9          #include "macros.h"
     10          #include "stdbool.h"
     11          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     12          static int test2(void){
   \                     ??test2_2:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004   C0..         PUSH      ?VB
   \   000006                ; Saved register size: 3
   \   000006                ; Auto size: 50
   \   000006   7432         MOV       A,#0x32
   \   000008   12....       LCALL     ?ALLOC_EXT_STACK8
     13            bool catched = false;
   \   00000B   C2..         CLR       ?VB.0
     14            bool finalyed = false;
   \   00000D   C2..         CLR       ?VB.1
     15            bool noexe = true;
   \   00000F   D2..         SETB      ?VB.2
     16            
     17            TRY{
   \   000011   90FFCD       MOV       DPTR,#-0x33
   \   000014   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000017   7408         MOV       A,#0x8
   \   000019                REQUIRE ?V7
   \   000019   12....       LCALL     ?SETJMP_XDATA
   \   00001C   8A..         MOV       ?V0,R2
   \   00001E   8B..         MOV       ?V1,R3
   \   000020   78..         MOV       R0,#?V0
   \   000022   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for test2>_0`:
   \   000025   0000         DW        0
   \   000027   01           DB        1
   \   000028   ....         DW        ??test2_46
   \   00002A   ....         DW        ??test2_47
   \   00002C   ....         DW        ??test2_48
     18              THROW(2);
   \                     ??test2_47:
   \   00002E   7A02         MOV       R2,#0x2
   \   000030   7B00         MOV       R3,#0x0
   \   000032   90FFCD       MOV       DPTR,#-0x33
   \   000035   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000038   7408         MOV       A,#0x8
   \   00003A                REQUIRE ?V7
   \   00003A   02....       LJMP      ?LONGJMP_XDATA
     19              noexe = false;
                     ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRJ Test\u_macros.c"
     20            }
     21            CATCH(1){
     22              catched = true;
   \                     ??test2_48:
   \   00003D   D2..         SETB      ?VB.0
     23            }
     24            FINALLY{
     25              finalyed = true;
   \                     ??test2_46:
   \   00003F   D2..         SETB      ?VB.1
     26            }
     27            ETRY;  
     28            
     29            if (!noexe)
   \   000041   A2..         MOV       C,?VB.2
   \   000043   4006         JC        ??test2_49
     30              return 1;
   \   000045   7A01         MOV       R2,#0x1
   \   000047   7B00         MOV       R3,#0x0
   \   000049   8018         SJMP      ??test2_50
     31          
     32            if (catched)
   \                     ??test2_49:
   \   00004B   A2..         MOV       C,?VB.0
   \   00004D   5006         JNC       ??test2_51
     33              return 2;  
   \   00004F   7A02         MOV       R2,#0x2
   \   000051   7B00         MOV       R3,#0x0
   \   000053   800E         SJMP      ??test2_50
     34          
     35            if (!finalyed)
   \                     ??test2_51:
   \   000055   A2..         MOV       C,?VB.1
   \   000057   4006         JC        ??test2_52
     36              return 3;
   \   000059   7A03         MOV       R2,#0x3
   \   00005B   7B00         MOV       R3,#0x0
   \   00005D   8004         SJMP      ??test2_50
     37              
     38            return 0;
   \                     ??test2_52:
   \   00005F   7A00         MOV       R2,#0x0
   \   000061   7B00         MOV       R3,#0x0
   \                     ??test2_50:
   \   000063   74CE         MOV       A,#-0x32
   \   000065   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000068   D0..         POP       ?VB
   \   00006A   D0..         POP       ?V1
   \   00006C   D0..         POP       ?V0
   \   00006E   02....       LJMP      ?BRET
     39          }
     40          
     41          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     42          static int test1(void){
   \                     ??test1_2:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004   C0..         PUSH      ?VB
   \   000006                ; Saved register size: 3
   \   000006                ; Auto size: 50
   \   000006   7432         MOV       A,#0x32
   \   000008   12....       LCALL     ?ALLOC_EXT_STACK8
     43            bool catched = false;
   \   00000B   C2..         CLR       ?VB.0
     44            bool finalyed = false;
   \   00000D   C2..         CLR       ?VB.1
     45            bool noexe = true;
   \   00000F   D2..         SETB      ?VB.2
     46            
     47            TRY{
   \   000011   90FFCD       MOV       DPTR,#-0x33
   \   000014   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000017   7408         MOV       A,#0x8
   \   000019                REQUIRE ?V7
   \   000019   12....       LCALL     ?SETJMP_XDATA
   \   00001C   8A..         MOV       ?V0,R2
   \   00001E   8B..         MOV       ?V1,R3
   \   000020   78..         MOV       R0,#?V0
   \   000022   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for test1>_0`:
   \   000025   0000         DW        0
   \   000027   01           DB        1
   \   000028   ....         DW        ??test1_29
   \   00002A   ....         DW        ??test1_30
   \   00002C   ....         DW        ??test1_31
     48              THROW(1);
   \                     ??test1_30:
   \   00002E   7A01         MOV       R2,#0x1
   \   000030   7B00         MOV       R3,#0x0
   \   000032   90FFCD       MOV       DPTR,#-0x33
   \   000035   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000038   7408         MOV       A,#0x8
   \   00003A                REQUIRE ?V7
   \   00003A   02....       LJMP      ?LONGJMP_XDATA
     49              noexe = false;
                     ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRJ Test\u_macros.c"

  static void SW_Init(void){
              ^
"E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c",34  Warning[Pe177]: function
          "SW_Init" was declared but never referenced
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\STACK_CORE_SRC\alarm_timer.c"

  static void u_test(void){
              ^
"E:\Neocore\Hardware\PRJ Test\u_debug.c",5  Warning[Pe177]: function "u_test"
          was declared but never referenced
          detected during compilation of secondary translation unit
                    "E:\Neocore\Hardware\PRJ Test\u_debug.c"
     50            }
     51            CATCH(1){
     52              catched = true;
   \                     ??test1_31:
   \   00003D   D2..         SETB      ?VB.0
     53            }
     54            FINALLY{
     55              finalyed = true;
   \                     ??test1_29:
   \   00003F   D2..         SETB      ?VB.1
     56            }
     57            ETRY;  
     58            
     59            if (!noexe)
   \   000041   A2..         MOV       C,?VB.2
   \   000043   4006         JC        ??test1_32
     60              return 1;
   \   000045   7A01         MOV       R2,#0x1
   \   000047   7B00         MOV       R3,#0x0
   \   000049   8018         SJMP      ??test1_33
     61          
     62            if (!catched)
   \                     ??test1_32:
   \   00004B   A2..         MOV       C,?VB.0
   \   00004D   4006         JC        ??test1_34
     63              return 2;  
   \   00004F   7A02         MOV       R2,#0x2
   \   000051   7B00         MOV       R3,#0x0
   \   000053   800E         SJMP      ??test1_33
     64          
     65            if (!finalyed)
   \                     ??test1_34:
   \   000055   A2..         MOV       C,?VB.1
   \   000057   4006         JC        ??test1_35
     66              return 3;
   \   000059   7A03         MOV       R2,#0x3
   \   00005B   7B00         MOV       R3,#0x0
   \   00005D   8004         SJMP      ??test1_33
     67              
     68            return 0;
   \                     ??test1_35:
   \   00005F   7A00         MOV       R2,#0x0
   \   000061   7B00         MOV       R3,#0x0
   \                     ??test1_33:
   \   000063   74CE         MOV       A,#-0x32
   \   000065   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000068   D0..         POP       ?VB
   \   00006A   D0..         POP       ?V1
   \   00006C   D0..         POP       ?V0
   \   00006E   02....       LJMP      ?BRET
     69          }
     70          
     71          
E:\Neocore\Hardware\PRJ Test\u_mem_slots.c
      1          #include "utest.h"
      2          #include "stddef.h"
      3          
      4          static int test1(void);
      5          static int test2(void);
      6          static int test3(void);
      7          

   \                                 In  segment XDATA_I, align 1, keep-with-next
      8          struct test_unit UT_MS_1 = {.name = "MS:create-delete", .fun = test1};
   \                     UT_MS_1:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_MS_1>`
   \   000022                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
      9          struct test_unit UT_MS_2 = {.name = "MS:create-full", .fun = test2};
   \                     UT_MS_2:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_MS_2>`
   \   000022                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
     10          struct test_unit UT_MS_3 = {.name = "MS:zone-check", .fun = test3};
   \                     UT_MS_3:
   \   000000                DS 34
   \   000022                REQUIRE `?<Initializer for UT_MS_3>`
   \   000022                REQUIRE __INIT_XDATA_I
     11          
     12          #include "mem_slots.h"
     13          
     14          //int SL_zone_check();
     15          //int SL_available();
     16          //int SL_busy();
     17          //bool SL_free(char *buff);
     18          //char* SL_alloc(void);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     19          static int test3(void){
   \                     ??test3_2:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
     20            int test_res = 0;
   \   000005   7E00         MOV       R6,#0x0
   \   000007   7F00         MOV       R7,#0x0
     21            
     22            if (!SL_zone_check())
   \   000009                ; Setup parameters for call to function SL_zone_check
   \   000009   12....       LCALL     `??SL_zone_check::?relay`; Banked call to: SL_zone_check
   \   00000C   8A..         MOV       ?V0,R2
   \   00000E   8B..         MOV       ?V1,R3
   \   000010   E5..         MOV       A,?V0
   \   000012   45..         ORL       A,?V1
   \   000014   7004         JNZ       ??test3_47
     23              test_res = 1;
   \   000016   7E01         MOV       R6,#0x1
   \   000018   7F00         MOV       R7,#0x0
     24            
     25            // Нарушаем границу во втором слоте
     26            char *sl1 = SL_alloc();
   \                     ??test3_47:
   \   00001A                ; Setup parameters for call to function SL_alloc
   \   00001A   12....       LCALL     `??SL_alloc::?relay`; Banked call to: SL_alloc
   \   00001D   8A..         MOV       ?V0,R2
   \   00001F   8B..         MOV       ?V1,R3
   \   000021   85....       MOV       ?V6,?V0
   \   000024   85....       MOV       ?V7,?V1
     27            char *sl2 = SL_alloc();
   \   000027                ; Setup parameters for call to function SL_alloc
   \   000027   12....       LCALL     `??SL_alloc::?relay`; Banked call to: SL_alloc
   \   00002A   8A..         MOV       ?V0,R2
   \   00002C   8B..         MOV       ?V1,R3
   \   00002E   85....       MOV       ?V2,?V0
   \   000031   85....       MOV       ?V3,?V1
     28            char *sl3 = SL_alloc();
   \   000034                ; Setup parameters for call to function SL_alloc
   \   000034   12....       LCALL     `??SL_alloc::?relay`; Banked call to: SL_alloc
   \   000037   8A..         MOV       ?V4,R2
   \   000039   8B..         MOV       ?V5,R3
   \   00003B   85....       MOV       ?V0,?V4
   \   00003E   85....       MOV       ?V1,?V5
     29            for (int i = 0; i < 180; i++)
   \   000041   7800         MOV       R0,#0x0
   \   000043   7900         MOV       R1,#0x0
   \                     ??test3_48:
   \   000045   C3           CLR       C
   \   000046   E8           MOV       A,R0
   \   000047   94B4         SUBB      A,#-0x4c
   \   000049   E9           MOV       A,R1
   \   00004A   9400         SUBB      A,#0x0
   \   00004C   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00004E   65D0         XRL       A,PSW
   \   000050   33           RLC       A
   \   000051   5014         JNC       ??test3_49
     30              sl3[i] = 0x55;
   \   000053   E5..         MOV       A,?V0
   \   000055   28           ADD       A,R0
   \   000056   F582         MOV       DPL,A
   \   000058   E5..         MOV       A,?V1
   \   00005A   39           ADDC      A,R1
   \   00005B   F583         MOV       DPH,A
   \   00005D   7455         MOV       A,#0x55
   \   00005F   F0           MOVX      @DPTR,A
   \   000060   08           INC       R0
   \   000061   E8           MOV       A,R0
   \   000062   70E1         JNZ       ??test3_48
   \   000064   09           INC       R1
   \   000065   80DE         SJMP      ??test3_48
     31            
     32            if (SL_zone_check()!=2)
   \                     ??test3_49:
   \   000067                ; Setup parameters for call to function SL_zone_check
   \   000067   12....       LCALL     `??SL_zone_check::?relay`; Banked call to: SL_zone_check
   \   00006A   8A..         MOV       ?V4,R2
   \   00006C   8B..         MOV       ?V5,R3
   \   00006E   7402         MOV       A,#0x2
   \   000070   65..         XRL       A,?V4
   \   000072   7004         JNZ       ??test3_50
   \   000074   7400         MOV       A,#0x0
   \   000076   65..         XRL       A,?V5
   \                     ??test3_50:
   \   000078   6004         JZ        ??test3_51
     33              test_res = 2;  
   \   00007A   7E02         MOV       R6,#0x2
   \   00007C   7F00         MOV       R7,#0x0
     34            
     35            return test_res;
   \                     ??test3_51:
   \   00007E   EE           MOV       A,R6
   \   00007F   FA           MOV       R2,A
   \   000080   EF           MOV       A,R7
   \   000081   FB           MOV       R3,A
   \   000082   7F08         MOV       R7,#0x8
   \   000084   02....       LJMP      ?BANKED_LEAVE_SP
     36          }
     37          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     38          static int test2(void){
   \                     ??test2_3:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 40
   \   000005   7428         MOV       A,#0x28
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
     39          // Используем полностью все фреймы
     40            char *all[20];
     41            int test_res = 0;
   \   00000A   7E00         MOV       R6,#0x0
   \   00000C   7F00         MOV       R7,#0x0
     42            
     43            for (int i = 0; i < 20; i++)
   \   00000E   75..00       MOV       ?V0,#0x0
   \   000011   75..00       MOV       ?V1,#0x0
   \                     ??test2_53:
   \   000014   C3           CLR       C
   \   000015   E5..         MOV       A,?V0
   \   000017   9414         SUBB      A,#0x14
   \   000019   E5..         MOV       A,?V1
   \   00001B   9400         SUBB      A,#0x0
   \   00001D   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00001F   65D0         XRL       A,PSW
   \   000021   33           RLC       A
   \   000022   503B         JNC       ??test2_54
     44              all[i] = SL_alloc();
   \   000024                ; Setup parameters for call to function SL_alloc
   \   000024   12....       LCALL     `??SL_alloc::?relay`; Banked call to: SL_alloc
   \   000027   A8..         MOV       R0,?V0
   \   000029   A9..         MOV       R1,?V1
   \   00002B   E8           MOV       A,R0
   \   00002C   75F002       MOV       B,#0x2
   \   00002F   A4           MUL       AB
   \   000030   C8           XCH       A,R0
   \   000031   ACF0         MOV       R4,B
   \   000033   75F000       MOV       B,#0x0
   \   000036   A4           MUL       AB
   \   000037   2C           ADD       A,R4
   \   000038   FC           MOV       R4,A
   \   000039   75F002       MOV       B,#0x2
   \   00003C   E9           MOV       A,R1
   \   00003D   A4           MUL       AB
   \   00003E   2C           ADD       A,R4
   \   00003F   F9           MOV       R1,A
   \   000040   90FFD7       MOV       DPTR,#-0x29
   \   000043   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000046   E582         MOV       A,DPL
   \   000048   28           ADD       A,R0
   \   000049   F582         MOV       DPL,A
   \   00004B   E583         MOV       A,DPH
   \   00004D   39           ADDC      A,R1
   \   00004E   F583         MOV       DPH,A
   \   000050   EA           MOV       A,R2
   \   000051   F0           MOVX      @DPTR,A
   \   000052   A3           INC       DPTR
   \   000053   EB           MOV       A,R3
   \   000054   F0           MOVX      @DPTR,A
   \   000055   05..         INC       ?V0
   \   000057   E5..         MOV       A,?V0
   \   000059   70B9         JNZ       ??test2_53
   \   00005B   05..         INC       ?V1
   \   00005D   80B5         SJMP      ??test2_53
     45          
     46          // Нету NULL  
     47            for(int i = 0; i < 20; i++)
   \                     ??test2_54:
   \   00005F   7800         MOV       R0,#0x0
   \   000061   7900         MOV       R1,#0x0
   \                     ??test2_55:
   \   000063   C3           CLR       C
   \   000064   E8           MOV       A,R0
   \   000065   9414         SUBB      A,#0x14
   \   000067   E9           MOV       A,R1
   \   000068   9400         SUBB      A,#0x0
   \   00006A   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00006C   65D0         XRL       A,PSW
   \   00006E   33           RLC       A
   \   00006F   503D         JNC       ??test2_56
     48              if (all[i] == NULL)
   \   000071   E8           MOV       A,R0
   \   000072   FA           MOV       R2,A
   \   000073   E9           MOV       A,R1
   \   000074   FB           MOV       R3,A
   \   000075   EA           MOV       A,R2
   \   000076   75F002       MOV       B,#0x2
   \   000079   A4           MUL       AB
   \   00007A   CA           XCH       A,R2
   \   00007B   ACF0         MOV       R4,B
   \   00007D   75F000       MOV       B,#0x0
   \   000080   A4           MUL       AB
   \   000081   2C           ADD       A,R4
   \   000082   FC           MOV       R4,A
   \   000083   75F002       MOV       B,#0x2
   \   000086   EB           MOV       A,R3
   \   000087   A4           MUL       AB
   \   000088   2C           ADD       A,R4
   \   000089   FB           MOV       R3,A
   \   00008A   90FFD7       MOV       DPTR,#-0x29
   \   00008D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000090   E582         MOV       A,DPL
   \   000092   2A           ADD       A,R2
   \   000093   F582         MOV       DPL,A
   \   000095   E583         MOV       A,DPH
   \   000097   3B           ADDC      A,R3
   \   000098   F583         MOV       DPH,A
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   FA           MOV       R2,A
   \   00009C   A3           INC       DPTR
   \   00009D   E0           MOVX      A,@DPTR
   \   00009E   FB           MOV       R3,A
   \   00009F   EA           MOV       A,R2
   \   0000A0   4B           ORL       A,R3
   \   0000A1   7004         JNZ       ??test2_57
     49                test_res = 1;
   \   0000A3   7E01         MOV       R6,#0x1
   \   0000A5   7F00         MOV       R7,#0x0
   \                     ??test2_57:
   \   0000A7   08           INC       R0
   \   0000A8   E8           MOV       A,R0
   \   0000A9   70B8         JNZ       ??test2_55
   \   0000AB   09           INC       R1
   \   0000AC   80B5         SJMP      ??test2_55
     50          
     51          // Все слоты должны быть разные 
     52            for(int i = 1; i < 20; i++)
   \                     ??test2_56:
   \   0000AE   7801         MOV       R0,#0x1
   \   0000B0   7900         MOV       R1,#0x0
   \                     ??test2_58:
   \   0000B2   C3           CLR       C
   \   0000B3   E8           MOV       A,R0
   \   0000B4   9414         SUBB      A,#0x14
   \   0000B6   E9           MOV       A,R1
   \   0000B7   9400         SUBB      A,#0x0
   \   0000B9   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0000BB   65D0         XRL       A,PSW
   \   0000BD   33           RLC       A
   \   0000BE   5078         JNC       ??test2_59
     53              if (all[i] == all[i - 1])
   \   0000C0   E8           MOV       A,R0
   \   0000C1   FA           MOV       R2,A
   \   0000C2   E9           MOV       A,R1
   \   0000C3   FB           MOV       R3,A
   \   0000C4   EA           MOV       A,R2
   \   0000C5   75F002       MOV       B,#0x2
   \   0000C8   A4           MUL       AB
   \   0000C9   CA           XCH       A,R2
   \   0000CA   ACF0         MOV       R4,B
   \   0000CC   75F000       MOV       B,#0x0
   \   0000CF   A4           MUL       AB
   \   0000D0   2C           ADD       A,R4
   \   0000D1   FC           MOV       R4,A
   \   0000D2   75F002       MOV       B,#0x2
   \   0000D5   EB           MOV       A,R3
   \   0000D6   A4           MUL       AB
   \   0000D7   2C           ADD       A,R4
   \   0000D8   FB           MOV       R3,A
   \   0000D9   90FFD7       MOV       DPTR,#-0x29
   \   0000DC   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000DF   E582         MOV       A,DPL
   \   0000E1   2A           ADD       A,R2
   \   0000E2   F582         MOV       DPL,A
   \   0000E4   E583         MOV       A,DPH
   \   0000E6   3B           ADDC      A,R3
   \   0000E7   F583         MOV       DPH,A
   \   0000E9   E0           MOVX      A,@DPTR
   \   0000EA   FC           MOV       R4,A
   \   0000EB   A3           INC       DPTR
   \   0000EC   E0           MOVX      A,@DPTR
   \   0000ED   FD           MOV       R5,A
   \   0000EE   E8           MOV       A,R0
   \   0000EF   FA           MOV       R2,A
   \   0000F0   E9           MOV       A,R1
   \   0000F1   FB           MOV       R3,A
   \   0000F2   EA           MOV       A,R2
   \   0000F3   75F002       MOV       B,#0x2
   \   0000F6   A4           MUL       AB
   \   0000F7   CA           XCH       A,R2
   \   0000F8   85F0..       MOV       ?V0,B
   \   0000FB   75F000       MOV       B,#0x0
   \   0000FE   A4           MUL       AB
   \   0000FF   25..         ADD       A,?V0
   \   000101   F5..         MOV       ?V0,A
   \   000103   75F002       MOV       B,#0x2
   \   000106   EB           MOV       A,R3
   \   000107   A4           MUL       AB
   \   000108   25..         ADD       A,?V0
   \   00010A   FB           MOV       R3,A
   \   00010B   90FFD7       MOV       DPTR,#-0x29
   \   00010E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000111   E582         MOV       A,DPL
   \   000113   2A           ADD       A,R2
   \   000114   FA           MOV       R2,A
   \   000115   E583         MOV       A,DPH
   \   000117   3B           ADDC      A,R3
   \   000118   FB           MOV       R3,A
   \   000119   EA           MOV       A,R2
   \   00011A   24FE         ADD       A,#-0x2
   \   00011C   F582         MOV       DPL,A
   \   00011E   EB           MOV       A,R3
   \   00011F   34FF         ADDC      A,#-0x1
   \   000121   F583         MOV       DPH,A
   \   000123   E0           MOVX      A,@DPTR
   \   000124   6C           XRL       A,R4
   \   000125   7003         JNZ       ??test2_60
   \   000127   A3           INC       DPTR
   \   000128   E0           MOVX      A,@DPTR
   \   000129   6D           XRL       A,R5
   \                     ??test2_60:
   \   00012A   7004         JNZ       ??test2_61
     54                test_res = 2;  
   \   00012C   7E02         MOV       R6,#0x2
   \   00012E   7F00         MOV       R7,#0x0
   \                     ??test2_61:
   \   000130   08           INC       R0
   \   000131   E8           MOV       A,R0
   \   000132   7001         JNZ       ??test2_62
   \   000134   09           INC       R1
   \                     ??test2_62:
   \   000135   02....       LJMP      ??test2_58 & 0xFFFF
     55          
     56          // Все слоты занятыы
     57            if (SL_busy() != 20)
   \                     ??test2_59:
   \   000138                ; Setup parameters for call to function SL_busy
   \   000138   12....       LCALL     `??SL_busy::?relay`; Banked call to: SL_busy
   \   00013B   8A..         MOV       ?V0,R2
   \   00013D   8B..         MOV       ?V1,R3
   \   00013F   7414         MOV       A,#0x14
   \   000141   65..         XRL       A,?V0
   \   000143   7004         JNZ       ??test2_63
   \   000145   7400         MOV       A,#0x0
   \   000147   65..         XRL       A,?V1
   \                     ??test2_63:
   \   000149   6004         JZ        ??test2_64
     58              test_res = 3;  
   \   00014B   7E03         MOV       R6,#0x3
   \   00014D   7F00         MOV       R7,#0x0
     59          
     60          // Свободных слотов нет
     61            if (SL_available() != 0)
   \                     ??test2_64:
   \   00014F                ; Setup parameters for call to function SL_available
   \   00014F   12....       LCALL     `??SL_available::?relay`; Banked call to: SL_available
   \   000152   8A..         MOV       ?V0,R2
   \   000154   8B..         MOV       ?V1,R3
   \   000156   E5..         MOV       A,?V0
   \   000158   45..         ORL       A,?V1
   \   00015A   6004         JZ        ??test2_65
     62              test_res = 4;   
   \   00015C   7E04         MOV       R6,#0x4
   \   00015E   7F00         MOV       R7,#0x0
     63            
     64          // Слотов нет и при выделении должен быть NULL  
     65            char *sl =  SL_alloc();
   \                     ??test2_65:
   \   000160                ; Setup parameters for call to function SL_alloc
   \   000160   12....       LCALL     `??SL_alloc::?relay`; Banked call to: SL_alloc
   \   000163   8A..         MOV       ?V0,R2
   \   000165   8B..         MOV       ?V1,R3
   \   000167   85....       MOV       ?V2,?V0
   \   00016A   85....       MOV       ?V3,?V1
     66            if (sl)
   \   00016D   E5..         MOV       A,?V2
   \   00016F   45..         ORL       A,?V3
   \   000171   6007         JZ        ??test2_66
     67              return 5;  
   \   000173   7A05         MOV       R2,#0x5
   \   000175   7B00         MOV       R3,#0x0
   \   000177   02....       LJMP      ??test2_67 & 0xFFFF
     68            
     69          // Убедимся что счетчики не уехали
     70          // Все слоты занятыы
     71            if (SL_busy() != 20)
   \                     ??test2_66:
   \   00017A                ; Setup parameters for call to function SL_busy
   \   00017A   12....       LCALL     `??SL_busy::?relay`; Banked call to: SL_busy
   \   00017D   8A..         MOV       ?V0,R2
   \   00017F   8B..         MOV       ?V1,R3
   \   000181   7414         MOV       A,#0x14
   \   000183   65..         XRL       A,?V0
   \   000185   7004         JNZ       ??test2_68
   \   000187   7400         MOV       A,#0x0
   \   000189   65..         XRL       A,?V1
   \                     ??test2_68:
   \   00018B   6004         JZ        ??test2_69
     72              test_res = 6;  
   \   00018D   7E06         MOV       R6,#0x6
   \   00018F   7F00         MOV       R7,#0x0
     73          
     74          // Свободных слотов нет
     75            if (SL_available() != 0)
   \                     ??test2_69:
   \   000191                ; Setup parameters for call to function SL_available
   \   000191   12....       LCALL     `??SL_available::?relay`; Banked call to: SL_available
   \   000194   8A..         MOV       ?V0,R2
   \   000196   8B..         MOV       ?V1,R3
   \   000198   E5..         MOV       A,?V0
   \   00019A   45..         ORL       A,?V1
   \   00019C   6004         JZ        ??test2_70
     76              test_res = 7; 
   \   00019E   7E07         MOV       R6,#0x7
   \   0001A0   7F00         MOV       R7,#0x0
     77            
     78          // Удаляем все что создали и контролим результат
     79            for (int i = 0; i < 20; i++)
   \                     ??test2_70:
   \   0001A2   75..00       MOV       ?V0,#0x0
   \   0001A5   75..00       MOV       ?V1,#0x0
   \                     ??test2_71:
   \   0001A8   C3           CLR       C
   \   0001A9   E5..         MOV       A,?V0
   \   0001AB   9414         SUBB      A,#0x14
   \   0001AD   E5..         MOV       A,?V1
   \   0001AF   9400         SUBB      A,#0x0
   \   0001B1   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0001B3   65D0         XRL       A,PSW
   \   0001B5   33           RLC       A
   \   0001B6   5041         JNC       ??test2_72
     80              if (!SL_free(all[i]))
   \   0001B8                ; Setup parameters for call to function SL_free
   \   0001B8   A8..         MOV       R0,?V0
   \   0001BA   A9..         MOV       R1,?V1
   \   0001BC   E8           MOV       A,R0
   \   0001BD   75F002       MOV       B,#0x2
   \   0001C0   A4           MUL       AB
   \   0001C1   C8           XCH       A,R0
   \   0001C2   AAF0         MOV       R2,B
   \   0001C4   75F000       MOV       B,#0x0
   \   0001C7   A4           MUL       AB
   \   0001C8   2A           ADD       A,R2
   \   0001C9   FA           MOV       R2,A
   \   0001CA   75F002       MOV       B,#0x2
   \   0001CD   E9           MOV       A,R1
   \   0001CE   A4           MUL       AB
   \   0001CF   2A           ADD       A,R2
   \   0001D0   F9           MOV       R1,A
   \   0001D1   90FFD7       MOV       DPTR,#-0x29
   \   0001D4   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0001D7   E582         MOV       A,DPL
   \   0001D9   28           ADD       A,R0
   \   0001DA   F582         MOV       DPL,A
   \   0001DC   E583         MOV       A,DPH
   \   0001DE   39           ADDC      A,R1
   \   0001DF   F583         MOV       DPH,A
   \   0001E1   E0           MOVX      A,@DPTR
   \   0001E2   FA           MOV       R2,A
   \   0001E3   A3           INC       DPTR
   \   0001E4   E0           MOVX      A,@DPTR
   \   0001E5   FB           MOV       R3,A
   \   0001E6   12....       LCALL     `??SL_free::?relay`; Banked call to: SL_free
   \   0001E9   4004         JC        ??test2_73
     81                test_res = 8; 
   \   0001EB   7E08         MOV       R6,#0x8
   \   0001ED   7F00         MOV       R7,#0x0
   \                     ??test2_73:
   \   0001EF   05..         INC       ?V0
   \   0001F1   E5..         MOV       A,?V0
   \   0001F3   70B3         JNZ       ??test2_71
   \   0001F5   05..         INC       ?V1
   \   0001F7   80AF         SJMP      ??test2_71
     82          
     83          // Все слоты свободны
     84            if (SL_busy() != 0)
   \                     ??test2_72:
   \   0001F9                ; Setup parameters for call to function SL_busy
   \   0001F9   12....       LCALL     `??SL_busy::?relay`; Banked call to: SL_busy
   \   0001FC   8A..         MOV       ?V0,R2
   \   0001FE   8B..         MOV       ?V1,R3
   \   000200   E5..         MOV       A,?V0
   \   000202   45..         ORL       A,?V1
   \   000204   6004         JZ        ??test2_74
     85              test_res = 9;  
   \   000206   7E09         MOV       R6,#0x9
   \   000208   7F00         MOV       R7,#0x0
     86          
     87            if (SL_available() != 20)
   \                     ??test2_74:
   \   00020A                ; Setup parameters for call to function SL_available
   \   00020A   12....       LCALL     `??SL_available::?relay`; Banked call to: SL_available
   \   00020D   8A..         MOV       ?V0,R2
   \   00020F   8B..         MOV       ?V1,R3
   \   000211   7414         MOV       A,#0x14
   \   000213   65..         XRL       A,?V0
   \   000215   7004         JNZ       ??test2_75
   \   000217   7400         MOV       A,#0x0
   \   000219   65..         XRL       A,?V1
   \                     ??test2_75:
   \   00021B   6004         JZ        ??test2_76
     88              test_res = 10;
   \   00021D   7E0A         MOV       R6,#0xa
   \   00021F   7F00         MOV       R7,#0x0
     89            
     90          // Пробуем удалить уже удаленное рез. должен быть false  
     91            for (int i = 0; i < 20; i++)
   \                     ??test2_76:
   \   000221   75..00       MOV       ?V0,#0x0
   \   000224   75..00       MOV       ?V1,#0x0
   \                     ??test2_77:
   \   000227   C3           CLR       C
   \   000228   E5..         MOV       A,?V0
   \   00022A   9414         SUBB      A,#0x14
   \   00022C   E5..         MOV       A,?V1
   \   00022E   9400         SUBB      A,#0x0
   \   000230   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000232   65D0         XRL       A,PSW
   \   000234   33           RLC       A
   \   000235   5041         JNC       ??test2_78
     92              if (SL_free(all[i]))
   \   000237                ; Setup parameters for call to function SL_free
   \   000237   A8..         MOV       R0,?V0
   \   000239   A9..         MOV       R1,?V1
   \   00023B   E8           MOV       A,R0
   \   00023C   75F002       MOV       B,#0x2
   \   00023F   A4           MUL       AB
   \   000240   C8           XCH       A,R0
   \   000241   AAF0         MOV       R2,B
   \   000243   75F000       MOV       B,#0x0
   \   000246   A4           MUL       AB
   \   000247   2A           ADD       A,R2
   \   000248   FA           MOV       R2,A
   \   000249   75F002       MOV       B,#0x2
   \   00024C   E9           MOV       A,R1
   \   00024D   A4           MUL       AB
   \   00024E   2A           ADD       A,R2
   \   00024F   F9           MOV       R1,A
   \   000250   90FFD7       MOV       DPTR,#-0x29
   \   000253   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000256   E582         MOV       A,DPL
   \   000258   28           ADD       A,R0
   \   000259   F582         MOV       DPL,A
   \   00025B   E583         MOV       A,DPH
   \   00025D   39           ADDC      A,R1
   \   00025E   F583         MOV       DPH,A
   \   000260   E0           MOVX      A,@DPTR
   \   000261   FA           MOV       R2,A
   \   000262   A3           INC       DPTR
   \   000263   E0           MOVX      A,@DPTR
   \   000264   FB           MOV       R3,A
   \   000265   12....       LCALL     `??SL_free::?relay`; Banked call to: SL_free
   \   000268   5004         JNC       ??test2_79
     93                test_res = 11;
   \   00026A   7E0B         MOV       R6,#0xb
   \   00026C   7F00         MOV       R7,#0x0
   \                     ??test2_79:
   \   00026E   05..         INC       ?V0
   \   000270   E5..         MOV       A,?V0
   \   000272   70B3         JNZ       ??test2_77
   \   000274   05..         INC       ?V1
   \   000276   80AF         SJMP      ??test2_77
     94            
     95          // Все слоты свободны
     96            if (SL_busy() != 0)
   \                     ??test2_78:
   \   000278                ; Setup parameters for call to function SL_busy
   \   000278   12....       LCALL     `??SL_busy::?relay`; Banked call to: SL_busy
   \   00027B   8A..         MOV       ?V0,R2
   \   00027D   8B..         MOV       ?V1,R3
   \   00027F   E5..         MOV       A,?V0
   \   000281   45..         ORL       A,?V1
   \   000283   6004         JZ        ??test2_80
     97              test_res = 12;  
   \   000285   7E0C         MOV       R6,#0xc
   \   000287   7F00         MOV       R7,#0x0
     98          
     99            if (SL_available() != 20)
   \                     ??test2_80:
   \   000289                ; Setup parameters for call to function SL_available
   \   000289   12....       LCALL     `??SL_available::?relay`; Banked call to: SL_available
   \   00028C   8A..         MOV       ?V0,R2
   \   00028E   8B..         MOV       ?V1,R3
   \   000290   7414         MOV       A,#0x14
   \   000292   65..         XRL       A,?V0
   \   000294   7004         JNZ       ??test2_81
   \   000296   7400         MOV       A,#0x0
   \   000298   65..         XRL       A,?V1
   \                     ??test2_81:
   \   00029A   6004         JZ        ??test2_82
    100              test_res = 13;
   \   00029C   7E0D         MOV       R6,#0xd
   \   00029E   7F00         MOV       R7,#0x0
    101            
    102            return test_res;
   \                     ??test2_82:
   \   0002A0   EE           MOV       A,R6
   \   0002A1   FA           MOV       R2,A
   \   0002A2   EF           MOV       A,R7
   \   0002A3   FB           MOV       R3,A
   \                     ??test2_67:
   \   0002A4   74D8         MOV       A,#-0x28
   \   0002A6   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0002A9   7F04         MOV       R7,#0x4
   \   0002AB   02....       LJMP      ?BANKED_LEAVE_SP
    103          }
    104          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    105          static int test1(void){
   \                     ??test1_3:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   7402         MOV       A,#0x2
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 5
   \   000005                ; Auto size: 0
    106            // Простой тест на создание и удаление
    107            bool test_res = 0;
   \   000005   C2..         CLR       ?VB.0
    108            
    109            if (SL_busy() != 0)
   \   000007                ; Setup parameters for call to function SL_busy
   \   000007   12....       LCALL     `??SL_busy::?relay`; Banked call to: SL_busy
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   E5..         MOV       A,?V0
   \   000010   45..         ORL       A,?V1
   \   000012   6002         JZ        ??test1_36
    110              test_res = 1;  
   \   000014   D2..         SETB      ?VB.0
    111          
    112            if (SL_available() != 20)
   \                     ??test1_36:
   \   000016                ; Setup parameters for call to function SL_available
   \   000016   12....       LCALL     `??SL_available::?relay`; Banked call to: SL_available
   \   000019   8A..         MOV       ?V0,R2
   \   00001B   8B..         MOV       ?V1,R3
   \   00001D   7414         MOV       A,#0x14
   \   00001F   65..         XRL       A,?V0
   \   000021   7004         JNZ       ??test1_37
   \   000023   7400         MOV       A,#0x0
   \   000025   65..         XRL       A,?V1
   \                     ??test1_37:
   \   000027   6002         JZ        ??test1_38
    113              test_res = 2;    
   \   000029   D2..         SETB      ?VB.0
    114            
    115            char* slot = SL_alloc();
   \                     ??test1_38:
   \   00002B                ; Setup parameters for call to function SL_alloc
   \   00002B   12....       LCALL     `??SL_alloc::?relay`; Banked call to: SL_alloc
   \   00002E   8A..         MOV       ?V0,R2
   \   000030   8B..         MOV       ?V1,R3
   \   000032   AE..         MOV       R6,?V0
   \   000034   AF..         MOV       R7,?V1
    116            if (SL_busy() != 1)
   \   000036                ; Setup parameters for call to function SL_busy
   \   000036   12....       LCALL     `??SL_busy::?relay`; Banked call to: SL_busy
   \   000039   8A..         MOV       ?V0,R2
   \   00003B   8B..         MOV       ?V1,R3
   \   00003D   7401         MOV       A,#0x1
   \   00003F   65..         XRL       A,?V0
   \   000041   7004         JNZ       ??test1_39
   \   000043   7400         MOV       A,#0x0
   \   000045   65..         XRL       A,?V1
   \                     ??test1_39:
   \   000047   6002         JZ        ??test1_40
    117              test_res = 3;
   \   000049   D2..         SETB      ?VB.0
    118            
    119            if (SL_available() != 19)
   \                     ??test1_40:
   \   00004B                ; Setup parameters for call to function SL_available
   \   00004B   12....       LCALL     `??SL_available::?relay`; Banked call to: SL_available
   \   00004E   8A..         MOV       ?V0,R2
   \   000050   8B..         MOV       ?V1,R3
   \   000052   7413         MOV       A,#0x13
   \   000054   65..         XRL       A,?V0
   \   000056   7004         JNZ       ??test1_41
   \   000058   7400         MOV       A,#0x0
   \   00005A   65..         XRL       A,?V1
   \                     ??test1_41:
   \   00005C   6002         JZ        ??test1_42
    120              test_res = 4;  
   \   00005E   D2..         SETB      ?VB.0
    121            
    122            SL_free(slot);
   \                     ??test1_42:
   \   000060                ; Setup parameters for call to function SL_free
   \   000060   EE           MOV       A,R6
   \   000061   FA           MOV       R2,A
   \   000062   EF           MOV       A,R7
   \   000063   FB           MOV       R3,A
   \   000064   12....       LCALL     `??SL_free::?relay`; Banked call to: SL_free
    123            if (SL_busy() != 0)
   \   000067                ; Setup parameters for call to function SL_busy
   \   000067   12....       LCALL     `??SL_busy::?relay`; Banked call to: SL_busy
   \   00006A   8A..         MOV       ?V0,R2
   \   00006C   8B..         MOV       ?V1,R3
   \   00006E   E5..         MOV       A,?V0
   \   000070   45..         ORL       A,?V1
   \   000072   6002         JZ        ??test1_43
    124              test_res = 5;  
   \   000074   D2..         SETB      ?VB.0
    125            
    126            if (SL_available() != 20)
   \                     ??test1_43:
   \   000076                ; Setup parameters for call to function SL_available
   \   000076   12....       LCALL     `??SL_available::?relay`; Banked call to: SL_available
   \   000079   8A..         MOV       ?V0,R2
   \   00007B   8B..         MOV       ?V1,R3
   \   00007D   7414         MOV       A,#0x14
   \   00007F   65..         XRL       A,?V0
   \   000081   7004         JNZ       ??test1_44
   \   000083   7400         MOV       A,#0x0
   \   000085   65..         XRL       A,?V1
   \                     ??test1_44:
   \   000087   6002         JZ        ??test1_45
    127              test_res = 6; 
   \   000089   D2..         SETB      ?VB.0
    128            
    129            return test_res;
   \                     ??test1_45:
   \   00008B   A2..         MOV       C,?VB.0
   \   00008D   E4           CLR       A
   \   00008E   33           RLC       A
   \   00008F   FA           MOV       R2,A
   \   000090   7B00         MOV       R3,#0x0
   \   000092   7F02         MOV       R7,#0x2
   \   000094   02....       LJMP      ?BANKED_LEAVE_SP
    130          }
    131          
E:\Neocore\Hardware\PRJ Test\u_mem_utils.c
      1          #include "debug.h"
      2          #include "mem_utils.h"
      3          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
      4          void u_mem_utils(void){
   \                     u_mem_utils:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   7402         MOV       A,#0x2
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 5
   \   000005                ; Auto size: 29
   \   000005   741D         MOV       A,#0x1d
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
      5            char tst1[10] = {1,2,3,4,5,6,7,8,9,10};
   \   00000A   90....       MOV       DPTR,#`?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}>_1`
   \   00000D   C082         PUSH      DPL
   \   00000F   C083         PUSH      DPH
   \   000011   90FFEA       MOV       DPTR,#-0x16
   \   000014   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000017   AC82         MOV       R4,DPL
   \   000019   AD83         MOV       R5,DPH
   \   00001B   D083         POP       DPH
   \   00001D   D082         POP       DPL
   \   00001F   740A         MOV       A,#0xa
   \   000021   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
      6            char tst2[10];
      7            int cmp_res;
      8            
      9            struct memcpy memcpy = {.src = tst1, .dst = tst2, .len = sizeof(tst1)};
   \   000024   90....       MOV       DPTR,#`?<Constant {(char *)0, (char *)0, 10}>`
   \   000027   C082         PUSH      DPL
   \   000029   C083         PUSH      DPH
   \   00002B   90FFF4       MOV       DPTR,#-0xc
   \   00002E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000031   AC82         MOV       R4,DPL
   \   000033   AD83         MOV       R5,DPH
   \   000035   D083         POP       DPH
   \   000037   D082         POP       DPL
   \   000039   7405         MOV       A,#0x5
   \   00003B   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   00003E   90FFE2       MOV       DPTR,#-0x1e
   \   000041   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000044   A882         MOV       R0,DPL
   \   000046   A983         MOV       R1,DPH
   \   000048   90FFF6       MOV       DPTR,#-0xa
   \   00004B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00004E   E8           MOV       A,R0
   \   00004F   F0           MOVX      @DPTR,A
   \   000050   A3           INC       DPTR
   \   000051   E9           MOV       A,R1
   \   000052   F0           MOVX      @DPTR,A
   \   000053   90FFEC       MOV       DPTR,#-0x14
   \   000056   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000059   A882         MOV       R0,DPL
   \   00005B   A983         MOV       R1,DPH
   \   00005D   90FFF8       MOV       DPTR,#-0x8
   \   000060   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000063   E8           MOV       A,R0
   \   000064   F0           MOVX      @DPTR,A
   \   000065   A3           INC       DPTR
   \   000066   E9           MOV       A,R1
   \   000067   F0           MOVX      @DPTR,A
     10            MEM_memcpy(&memcpy);
   \   000068                ; Setup parameters for call to function MEM_memcpy
   \   000068   90FFF6       MOV       DPTR,#-0xa
   \   00006B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00006E   AA82         MOV       R2,DPL
   \   000070   AB83         MOV       R3,DPH
   \   000072   12....       LCALL     `??MEM_memcpy::?relay`; Banked call to: MEM_memcpy
     11            
     12            for (int i = 0; i < sizeof(tst1); i++){
   \   000075   75..00       MOV       ?V0,#0x0
   \   000078   75..00       MOV       ?V1,#0x0
   \                     ??u_mem_utils_0:
   \   00007B   C3           CLR       C
   \   00007C   E5..         MOV       A,?V0
   \   00007E   940A         SUBB      A,#0xa
   \   000080   E5..         MOV       A,?V1
   \   000082   9400         SUBB      A,#0x0
   \   000084   5061         JNC       ??u_mem_utils_1
     13              cmp_res = tst1[i] == tst2[i];
   \   000086   90FFEC       MOV       DPTR,#-0x14
   \   000089   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00008C   E582         MOV       A,DPL
   \   00008E   25..         ADD       A,?V0
   \   000090   F582         MOV       DPL,A
   \   000092   E583         MOV       A,DPH
   \   000094   35..         ADDC      A,?V1
   \   000096   F583         MOV       DPH,A
   \   000098   E0           MOVX      A,@DPTR
   \   000099   F8           MOV       R0,A
   \   00009A   90FFE2       MOV       DPTR,#-0x1e
   \   00009D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A0   E582         MOV       A,DPL
   \   0000A2   25..         ADD       A,?V0
   \   0000A4   F582         MOV       DPL,A
   \   0000A6   E583         MOV       A,DPH
   \   0000A8   35..         ADDC      A,?V1
   \   0000AA   F583         MOV       DPH,A
   \   0000AC   E0           MOVX      A,@DPTR
   \   0000AD   68           XRL       A,R0
   \   0000AE   7006         JNZ       ??u_mem_utils_2
   \   0000B0   7E01         MOV       R6,#0x1
   \   0000B2   7F00         MOV       R7,#0x0
   \   0000B4   8004         SJMP      ??u_mem_utils_3
   \                     ??u_mem_utils_2:
   \   0000B6   7E00         MOV       R6,#0x0
   \   0000B8   7F00         MOV       R7,#0x0
     14              ASSERT(cmp_res == 0);
   \                     ??u_mem_utils_3:
   \   0000BA   EE           MOV       A,R6
   \   0000BB   4F           ORL       A,R7
   \   0000BC   601F         JZ        ??u_mem_utils_4
   \   0000BE                ; Setup parameters for call to function printf
   \   0000BE   740E         MOV       A,#0xe
   \   0000C0   C0E0         PUSH      A
   \   0000C2   7400         MOV       A,#0x0
   \   0000C4   C0E0         PUSH      A
   \   0000C6   74..         MOV       A,#`?<Constant "u_mem_utils.c">` & 0xff
   \   0000C8   C0E0         PUSH      A
   \   0000CA   74..         MOV       A,#(`?<Constant "u_mem_utils.c">` >> 8) & 0xff
   \   0000CC   C0E0         PUSH      A
   \   0000CE   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_8` & 0xff
   \   0000D0   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_8` >> 8) & 0xff
   \   0000D2   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0000D5   74FC         MOV       A,#-0x4
   \   0000D7   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000DA                ; Setup parameters for call to function DBG_CORE_HALT
   \   0000DA   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     15              }
   \                     ??u_mem_utils_4:
   \   0000DD   05..         INC       ?V0
   \   0000DF   E5..         MOV       A,?V0
   \   0000E1   7098         JNZ       ??u_mem_utils_0
   \   0000E3   05..         INC       ?V1
   \   0000E5   8094         SJMP      ??u_mem_utils_0
     16            LOG_ON("MEM_memcpy ok!");
   \                     ??u_mem_utils_1:
   \   0000E7                ; Setup parameters for call to function printf
   \   0000E7   74..         MOV       A,#??__FUNCTION___13 & 0xff
   \   0000E9   C0E0         PUSH      A
   \   0000EB   74..         MOV       A,#(??__FUNCTION___13 >> 8) & 0xff
   \   0000ED   C0E0         PUSH      A
   \   0000EF   7410         MOV       A,#0x10
   \   0000F1   C0E0         PUSH      A
   \   0000F3   7400         MOV       A,#0x0
   \   0000F5   C0E0         PUSH      A
   \   0000F7   74..         MOV       A,#`?<Constant "u_mem_utils.c">` & 0xff
   \   0000F9   C0E0         PUSH      A
   \   0000FB   74..         MOV       A,#(`?<Constant "u_mem_utils.c">` >> 8) & 0xff
   \   0000FD   C0E0         PUSH      A
   \   0000FF   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_4` & 0xff
   \   000101   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_4` >> 8) & 0xff
   \   000103   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000106   74FA         MOV       A,#-0x6
   \   000108   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00010B                ; Setup parameters for call to function printf
   \   00010B   7A..         MOV       R2,#`?<Constant "MEM_memcpy ok!">` & 0xff
   \   00010D   7B..         MOV       R3,#(`?<Constant "MEM_memcpy ok!">` >> 8) & 0xff
   \   00010F   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000112                ; Setup parameters for call to function printf
   \   000112   7A..         MOV       R2,#`?<Constant "\\r\\n">_3` & 0xff
   \   000114   7B..         MOV       R3,#(`?<Constant "\\r\\n">_3` >> 8) & 0xff
   \   000116   12....       LCALL     `??printf::?relay`; Banked call to: printf
     17            
     18            struct memset memset = {.dst = tst1, .val = 7, .len = sizeof(tst1)};
   \   000119   90....       MOV       DPTR,#`?<Constant {(char *)0, 10, 7}>`
   \   00011C   C082         PUSH      DPL
   \   00011E   C083         PUSH      DPH
   \   000120   90FFF9       MOV       DPTR,#-0x7
   \   000123   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000126   AC82         MOV       R4,DPL
   \   000128   AD83         MOV       R5,DPH
   \   00012A   D083         POP       DPH
   \   00012C   D082         POP       DPL
   \   00012E   7404         MOV       A,#0x4
   \   000130   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   000133   90FFEC       MOV       DPTR,#-0x14
   \   000136   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000139   A882         MOV       R0,DPL
   \   00013B   A983         MOV       R1,DPH
   \   00013D   90FFFB       MOV       DPTR,#-0x5
   \   000140   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000143   E8           MOV       A,R0
   \   000144   F0           MOVX      @DPTR,A
   \   000145   A3           INC       DPTR
   \   000146   E9           MOV       A,R1
   \   000147   F0           MOVX      @DPTR,A
     19            MEM_memset(&memset);
   \   000148                ; Setup parameters for call to function MEM_memset
   \   000148   90FFFB       MOV       DPTR,#-0x5
   \   00014B   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00014E   AA82         MOV       R2,DPL
   \   000150   AB83         MOV       R3,DPH
   \   000152   12....       LCALL     `??MEM_memset::?relay`; Banked call to: MEM_memset
     20          
     21            for (int i = 0; i < sizeof(tst1); i++){
   \   000155   75..00       MOV       ?V0,#0x0
   \   000158   75..00       MOV       ?V1,#0x0
   \                     ??u_mem_utils_5:
   \   00015B   C3           CLR       C
   \   00015C   E5..         MOV       A,?V0
   \   00015E   940A         SUBB      A,#0xa
   \   000160   E5..         MOV       A,?V1
   \   000162   9400         SUBB      A,#0x0
   \   000164   504E         JNC       ??u_mem_utils_6
     22              cmp_res = tst1[i] == 7;
   \   000166   90FFEC       MOV       DPTR,#-0x14
   \   000169   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00016C   E582         MOV       A,DPL
   \   00016E   25..         ADD       A,?V0
   \   000170   F582         MOV       DPL,A
   \   000172   E583         MOV       A,DPH
   \   000174   35..         ADDC      A,?V1
   \   000176   F583         MOV       DPH,A
   \   000178   E0           MOVX      A,@DPTR
   \   000179   6407         XRL       A,#0x7
   \   00017B   7006         JNZ       ??u_mem_utils_7
   \   00017D   7E01         MOV       R6,#0x1
   \   00017F   7F00         MOV       R7,#0x0
   \   000181   8004         SJMP      ??u_mem_utils_8
   \                     ??u_mem_utils_7:
   \   000183   7E00         MOV       R6,#0x0
   \   000185   7F00         MOV       R7,#0x0
     23              ASSERT(cmp_res == 0);
   \                     ??u_mem_utils_8:
   \   000187   EE           MOV       A,R6
   \   000188   4F           ORL       A,R7
   \   000189   601F         JZ        ??u_mem_utils_9
   \   00018B                ; Setup parameters for call to function printf
   \   00018B   7417         MOV       A,#0x17
   \   00018D   C0E0         PUSH      A
   \   00018F   7400         MOV       A,#0x0
   \   000191   C0E0         PUSH      A
   \   000193   74..         MOV       A,#`?<Constant "u_mem_utils.c">` & 0xff
   \   000195   C0E0         PUSH      A
   \   000197   74..         MOV       A,#(`?<Constant "u_mem_utils.c">` >> 8) & 0xff
   \   000199   C0E0         PUSH      A
   \   00019B   7A..         MOV       R2,#`?<Constant "!%s:%d\\r\\n">_8` & 0xff
   \   00019D   7B..         MOV       R3,#(`?<Constant "!%s:%d\\r\\n">_8` >> 8) & 0xff
   \   00019F   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0001A2   74FC         MOV       A,#-0x4
   \   0001A4   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001A7                ; Setup parameters for call to function DBG_CORE_HALT
   \   0001A7   12....       LCALL     `??DBG_CORE_HALT::?relay`; Banked call to: DBG_CORE_HALT
     24              }
   \                     ??u_mem_utils_9:
   \   0001AA   05..         INC       ?V0
   \   0001AC   E5..         MOV       A,?V0
   \   0001AE   70AB         JNZ       ??u_mem_utils_5
   \   0001B0   05..         INC       ?V1
   \   0001B2   80A7         SJMP      ??u_mem_utils_5
     25            LOG_ON("MEM_memset ok!");
   \                     ??u_mem_utils_6:
   \   0001B4                ; Setup parameters for call to function printf
   \   0001B4   74..         MOV       A,#??__FUNCTION___13 & 0xff
   \   0001B6   C0E0         PUSH      A
   \   0001B8   74..         MOV       A,#(??__FUNCTION___13 >> 8) & 0xff
   \   0001BA   C0E0         PUSH      A
   \   0001BC   7419         MOV       A,#0x19
   \   0001BE   C0E0         PUSH      A
   \   0001C0   7400         MOV       A,#0x0
   \   0001C2   C0E0         PUSH      A
   \   0001C4   74..         MOV       A,#`?<Constant "u_mem_utils.c">` & 0xff
   \   0001C6   C0E0         PUSH      A
   \   0001C8   74..         MOV       A,#(`?<Constant "u_mem_utils.c">` >> 8) & 0xff
   \   0001CA   C0E0         PUSH      A
   \   0001CC   7A..         MOV       R2,#`?<Constant "%s:%d:%s -> ">_4` & 0xff
   \   0001CE   7B..         MOV       R3,#(`?<Constant "%s:%d:%s -> ">_4` >> 8) & 0xff
   \   0001D0   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0001D3   74FA         MOV       A,#-0x6
   \   0001D5   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001D8                ; Setup parameters for call to function printf
   \   0001D8   7A..         MOV       R2,#`?<Constant "MEM_memset ok!">` & 0xff
   \   0001DA   7B..         MOV       R3,#(`?<Constant "MEM_memset ok!">` >> 8) & 0xff
   \   0001DC   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   0001DF                ; Setup parameters for call to function printf
   \   0001DF   7A..         MOV       R2,#`?<Constant "\\r\\n">_3` & 0xff
   \   0001E1   7B..         MOV       R3,#(`?<Constant "\\r\\n">_3` >> 8) & 0xff
   \   0001E3   12....       LCALL     `??printf::?relay`; Banked call to: printf
     26          }
   \   0001E6   74E3         MOV       A,#-0x1d
   \   0001E8   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0001EB   7F02         MOV       R7,#0x2
   \   0001ED   02....       LJMP      ?BANKED_LEAVE_SP

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {(char *)0, (char *)0, 10}>`:
   \   000000   0000         DW 0H
   \   000002   0000         DW 0H
   \   000004   0A           DB 10

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {(char *)0, 10, 7}>`:
   \   000000   0000         DW 0H
   \   000002   0A           DB 10
   \   000003   07           DB 7
E:\Neocore\Hardware\STACK_CORE_SRC\ustimer.c
      1          #include "ioCC2530.h"
      2          #include "ustimer.h"
      3          #include "stdint.h"
      4          #include "action_manager.h"
      5          #include "stdbool.h"
      6          
      7          
      8          #define ACCURATE_VAL_US 500 
      9          
     10          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт

   \                                 In  segment XDATA_ROM_C, align 1
     11          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
   \                     ??MAC_TIMER_MAX:
   \   000000   FFFFFFFF     DD 4294967295

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     12          static uint32_t DELAY_CALIBRATE_TICS; // Калибровка функции задержки
   \                     ??DELAY_CALIBRATE_TICS:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
     13          
     14          static void DelayCalibrate(void);
     15          static void HW_Init(void);  

   \                                 In  segment XDATA_I, align 1, keep-with-next
     16          module_s UST_MODULE = {ALIAS(HW_Init)};
   \                     UST_MODULE:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for UST_MODULE>`
   \   00000A                REQUIRE __INIT_XDATA_I
     17          
     18          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     19          void HW_Init(void){
   \                     ??HW_Init_7:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     20            // Запускаем таймер, LATCH MODE = 1
     21            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     22            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     23            T2CTRL = (1<<0) | (1<<3); 
   \   000000   759409       MOV       0x94,#0x9
     24            // Калибровка функции задержки
     25            DelayCalibrate();
   \   000003                ; Setup parameters for call to function DelayCalibrate
   \   000003   12....       LCALL     `??DelayCalibrate::?relay`; Banked call to: DelayCalibrate
     26          }
   \   000006   02....       LJMP      ?BRET
   \   000009                REQUIRE T2CTRL
     27          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     28          ustime_t UST_now(void){
   \                     UST_now:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 4
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?ALLOC_EXT_STACK8
     29            ustime_t now;
     30            ((char*)&now)[0] = T2M0;
   \   000005   E5A2         MOV       A,0xa2
   \   000007   C0E0         PUSH      A
   \   000009   90FFFA       MOV       DPTR,#-0x6
   \   00000C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00000F   D0E0         POP       A
   \   000011   F0           MOVX      @DPTR,A
     31            ((char*)&now)[1] = T2M1;
   \   000012   E5A3         MOV       A,0xa3
   \   000014   C0E0         PUSH      A
   \   000016   90FFFB       MOV       DPTR,#-0x5
   \   000019   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00001C   D0E0         POP       A
   \   00001E   F0           MOVX      @DPTR,A
     32            ((char*)&now)[2] = T2MOVF0;
   \   00001F   E5A4         MOV       A,0xa4
   \   000021   C0E0         PUSH      A
   \   000023   90FFFC       MOV       DPTR,#-0x4
   \   000026   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000029   D0E0         POP       A
   \   00002B   F0           MOVX      @DPTR,A
     33            ((char*)&now)[3] = T2MOVF1;
   \   00002C   E5A5         MOV       A,0xa5
   \   00002E   C0E0         PUSH      A
   \   000030   90FFFD       MOV       DPTR,#-0x3
   \   000033   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000036   D0E0         POP       A
   \   000038   F0           MOVX      @DPTR,A
     34            return now;
   \   000039   90FFFB       MOV       DPTR,#-0x5
   \   00003C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00003F   12....       LCALL     ?XLOAD_R2345
   \   000042   74FC         MOV       A,#-0x4
   \   000044   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000047   02....       LJMP      ?BRET
   \   00004A                REQUIRE T2M0
   \   00004A                REQUIRE T2M1
   \   00004A                REQUIRE T2MOVF0
   \   00004A                REQUIRE T2MOVF1
     35          }
     36          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     37          bool UST_time_over(stamp_t beg, ustime_t wait){
   \                     UST_time_over:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 8
   \   000005   7408         MOV       A,#0x8
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   90FFF7       MOV       DPTR,#-0x9
   \   00000D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   EC           MOV       A,R4
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   ED           MOV       A,R5
   \   00001A   F0           MOVX      @DPTR,A
   \   00001B   90FFE5       MOV       DPTR,#-0x1b
   \   00001E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000021   78..         MOV       R0,#?V0
   \   000023   12....       LCALL     ?L_MOV_X
     38            stamp_t now = UST_now(); 
   \   000026                ; Setup parameters for call to function UST_now
   \   000026   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   000029   90FFFB       MOV       DPTR,#-0x5
   \   00002C   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00002F   12....       LCALL     ?XSTORE_R2345
     39            ustime_t delta = UST_interval(beg, now);
   \   000032                ; Setup parameters for call to function UST_interval
   \   000032   90FFFB       MOV       DPTR,#-0x5
   \   000035   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000038   78..         MOV       R0,#?V4
   \   00003A   12....       LCALL     ?L_MOV_X
   \   00003D   78..         MOV       R0,#?V4
   \   00003F   12....       LCALL     ?PUSH_ISTACK_I_FOUR
   \   000042   90FFF3       MOV       DPTR,#-0xd
   \   000045   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000048   12....       LCALL     ?XLOAD_R2345
   \   00004B   12....       LCALL     `??UST_interval::?relay`; Banked call to: UST_interval
   \   00004E   74FC         MOV       A,#-0x4
   \   000050   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000053   8A..         MOV       ?V4,R2
   \   000055   8B..         MOV       ?V5,R3
   \   000057   8C..         MOV       ?V6,R4
   \   000059   8D..         MOV       ?V7,R5
     40            return (delta > wait) ?  true:false;
   \   00005B   78..         MOV       R0,#?V4
   \   00005D   79..         MOV       R1,#?V0
   \   00005F   12....       LCALL     ?UL_GT
   \   000062   5004         JNC       ??UST_time_over_0
   \   000064   D2F0         SETB      B.0
   \   000066   8002         SJMP      ??UST_time_over_1
   \                     ??UST_time_over_0:
   \   000068   C2F0         CLR       B.0
   \                     ??UST_time_over_1:
   \   00006A   A2F0         MOV       C,B.0
   \   00006C   74F8         MOV       A,#-0x8
   \   00006E   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000071   7F08         MOV       R7,#0x8
   \   000073   02....       LJMP      ?BANKED_LEAVE_SP
     41          }
     42          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     43          ustime_t UST_interval(stamp_t beg, stamp_t end){
   \                     UST_interval:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 8
   \   000005   7408         MOV       A,#0x8
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   90FFFB       MOV       DPTR,#-0x5
   \   00000D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   EC           MOV       A,R4
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   ED           MOV       A,R5
   \   00001A   F0           MOVX      @DPTR,A
   \   00001B   90FFE5       MOV       DPTR,#-0x1b
   \   00001E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000021   78..         MOV       R0,#?V0
   \   000023   12....       LCALL     ?L_MOV_X
     44            return (end >= beg) ? 
     45              TICKS_TO_US(end - beg) :
     46              TICKS_TO_US(MAC_TIMER_MAX - beg + end);
   \   000026   90FFFB       MOV       DPTR,#-0x5
   \   000029   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00002C   78..         MOV       R0,#?V0
   \   00002E   12....       LCALL     ?UL_GE_X
   \   000031   501F         JNC       ??UST_interval_0
   \   000033   90FFFB       MOV       DPTR,#-0x5
   \   000036   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000039   78..         MOV       R0,#?V0
   \   00003B   12....       LCALL     ?L_SUB_X
   \   00003E   7405         MOV       A,#0x5
   \   000040   78..         MOV       R0,#?V0
   \   000042   12....       LCALL     ?UL_SHR
   \   000045   90FFF7       MOV       DPTR,#-0x9
   \   000048   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?L_MOV_TO_X
   \   000050   802C         SJMP      ??UST_interval_1
   \                     ??UST_interval_0:
   \   000052   90....       MOV       DPTR,#??MAC_TIMER_MAX
   \   000055   78..         MOV       R0,#?V4
   \   000057   12....       LCALL     ?L_MOV_X
   \   00005A   90FFFB       MOV       DPTR,#-0x5
   \   00005D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000060   78..         MOV       R0,#?V4
   \   000062   12....       LCALL     ?L_SUB_X
   \   000065   78..         MOV       R0,#?V4
   \   000067   79..         MOV       R1,#?V0
   \   000069   12....       LCALL     ?L_ADD
   \   00006C   7405         MOV       A,#0x5
   \   00006E   78..         MOV       R0,#?V4
   \   000070   12....       LCALL     ?UL_SHR
   \   000073   90FFF7       MOV       DPTR,#-0x9
   \   000076   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000079   78..         MOV       R0,#?V4
   \   00007B   12....       LCALL     ?L_MOV_TO_X
   \                     ??UST_interval_1:
   \   00007E   90FFF7       MOV       DPTR,#-0x9
   \   000081   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000084   12....       LCALL     ?XLOAD_R2345
   \   000087   74F8         MOV       A,#-0x8
   \   000089   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00008C   7F08         MOV       R7,#0x8
   \   00008E   02....       LJMP      ?BANKED_LEAVE_SP
     47          };
     48          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     49          void UST_delay(ustime_t time){
   \                     UST_delay:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 16
   \   000005   7410         MOV       A,#0x10
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   90FFEF       MOV       DPTR,#-0x11
   \   00000D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   EC           MOV       A,R4
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   ED           MOV       A,R5
   \   00001A   F0           MOVX      @DPTR,A
     50            stamp_t now = UST_now();
   \   00001B                ; Setup parameters for call to function UST_now
   \   00001B   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   00001E   90FFF3       MOV       DPTR,#-0xd
   \   000021   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000024   12....       LCALL     ?XSTORE_R2345
     51            stamp_t len = US_TO_TICKS(time);
   \   000027   90FFEF       MOV       DPTR,#-0x11
   \   00002A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00002D   78..         MOV       R0,#?V0
   \   00002F   12....       LCALL     ?L_MOV_X
   \   000032   90....       MOV       DPTR,#__Constant_20
   \   000035   78..         MOV       R0,#?V4
   \   000037   12....       LCALL     ?L_MOV_X
   \   00003A   78..         MOV       R0,#?V0
   \   00003C   79..         MOV       R1,#?V4
   \   00003E   12....       LCALL     ?L_MUL
   \   000041   90FFF7       MOV       DPTR,#-0x9
   \   000044   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000047   78..         MOV       R0,#?V0
   \   000049   12....       LCALL     ?L_MOV_TO_X
     52            stamp_t offset = (time > DELAY_CALIBRATE_TICS) ?
     53                              DELAY_CALIBRATE_TICS : 0;
   \   00004C   90FFEF       MOV       DPTR,#-0x11
   \   00004F   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000052   78..         MOV       R0,#?V0
   \   000054   12....       LCALL     ?L_MOV_X
   \   000057   90....       MOV       DPTR,#??DELAY_CALIBRATE_TICS
   \   00005A   78..         MOV       R0,#?V0
   \   00005C   12....       LCALL     ?UL_GT_X
   \   00005F   5011         JNC       ??UST_delay_0
   \   000061   90....       MOV       DPTR,#??DELAY_CALIBRATE_TICS
   \   000064   12....       LCALL     ?XLOAD_R0123
   \   000067   90FFFB       MOV       DPTR,#-0x5
   \   00006A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00006D   12....       LCALL     ?XSTORE_R0123
   \   000070   8015         SJMP      ??UST_delay_1
   \                     ??UST_delay_0:
   \   000072   90FFFB       MOV       DPTR,#-0x5
   \   000075   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000078   7400         MOV       A,#0x0
   \   00007A   F0           MOVX      @DPTR,A
   \   00007B   A3           INC       DPTR
   \   00007C   7400         MOV       A,#0x0
   \   00007E   F0           MOVX      @DPTR,A
   \   00007F   A3           INC       DPTR
   \   000080   7400         MOV       A,#0x0
   \   000082   F0           MOVX      @DPTR,A
   \   000083   A3           INC       DPTR
   \   000084   7400         MOV       A,#0x0
   \   000086   F0           MOVX      @DPTR,A
     54            while (UST_now() < (now + len - offset));
   \                     ??UST_delay_1:
   \   000087   90FFF3       MOV       DPTR,#-0xd
   \   00008A   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00008D   78..         MOV       R0,#?V0
   \   00008F   12....       LCALL     ?L_MOV_X
   \   000092   90FFF7       MOV       DPTR,#-0x9
   \   000095   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000098   78..         MOV       R0,#?V0
   \   00009A   12....       LCALL     ?L_ADD_X
   \   00009D   90FFFB       MOV       DPTR,#-0x5
   \   0000A0   12....       LCALL     ?EXT_STACK_DISP0_16
   \   0000A3   78..         MOV       R0,#?V0
   \   0000A5   12....       LCALL     ?L_SUB_X
   \   0000A8                ; Setup parameters for call to function UST_now
   \   0000A8   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   0000AB   8A..         MOV       ?V4,R2
   \   0000AD   8B..         MOV       ?V5,R3
   \   0000AF   8C..         MOV       ?V6,R4
   \   0000B1   8D..         MOV       ?V7,R5
   \   0000B3   78..         MOV       R0,#?V0
   \   0000B5   79..         MOV       R1,#?V4
   \   0000B7   12....       LCALL     ?UL_GT
   \   0000BA   40CB         JC        ??UST_delay_1
     55          }
   \   0000BC   74F0         MOV       A,#-0x10
   \   0000BE   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   0000C1   7F08         MOV       R7,#0x8
   \   0000C3   02....       LJMP      ?BANKED_LEAVE_SP
     56          
     57          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     58          stamp_t _interval(stamp_t beg, stamp_t end){
   \                     _interval:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 8
   \   000005   7408         MOV       A,#0x8
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
   \   00000A   90FFFB       MOV       DPTR,#-0x5
   \   00000D   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   EC           MOV       A,R4
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   ED           MOV       A,R5
   \   00001A   F0           MOVX      @DPTR,A
   \   00001B   90FFE5       MOV       DPTR,#-0x1b
   \   00001E   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000021   78..         MOV       R0,#?V0
   \   000023   12....       LCALL     ?L_MOV_X
     59            return (end >= beg) ? 
     60              (end - beg) :
     61              (MAC_TIMER_MAX - beg + end);
   \   000026   90FFFB       MOV       DPTR,#-0x5
   \   000029   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00002C   78..         MOV       R0,#?V0
   \   00002E   12....       LCALL     ?UL_GE_X
   \   000031   5018         JNC       ??_interval_0
   \   000033   90FFFB       MOV       DPTR,#-0x5
   \   000036   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000039   78..         MOV       R0,#?V0
   \   00003B   12....       LCALL     ?L_SUB_X
   \   00003E   90FFF7       MOV       DPTR,#-0x9
   \   000041   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000044   78..         MOV       R0,#?V0
   \   000046   12....       LCALL     ?L_MOV_TO_X
   \   000049   8025         SJMP      ??_interval_1
   \                     ??_interval_0:
   \   00004B   90....       MOV       DPTR,#??MAC_TIMER_MAX
   \   00004E   78..         MOV       R0,#?V4
   \   000050   12....       LCALL     ?L_MOV_X
   \   000053   90FFFB       MOV       DPTR,#-0x5
   \   000056   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000059   78..         MOV       R0,#?V4
   \   00005B   12....       LCALL     ?L_SUB_X
   \   00005E   78..         MOV       R0,#?V4
   \   000060   79..         MOV       R1,#?V0
   \   000062   12....       LCALL     ?L_ADD
   \   000065   90FFF7       MOV       DPTR,#-0x9
   \   000068   12....       LCALL     ?EXT_STACK_DISP0_16
   \   00006B   78..         MOV       R0,#?V4
   \   00006D   12....       LCALL     ?L_MOV_TO_X
   \                     ??_interval_1:
   \   000070   90FFF7       MOV       DPTR,#-0x9
   \   000073   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000076   12....       LCALL     ?XLOAD_R2345
   \   000079   74F8         MOV       A,#-0x8
   \   00007B   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00007E   7F08         MOV       R7,#0x8
   \   000080   02....       LJMP      ?BANKED_LEAVE_SP
     62          };
     63          
     64          /**
     65          @brief Калибровка функции задержки TIM_delay
     66          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     67          static void DelayCalibrate(void){
   \                     ??DelayCalibrate:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   7408         MOV       A,#0x8
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 4
   \   000005   7404         MOV       A,#0x4
   \   000007   12....       LCALL     ?ALLOC_EXT_STACK8
     68            DELAY_CALIBRATE_TICS = 0;  
   \   00000A   90....       MOV       DPTR,#??DELAY_CALIBRATE_TICS
   \   00000D   7400         MOV       A,#0x0
   \   00000F   F0           MOVX      @DPTR,A
   \   000010   A3           INC       DPTR
   \   000011   7400         MOV       A,#0x0
   \   000013   F0           MOVX      @DPTR,A
   \   000014   A3           INC       DPTR
   \   000015   7400         MOV       A,#0x0
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   7400         MOV       A,#0x0
   \   00001B   F0           MOVX      @DPTR,A
     69            stamp_t start = UST_now();
   \   00001C                ; Setup parameters for call to function UST_now
   \   00001C   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   00001F   90FFFB       MOV       DPTR,#-0x5
   \   000022   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000025   12....       LCALL     ?XSTORE_R2345
     70            UST_delay(ACCURATE_VAL_US);
   \   000028                ; Setup parameters for call to function UST_delay
   \   000028   90....       MOV       DPTR,#__Constant_1f4
   \   00002B   12....       LCALL     ?XLOAD_R2345
   \   00002E   12....       LCALL     `??UST_delay::?relay`; Banked call to: UST_delay
     71            stamp_t end = UST_now();
   \   000031                ; Setup parameters for call to function UST_now
   \   000031   12....       LCALL     `??UST_now::?relay`; Banked call to: UST_now
   \   000034   8A..         MOV       ?V0,R2
   \   000036   8B..         MOV       ?V1,R3
   \   000038   8C..         MOV       ?V2,R4
   \   00003A   8D..         MOV       ?V3,R5
     72            DELAY_CALIBRATE_TICS = _interval(start, end) -
     73                                    US_TO_TICKS(ACCURATE_VAL_US);
   \   00003C                ; Setup parameters for call to function _interval
   \   00003C   78..         MOV       R0,#?V0
   \   00003E   12....       LCALL     ?PUSH_ISTACK_I_FOUR
   \   000041   90FFF7       MOV       DPTR,#-0x9
   \   000044   12....       LCALL     ?EXT_STACK_DISP0_16
   \   000047   12....       LCALL     ?XLOAD_R2345
   \   00004A   12....       LCALL     `??_interval::?relay`; Banked call to: _interval
   \   00004D   74FC         MOV       A,#-0x4
   \   00004F   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   000052   8A..         MOV       ?V4,R2
   \   000054   8B..         MOV       ?V5,R3
   \   000056   8C..         MOV       ?V6,R4
   \   000058   8D..         MOV       ?V7,R5
   \   00005A   90....       MOV       DPTR,#__Constant_ffffc180
   \   00005D   78..         MOV       R0,#?V4
   \   00005F   12....       LCALL     ?L_ADD_X
   \   000062   90....       MOV       DPTR,#??DELAY_CALIBRATE_TICS
   \   000065   78..         MOV       R0,#?V4
   \   000067   12....       LCALL     ?L_MOV_TO_X
     74          };
   \   00006A   74FC         MOV       A,#-0x4
   \   00006C   12....       LCALL     ?DEALLOC_EXT_STACK8
   \   00006F   7F08         MOV       R7,#0x8
   \   000071   02....       LJMP      ?BANKED_LEAVE_SP
E:\Neocore\Hardware\PRJ Test\utest.c
      1          #include "utest.h"
      2          #include "macros.h"
      3          #include "stdio.h"
      4          #include "action_manager.h"
      5          #include "debug.h"
      6          

   \                                 In  segment XDATA_I, align 1, keep-with-next
      7          struct test_unit* TEST_FUN[] = TEST_FUN_DEF;
   \                     TEST_FUN:
   \   000000                DS 22
   \   000016                REQUIRE `?<Initializer for TEST_FUN>`
   \   000016                REQUIRE __INIT_XDATA_I
      8          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
      9          static int passed = 0;
   \                     ??passed:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     10          static int common_count = 0;
   \                     ??common_count:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     11          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     12          static inline void run_unit_fun(struct test_unit* unit){
   \                     ??run_unit_fun:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   7404         MOV       A,#0x4
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
     13            if (!unit->fun){
   \   000009   EE           MOV       A,R6
   \   00000A   2420         ADD       A,#0x20
   \   00000C   F582         MOV       DPL,A
   \   00000E   E4           CLR       A
   \   00000F   3F           ADDC      A,R7
   \   000010   F583         MOV       DPH,A
   \   000012   E0           MOVX      A,@DPTR
   \   000013   F8           MOV       R0,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   F9           MOV       R1,A
   \   000017   E8           MOV       A,R0
   \   000018   49           ORL       A,R1
   \   000019   7009         JNZ       ??run_unit_fun_1
     14            printf("Test function not assigned!!!");
   \   00001B                ; Setup parameters for call to function printf
   \   00001B   7A..         MOV       R2,#`?<Constant "Test function not ass...">` & 0xff
   \   00001D   7B..         MOV       R3,#(`?<Constant "Test function not ass...">` >> 8) & 0xff
   \   00001F   12....       LCALL     `??printf::?relay`; Banked call to: printf
     15            while(true);
   \                     ??run_unit_fun_2:
   \   000022   80FE         SJMP      ??run_unit_fun_2
     16            }
     17            int res;
     18            common_count++;
   \                     ??run_unit_fun_1:
   \   000024   90....       MOV       DPTR,#??common_count
   \   000027   E0           MOVX      A,@DPTR
   \   000028   2401         ADD       A,#0x1
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   A3           INC       DPTR
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   3400         ADDC      A,#0x0
   \   00002F   F0           MOVX      @DPTR,A
     19            res = unit->fun();
   \   000030                ; Setup parameters for indirect call
   \   000030   EE           MOV       A,R6
   \   000031   2420         ADD       A,#0x20
   \   000033   F582         MOV       DPL,A
   \   000035   E4           CLR       A
   \   000036   3F           ADDC      A,R7
   \   000037   F583         MOV       DPH,A
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   F8           MOV       R0,A
   \   00003B   A3           INC       DPTR
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F583         MOV       DPH,A
   \   00003F   8882         MOV       DPL,R0
   \   000041   12....       LCALL     ?CALL_IND
   \   000044   8A..         MOV       ?V2,R2
   \   000046   8B..         MOV       ?V3,R3
   \   000048   85....       MOV       ?V0,?V2
   \   00004B   85....       MOV       ?V1,?V3
     20            
     21            printf("TESTING:\t%-32s", unit->name);
   \   00004E                ; Setup parameters for call to function printf
   \   00004E   EE           MOV       A,R6
   \   00004F   C0E0         PUSH      A
   \   000051   EF           MOV       A,R7
   \   000052   C0E0         PUSH      A
   \   000054   7A..         MOV       R2,#`?<Constant "TESTING:\\t%-32s">` & 0xff
   \   000056   7B..         MOV       R3,#(`?<Constant "TESTING:\\t%-32s">` >> 8) & 0xff
   \   000058   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   00005B   D0E0         POP       A
   \   00005D   D0E0         POP       A
     22            if (res == 0){
   \   00005F   E5..         MOV       A,?V0
   \   000061   45..         ORL       A,?V1
   \   000063   7015         JNZ       ??run_unit_fun_3
     23              printf("\tPASSED\r\n");
   \   000065                ; Setup parameters for call to function printf
   \   000065   7A..         MOV       R2,#`?<Constant "\\tPASSED\\r\\n">` & 0xff
   \   000067   7B..         MOV       R3,#(`?<Constant "\\tPASSED\\r\\n">` >> 8) & 0xff
   \   000069   12....       LCALL     `??printf::?relay`; Banked call to: printf
     24              passed++;
   \   00006C   90....       MOV       DPTR,#??passed
   \   00006F   E0           MOVX      A,@DPTR
   \   000070   2401         ADD       A,#0x1
   \   000072   F0           MOVX      @DPTR,A
   \   000073   A3           INC       DPTR
   \   000074   E0           MOVX      A,@DPTR
   \   000075   3400         ADDC      A,#0x0
   \   000077   F0           MOVX      @DPTR,A
   \   000078   800F         SJMP      ??run_unit_fun_4
     25            }
     26            else
     27              printf("\tERR = %d. FAILED <--------------\r\n", res);           
   \                     ??run_unit_fun_3:
   \   00007A                ; Setup parameters for call to function printf
   \   00007A   C0..         PUSH      ?V0
   \   00007C   C0..         PUSH      ?V1
   \   00007E   7A..         MOV       R2,#`?<Constant "\\tERR = %d. FAILED <--...">` & 0xff
   \   000080   7B..         MOV       R3,#(`?<Constant "\\tERR = %d. FAILED <--...">` >> 8) & 0xff
   \   000082   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000085   D0E0         POP       A
   \   000087   D0E0         POP       A
     28          };
   \                     ??run_unit_fun_4:
   \   000089   7F04         MOV       R7,#0x4
   \   00008B   02....       LJMP      ?BANKED_LEAVE_SP
     29          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     30          static void show_grating(void){
   \                     ??show_grating:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     31            printf("Begin unit test\r\n");
   \   000000                ; Setup parameters for call to function printf
   \   000000   7A..         MOV       R2,#`?<Constant "Begin unit test\\r\\n">` & 0xff
   \   000002   7B..         MOV       R3,#(`?<Constant "Begin unit test\\r\\n">` >> 8) & 0xff
   \   000004   12....       LCALL     `??printf::?relay`; Banked call to: printf
     32          }
   \   000007   02....       LJMP      ?BRET
     33          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     34          static void show_statistic(void){
   \                     ??show_statistic:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     35            printf("\r\n##########################################\r\n");
   \   000004                ; Setup parameters for call to function printf
   \   000004   7A..         MOV       R2,#`?<Constant "\\r\\n###################...">` & 0xff
   \   000006   7B..         MOV       R3,#(`?<Constant "\\r\\n###################...">` >> 8) & 0xff
   \   000008   12....       LCALL     `??printf::?relay`; Banked call to: printf
     36            printf("Test runned: \t%d\r\n", common_count);
   \   00000B                ; Setup parameters for call to function printf
   \   00000B   90....       MOV       DPTR,#??common_count
   \   00000E   12....       LCALL     ?PUSH_ISTACK_X_TWO
   \   000011   7A..         MOV       R2,#`?<Constant "Test runned: \\t%d\\r\\n">` & 0xff
   \   000013   7B..         MOV       R3,#(`?<Constant "Test runned: \\t%d\\r\\n">` >> 8) & 0xff
   \   000015   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000018   D0E0         POP       A
   \   00001A   D0E0         POP       A
     37            printf("Test passed: \t%d\r\n", passed);
   \   00001C                ; Setup parameters for call to function printf
   \   00001C   90....       MOV       DPTR,#??passed
   \   00001F   12....       LCALL     ?PUSH_ISTACK_X_TWO
   \   000022   7A..         MOV       R2,#`?<Constant "Test passed: \\t%d\\r\\n">` & 0xff
   \   000024   7B..         MOV       R3,#(`?<Constant "Test passed: \\t%d\\r\\n">` >> 8) & 0xff
   \   000026   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000029   D0E0         POP       A
   \   00002B   D0E0         POP       A
     38            if (common_count == passed)
   \   00002D   90....       MOV       DPTR,#??common_count
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F8           MOV       R0,A
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   F9           MOV       R1,A
   \   000035   90....       MOV       DPTR,#??passed
   \   000038   E0           MOVX      A,@DPTR
   \   000039   68           XRL       A,R0
   \   00003A   7003         JNZ       ??show_statistic_1
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   69           XRL       A,R1
   \                     ??show_statistic_1:
   \   00003F   7009         JNZ       ??show_statistic_2
     39              printf("Succes!\r\n");
   \   000041                ; Setup parameters for call to function printf
   \   000041   7A..         MOV       R2,#`?<Constant "Succes!\\r\\n">` & 0xff
   \   000043   7B..         MOV       R3,#(`?<Constant "Succes!\\r\\n">` >> 8) & 0xff
   \   000045   12....       LCALL     `??printf::?relay`; Banked call to: printf
   \   000048   8007         SJMP      ??show_statistic_3
     40            else
     41              printf("Failed!\r\n");
   \                     ??show_statistic_2:
   \   00004A                ; Setup parameters for call to function printf
   \   00004A   7A..         MOV       R2,#`?<Constant "Failed!\\r\\n">` & 0xff
   \   00004C   7B..         MOV       R3,#(`?<Constant "Failed!\\r\\n">` >> 8) & 0xff
   \   00004E   12....       LCALL     `??printf::?relay`; Banked call to: printf
     42          }
   \                     ??show_statistic_3:
   \   000051   D0..         POP       ?V1
   \   000053   D0..         POP       ?V0
   \   000055   02....       LJMP      ?BRET
     43          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     44          void run_tests(void){
   \                     run_tests:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   7402         MOV       A,#0x2
   \   000002   12....       LCALL     ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 5
   \   000005                ; Auto size: 0
     45            show_grating();
   \   000005                ; Setup parameters for call to function show_grating
   \   000005   12....       LCALL     `??show_grating::?relay`; Banked call to: show_grating
     46            struct test_unit* unit;
     47            for (int i = 0; i < sizeof(TEST_FUN)/sizeof(struct test_unit*); i++){
   \   000008   7E00         MOV       R6,#0x0
   \   00000A   7F00         MOV       R7,#0x0
   \                     ??run_tests_0:
   \   00000C   C3           CLR       C
   \   00000D   EE           MOV       A,R6
   \   00000E   940B         SUBB      A,#0xb
   \   000010   EF           MOV       A,R7
   \   000011   9400         SUBB      A,#0x0
   \   000013   503D         JNC       ??run_tests_1
     48              unit = TEST_FUN[i];
   \   000015   EE           MOV       A,R6
   \   000016   F8           MOV       R0,A
   \   000017   EF           MOV       A,R7
   \   000018   F9           MOV       R1,A
   \   000019   E8           MOV       A,R0
   \   00001A   75F002       MOV       B,#0x2
   \   00001D   A4           MUL       AB
   \   00001E   C8           XCH       A,R0
   \   00001F   AAF0         MOV       R2,B
   \   000021   75F000       MOV       B,#0x0
   \   000024   A4           MUL       AB
   \   000025   2A           ADD       A,R2
   \   000026   FA           MOV       R2,A
   \   000027   75F002       MOV       B,#0x2
   \   00002A   E9           MOV       A,R1
   \   00002B   A4           MUL       AB
   \   00002C   2A           ADD       A,R2
   \   00002D   F9           MOV       R1,A
   \   00002E   74..         MOV       A,#TEST_FUN & 0xff
   \   000030   28           ADD       A,R0
   \   000031   F582         MOV       DPL,A
   \   000033   74..         MOV       A,#(TEST_FUN >> 8) & 0xff
   \   000035   39           ADDC      A,R1
   \   000036   F583         MOV       DPH,A
   \   000038   E0           MOVX      A,@DPTR
   \   000039   F8           MOV       R0,A
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   F9           MOV       R1,A
   \   00003D   88..         MOV       ?V0,R0
   \   00003F   89..         MOV       ?V1,R1
     49              AM_SW_Init();
   \   000041                ; Setup parameters for call to function AM_SW_Init
   \   000041   12....       LCALL     `??AM_SW_Init::?relay`; Banked call to: AM_SW_Init
     50              run_unit_fun(unit);
   \   000044                ; Setup parameters for call to function run_unit_fun
   \   000044   AA..         MOV       R2,?V0
   \   000046   AB..         MOV       R3,?V1
   \   000048   12....       LCALL     `??run_unit_fun::?relay`; Banked call to: run_unit_fun
     51            };
   \   00004B   0E           INC       R6
   \   00004C   EE           MOV       A,R6
   \   00004D   70BD         JNZ       ??run_tests_0
   \   00004F   0F           INC       R7
   \   000050   80BA         SJMP      ??run_tests_0
     52            show_statistic();  
   \                     ??run_tests_1:
   \   000052                ; Setup parameters for call to function show_statistic
   \   000052   12....       LCALL     `??show_statistic::?relay`; Banked call to: show_statistic
     53          }
   \   000055   7F02         MOV       R7,#0x2
   \   000057   02....       LJMP      ?BANKED_LEAVE_SP

   \                                 In  segment INTVEC, offset 0x2b, root
   \                     `??TimerCompareInterrupt::??INTVEC 43`:
   \   00002B   02....       LJMP       (TimerCompareInterrupt)

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for COLD_MOD>`:
   \   000000   ....         DW SYNC_MODULE
   \   000002   ....         DW LLC_MODULE
   \   000004   ....         DW LED_MODULE

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for HOT_MOD>`:
   \   000000   ....         DW RTC_MODULE
   \   000002   ....         DW SYNC_MODULE
   \   000004   ....         DW LLC_MODULE
   \   000006   ....         DW LED_MODULE

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for HW_MOD>`:
   \   000000   ....         DW CPU_MODULE
   \   000002   ....         DW DBG_MODULE
   \   000004   ....         DW AT_MODULE
   \   000006   ....         DW UST_MODULE
   \   000008   ....         DW DMA_MODULE
   \   00000A   ....         DW CODER_MODULE
   \   00000C   ....         DW RADIO_MODULE
   \   00000E   ....         DW LED_MODULE

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for SW_MOD>`:
   \   000000   ....         DW FR_MODULE
   \   000002   ....         DW MD_MODULE
   \   000004   ....         DW MS_MODULE
   \   000006   ....         DW BF_MODULE
   \   000008   ....         DW RADIO_MODULE
   \   00000A   ....         DW SYNC_MODULE
   \   00000C   ....         DW LLC_MODULE
   \   00000E   ....         DW MAC_MODULE

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for IRQ_MOD>`:
   \   000000   ....         DW BF_MODULE
   \   000002   ....         DW MAC_MODULE
   \   000004   ....         DW LLC_MODULE

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for AT_MODULE>`:
   \   000000   ....         DW `??HW_Init::?relay`
   \   000002   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for BF_MODULE>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??SW_Init::?relay`
   \   000004   ....         DW `??IRQ_Init::?relay`
   \   000006   00000000     DB 0, 0, 0, 0

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for TX_LIST_HEAD>`:
   \   000000   ....         DW TX_LIST_HEAD
   \   000002   ....         DW TX_LIST_HEAD

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for RX_LIST_HEAD>`:
   \   000000   ....         DW RX_LIST_HEAD
   \   000002   ....         DW RX_LIST_HEAD

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for CODER_MODULE>`:
   \   000000   ....         DW `??HW_Init::?relay_1`
   \   000002   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for CPU_MODULE>`:
   \   000000   ....         DW `??HW_Init::?relay_2`
   \   000002   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for DBG_MODULE>`:
   \   000000   ....         DW `??HW_Init::?relay_3`
   \   000002   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for DMA_MODULE>`:
   \   000000   ....         DW `??HW_Init::?relay_4`
   \   000002   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for FR_MODULE>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??SW_Init::?relay_1`
   \   000004   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for LED_MODULE>`:
   \   000000   ....         DW `??HW_Init::?relay_5`
   \   000002   ....         DW `??SW_Init::?relay_2`
   \   000004   0000         DW 0H
   \   000006   ....         DW `??Cold_Start::?relay`
   \   000008   ....         DW `??Hot_Start::?relay`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for LLC_MODULE>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??SW_Init::?relay_3`
   \   000004   ....         DW `??IRQ_Init::?relay_1`
   \   000006   ....         DW `??Cold_Start::?relay_1`
   \   000008   ....         DW `??Hot_Start::?relay_1`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for MAC_MODULE>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??SW_Init::?relay_4`
   \   000004   ....         DW `??IRQ_Init::?relay_2`
   \   000006   00000000     DB 0, 0, 0, 0

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for MS_MODULE>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??SW_Init::?relay_5`
   \   000004   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for MD_MODULE>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??SW_Init::?relay_6`
   \   000004   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for RADIO_MODULE>`:
   \   000000   ....         DW `??HW_Init::?relay_6`
   \   000002   ....         DW `??SW_Init::?relay_7`
   \   000004   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for RTC_MODULE>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??SW_Init::?relay_8`
   \   000004   0000         DW 0H
   \   000006   ....         DW `??Cold_Start::?relay_2`
   \   000008   ....         DW `??Hot_Start::?relay_2`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for SYNC_MODULE>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??SW_Init::?relay_9`
   \   000004   0000         DW 0H
   \   000006   ....         DW `??Cold_Start::?relay_3`
   \   000008   ....         DW `??Hot_Start::?relay_3`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_BF_1>`:
   \   000000   42463A70     DB "BF:push tx"
   \            75736820
   \            747800  
   \   00000B   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000013   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001B   00000000     DB 0, 0, 0, 0, 0
   \            00      
   \   000020   ....         DW `??test1::?relay`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_BF_2>`:
   \   000000   42463A70     DB "BF:push-pop tx all"
   \            7573682D
   \            706F7020
   \            74782061
   \            6C6C00  
   \   000013   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001B   00000000     DB 0, 0, 0, 0, 0
   \            00      
   \   000020   ....         DW `??test2::?relay`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_BF_3>`:
   \   000000   42463A6D     DB "BF:mix rx-tx bufs"
   \            69782072
   \            782D7478
   \            20627566
   \            7300    
   \   000012   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001A   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    
   \   000020   ....         DW `??test3::?relay`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UTEST_DEBUG>`:
   \   000000   44454255     DB "DEBUG MODUL"
   \            47204D4F
   \            44554C00
   \   00000C   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000014   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001C   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_FR_1>`:
   \   000000   46523A63     DB "FR:create-delete"
   \            72656174
   \            652D6465
   \            6C657465
   \            00      
   \   000011   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000019   00000000     DB 0, 0, 0, 0, 0, 0, 0
   \            000000  
   \   000020   ....         DW `??test1::?relay_1`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_FR_2>`:
   \   000000   46523A63     DB "FR:create-full"
   \            72656174
   \            652D6675
   \            6C6C00  
   \   00000F   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000017   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001F   00           DB 0
   \   000020   ....         DW `??test2::?relay_1`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_FR_3>`:
   \   000000   46523A68     DB "FR:header manipulation"
   \            65616465
   \            72206D61
   \            6E697075
   \            6C617469
   \            6F6E00  
   \   000017   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001F   00           DB 0
   \   000020   ....         DW `??test3::?relay_1`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_MACR_1>`:
   \   000000   4D414352     DB "MACROS: EXCEPTIOS"
   \            4F533A20
   \            45584345
   \            5054494F
   \            5300    
   \   000012   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001A   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    
   \   000020   ....         DW `??test1::?relay_2`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_MACR_2>`:
   \   000000   4D414352     DB "MACROS: EXCEPTIOS"
   \            4F533A20
   \            45584345
   \            5054494F
   \            5300    
   \   000012   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001A   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    
   \   000020   ....         DW `??test2::?relay_2`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_MS_1>`:
   \   000000   4D533A63     DB "MS:create-delete"
   \            72656174
   \            652D6465
   \            6C657465
   \            00      
   \   000011   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000019   00000000     DB 0, 0, 0, 0, 0, 0, 0
   \            000000  
   \   000020   ....         DW `??test1::?relay_3`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_MS_2>`:
   \   000000   4D533A63     DB "MS:create-full"
   \            72656174
   \            652D6675
   \            6C6C00  
   \   00000F   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000017   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001F   00           DB 0
   \   000020   ....         DW `??test2::?relay_3`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UT_MS_3>`:
   \   000000   4D533A7A     DB "MS:zone-check"
   \            6F6E652D
   \            63686563
   \            6B00    
   \   00000E   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000016   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001E   0000         DB 0, 0
   \   000020   ....         DW `??test3::?relay_2`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for UST_MODULE>`:
   \   000000   ....         DW `??HW_Init::?relay_7`
   \   000002   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for TEST_FUN>`:
   \   000000   ....         DW UT_MS_1
   \   000002   ....         DW UT_MS_2
   \   000004   ....         DW UT_MS_3
   \   000006   ....         DW UT_FR_1
   \   000008   ....         DW UT_FR_2
   \   00000A   ....         DW UT_FR_3
   \   00000C   ....         DW UT_BF_1
   \   00000E   ....         DW UT_BF_2
   \   000010   ....         DW UT_BF_3
   \   000012   ....         DW UT_MACR_1
   \   000014   ....         DW UT_MACR_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AM_set_callback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AM_set_callback

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AM_Callback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AM_Callback

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AM_Cold_start::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AM_Cold_start

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AM_Hot_start::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AM_Hot_start

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AM_HW_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AM_HW_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AM_SW_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AM_SW_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AM_IRQ_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AM_IRQ_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??__cli::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??__cli

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HW_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??HW_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AT_enable::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AT_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AT_interval::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AT_interval

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AT_set_time::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AT_set_time

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AT_time::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AT_time

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AT_wait::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AT_wait

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??IRQEnable::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??IRQEnable

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AT_set_alarm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AT_set_alarm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??calcCompareTime::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??calcCompareTime

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ReadTimer::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??ReadTimer

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??loadTimerCompare::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??loadTimerCompare

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??isIRQEnable::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??isIRQEnable

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??__cli::?relay_1`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??__cli_1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??INIT_LIST_HEAD::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??INIT_LIST_HEAD

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??__list_add_valid::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??__list_add_valid

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??__list_del_entry_valid::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??__list_del_entry_valid

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??__list_add::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??__list_add

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??list_add::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??list_add

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??__list_del::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??__list_del

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??__list_del_entry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??__list_del_entry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??list_del::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??list_del

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??list_is_last::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??list_is_last

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??list_empty::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??list_empty

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??IRQ_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??IRQ_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SW_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SW_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_rx_busy::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_rx_busy

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_tx_busy::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_tx_busy

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_available::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_available

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_available_tx::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_available_tx

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_available_rx::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_available_rx

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??find_free_node::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??find_free_node

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_push::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??_push

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_push_tx::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_push_tx

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_push_rx::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_push_rx

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_cursor_rx::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_cursor_rx

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_cursor_tx::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_cursor_tx

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_cursor_next::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_cursor_next

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_remove_tx::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_remove_tx

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_remove_rx::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_remove_rx

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BF_content::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BF_content

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HW_Init::?relay_1`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??HW_Init_1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AES_StreamCoder::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AES_StreamCoder

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??CTR_enc_decrypt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??CTR_enc_decrypt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??CBCMAC_buf_encrypt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??CBCMAC_buf_encrypt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??generateAuthData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??generateAuthData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AES_CCMEncrypt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AES_CCMEncrypt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??AES_CCMDecrypt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AES_CCMDecrypt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HW_Init::?relay_2`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??HW_Init_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HW_Init::?relay_3`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??HW_Init_3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??DBG_CORE_HALT::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    DBG_CORE_HALT

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??DBG_CORE_FAULT::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    DBG_CORE_FAULT

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??uart_init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??uart_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MyLowLevelPutchar::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MyLowLevelPutchar

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??__write::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    __write

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HW_Init::?relay_4`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??HW_Init_4

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SW_Init::?relay_1`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SW_Init_1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??FR_create::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    FR_create

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??FR_delete::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    FR_delete

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??FR_add_header::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    FR_add_header

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??FR_del_header::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    FR_del_header

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??FR_busy::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    FR_busy

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??FR_available::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    FR_available

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HW_Init::?relay_5`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??HW_Init_5

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SW_Init::?relay_2`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SW_Init_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Cold_Start::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??Cold_Start

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Hot_Start::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??Hot_Start

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??IRQ_Init::?relay_1`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??IRQ_Init_1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SW_Init::?relay_3`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SW_Init_3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??LLC_open_slot::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    LLC_open_slot

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??LLC_close_slot::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    LLC_close_slot

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??LLC_add_tx_frame::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    LLC_add_tx_frame

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??scheduler_tx::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??scheduler_tx

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??scheduler_rx::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??scheduler_rx

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Cold_Start::?relay_1`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??Cold_Start_1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??receive::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??receive

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??transmite::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??transmite

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Hot_Start::?relay_1`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??Hot_Start_1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SW_Init::?relay_4`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SW_Init_4

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??IRQ_Init::?relay_2`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??IRQ_Init_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_recv_frame::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??_recv_frame

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??xor_calc::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??xor_calc

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_send_ack::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??_send_ack

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MAC_Receive::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MAC_Receive

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_send_frame::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??_send_frame

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_recv_ack::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??_recv_ack

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MAC_Send::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MAC_Send

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??main::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    main

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??is_array_ptr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??is_array_ptr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??array_index::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??array_index

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??__cli::?relay_2`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??__cli_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SW_Init::?relay_5`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SW_Init_5

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SL_alloc::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SL_alloc

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_free::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??_free

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SL_free::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SL_free

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SL_busy::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SL_busy

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SL_available::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SL_available

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SL_zone_check::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SL_zone_check

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MEM_memcpy::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MEM_memcpy

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MEM_memset::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MEM_memset

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SW_Init::?relay_6`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SW_Init_6

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SW_Init::?relay_7`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SW_Init_7

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HW_Init::?relay_6`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??HW_Init_6

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??setFreq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??setFreq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??pre_config::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??pre_config

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??RI_SetChannel::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    RI_SetChannel

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??LoadTXData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??LoadTXData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SendData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SendData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??RI_Send::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    RI_Send

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??UnLoadRXData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??UnLoadRXData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??RecvData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??RecvData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??RI_Receive::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    RI_Receive

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bits_count::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??bits_count

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??getRNDByte::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??getRNDByte

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??readRandom::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??readRandom

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??random_core_init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??random_core_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??RI_Measure_POW::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    RI_Measure_POW

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SW_Init::?relay_8`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SW_Init_8

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Cold_Start::?relay_2`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??Cold_Start_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Hot_Start::?relay_2`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??Hot_Start_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??SW_Init::?relay_9`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??SW_Init_9

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Cold_Start::?relay_3`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??Cold_Start_3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??validate_sync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??validate_sync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??accept_sync_data::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??accept_sync_data

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??syncronize_timer::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??syncronize_timer

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??mode_1_receive_process::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??mode_1_receive_process

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_throw_dice::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??_throw_dice

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??mode_1_retransmition_process::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??mode_1_retransmition_process

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??mode_1_process::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??mode_1_process

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??mode_2_process::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??mode_2_process

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Hot_Start::?relay_3`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??Hot_Start_3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??recv_sync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??recv_sync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??send_sync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??send_sync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??network_recv_sync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??network_recv_sync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??network_sync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    network_sync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??__cli::?relay_3`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??__cli_3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??TM_SetAlarm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    TM_SetAlarm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??TM_ClrAlarm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    TM_ClrAlarm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_inc_timeslot::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??_inc_timeslot

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_find_next_active::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??_find_next_active

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??scheulder_next_alarm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??scheulder_next_alarm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??TM_IRQ::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    TM_IRQ

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??mcu_sleep::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??mcu_sleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_clr_all::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??_clr_all

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??start_mode_1::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??start_mode_1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??start_mode_2::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??start_mode_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Neocore_start::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Neocore_start

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??u_alarm_timer::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    u_alarm_timer

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test3::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test2::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test1::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ch_cmp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??ch_cmp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ch_cmp_val::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??ch_cmp_val

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test3::?relay_1`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test3_1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test2::?relay_1`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test2_1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test1::?relay_1`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test1_1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test2::?relay_2`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test2_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test1::?relay_2`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test1_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test3::?relay_2`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test3_2

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test2::?relay_3`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test2_3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??test1::?relay_3`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??test1_3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??u_mem_utils::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    u_mem_utils

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HW_Init::?relay_7`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??HW_Init_7

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??UST_now::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    UST_now

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??UST_time_over::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    UST_time_over

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??UST_interval::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    UST_interval

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??UST_delay::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    UST_delay

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_interval::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _interval

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??DelayCalibrate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??DelayCalibrate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??run_unit_fun::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??run_unit_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??show_grating::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??show_grating

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??show_statistic::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??show_statistic

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??run_tests::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    run_tests

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "!%s:%d\\r\\n">`:
   \   000000   2125733A     DB "!%s:%d\015\012"
   \            25640D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "action_manager.c">`:
   \   000000   61637469     DB "action_manager.c"
   \            6F6E5F6D
   \            616E6167
   \            65722E63
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "!%s:%d\\r\\n">_1`:
   \   000000   2125733A     DB "!%s:%d\015\012"
   \            25640D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "alarm_timer.c">`:
   \   000000   616C6172     DB "alarm_timer.c"
   \            6D5F7469
   \            6D65722E
   \            6300    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "!%s:%d\\r\\n">_2`:
   \   000000   2125733A     DB "!%s:%d\015\012"
   \            25640D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "buffer.c">`:
   \   000000   62756666     DB "buffer.c"
   \            65722E63
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,`:
   \   000000   01           DB 1
   \   000001   02           DB 2
   \   000002   03           DB 3
   \   000003   04           DB 4
   \   000004   05           DB 5
   \   000005   06           DB 6
   \   000006   07           DB 7
   \   000007   08           DB 8
   \   000008   09           DB 9
   \   000009   0A           DB 10
   \   00000A   0B           DB 11
   \   00000B   0C           DB 12
   \   00000C   0D           DB 13
   \   00000D   0E           DB 14
   \   00000E   0F           DB 15
   \   00000F   10           DB 16

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_1`:
   \   000000   01           DB 1
   \   000001   02           DB 2
   \   000002   03           DB 3
   \   000003   04           DB 4
   \   000004   05           DB 5
   \   000005   06           DB 6
   \   000006   07           DB 7
   \   000007   08           DB 8
   \   000008   09           DB 9
   \   000009   0A           DB 10
   \   00000A   0B           DB 11
   \   00000B   0C           DB 12
   \   00000C   0D           DB 13
   \   00000D   0E           DB 14
   \   00000E   0F           DB 15
   \   00000F   10           DB 16

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_2`:
   \   000000   01           DB 1
   \   000001   02           DB 2
   \   000002   03           DB 3
   \   000003   04           DB 4
   \   000004   05           DB 5
   \   000005   06           DB 6
   \   000006   07           DB 7
   \   000007   08           DB 8
   \   000008   09           DB 9
   \   000009   0A           DB 10
   \   00000A   0B           DB 11
   \   00000B   0C           DB 12
   \   00000C   0D           DB 13
   \   00000D   0E           DB 14
   \   00000E   0F           DB 15
   \   00000F   10           DB 16

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_3`:
   \   000000   01           DB 1
   \   000001   02           DB 2
   \   000002   03           DB 3
   \   000003   04           DB 4
   \   000004   05           DB 5
   \   000005   06           DB 6
   \   000006   07           DB 7
   \   000007   08           DB 8
   \   000008   09           DB 9
   \   000009   0A           DB 10
   \   00000A   0B           DB 11
   \   00000B   0C           DB 12
   \   00000C   0D           DB 13
   \   00000D   0E           DB 14
   \   00000E   0F           DB 15
   \   00000F   10           DB 16

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "!%s:%d\\r\\n">_3`:
   \   000000   2125733A     DB "!%s:%d\015\012"
   \            25640D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "llc.c">`:
   \   000000   6C6C632E     DB "llc.c"
   \            6300    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%s:%d:%s -> ">`:
   \   000000   25733A25     DB "%s:%d:%s -> "
   \            643A2573
   \            202D3E20
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Error">`:
   \   000000   4572726F     DB "Error"
   \            7200    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Send success">`:
   \   000000   53656E64     DB "Send success"
   \            20737563
   \            63657373
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "\\r\\n">`:
   \   000000   0D0A00       DB "\015\012"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "CCA/ACK err">`:
   \   000000   4343412F     DB "CCA/ACK err"
   \            41434B20
   \            65727200

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Attempts exired">`:
   \   000000   41747465     DB "Attempts exired"
   \            6D707473
   \            20657869
   \            72656400

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%s:%d:%s -> ">_1`:
   \   000000   25733A25     DB "%s:%d:%s -> "
   \            643A2573
   \            202D3E20
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "mac.c">`:
   \   000000   6D61632E     DB "mac.c"
   \            6300    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Wrong channel">`:
   \   000000   57726F6E     DB "Wrong channel"
   \            67206368
   \            616E6E65
   \            6C00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "push">`:
   \   000000   70757368     DB "push"
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "\\r\\n">_1`:
   \   000000   0D0A00       DB "\015\012"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "push del">`:
   \   000000   70757368     DB "push del"
   \            2064656C
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "!%s:%d\\r\\n">_4`:
   \   000000   2125733A     DB "!%s:%d\015\012"
   \            25640D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "mem_slots.c">`:
   \   000000   6D656D5F     DB "mem_slots.c"
   \            736C6F74
   \            732E6300

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "!%s:%d\\r\\n">_5`:
   \   000000   2125733A     DB "!%s:%d\015\012"
   \            25640D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "radio.c">`:
   \   000000   72616469     DB "radio.c"
   \            6F2E6300

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%s:%d:%s -> ">_2`:
   \   000000   25733A25     DB "%s:%d:%s -> "
   \            643A2573
   \            202D3E20
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "sync.c">`:
   \   000000   73796E63     DB "sync.c"
   \            2E6300  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Sync err %d">`:
   \   000000   53796E63     DB "Sync err %d"
   \            20657272
   \            20256400

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "\\r\\n">_2`:
   \   000000   0D0A00       DB "\015\012"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Sichronize sync RSSI ...">`:
   \   000000   53696368     DB "Sichronize sync RSSI = %d"
   \            726F6E69
   \            7A652073
   \            796E6320
   \            52535349
   \            203D2025
   \            6400    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "unsynced">`:
   \   000000   756E7379     DB "unsynced"
   \            6E636564
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Wrong mode">`:
   \   000000   57726F6E     DB "Wrong mode"
   \            67206D6F
   \            646500  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Wrong channel">_1`:
   \   000000   57726F6E     DB "Wrong channel"
   \            67206368
   \            616E6E65
   \            6C00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "!%s:%d\\r\\n">_6`:
   \   000000   2125733A     DB "!%s:%d\015\012"
   \            25640D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "SYNC sended, res = %d">`:
   \   000000   53594E43     DB "SYNC sended, res = %d"
   \            2073656E
   \            6465642C
   \            20726573
   \            203D2025
   \            6400    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "!%s:%d\\r\\n">_7`:
   \   000000   2125733A     DB "!%s:%d\015\012"
   \            25640D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "time_manager.c">`:
   \   000000   74696D65     DB "time_manager.c"
   \            5F6D616E
   \            61676572
   \            2E6300  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%s:%d:%s -> ">_3`:
   \   000000   25733A25     DB "%s:%d:%s -> "
   \            643A2573
   \            202D3E20
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Incorrect MODEL.TM.MODE">`:
   \   000000   496E636F     DB "Incorrect MODEL.TM.MODE"
   \            72726563
   \            74204D4F
   \            44454C2E
   \            544D2E4D
   \            4F444500

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}>`:
   \   000000   01           DB 1
   \   000001   02           DB 2
   \   000002   03           DB 3
   \   000003   04           DB 4
   \   000004   05           DB 5
   \   000005   06           DB 6
   \   000006   07           DB 7
   \   000007   08           DB 8
   \   000008   09           DB 9
   \   000009   0A           DB 10

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}>_1`:
   \   000000   01           DB 1
   \   000001   02           DB 2
   \   000002   03           DB 3
   \   000003   04           DB 4
   \   000004   05           DB 5
   \   000005   06           DB 6
   \   000006   07           DB 7
   \   000007   08           DB 8
   \   000008   09           DB 9
   \   000009   0A           DB 10

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "!%s:%d\\r\\n">_8`:
   \   000000   2125733A     DB "!%s:%d\015\012"
   \            25640D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "u_mem_utils.c">`:
   \   000000   755F6D65     DB "u_mem_utils.c"
   \            6D5F7574
   \            696C732E
   \            6300    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%s:%d:%s -> ">_4`:
   \   000000   25733A25     DB "%s:%d:%s -> "
   \            643A2573
   \            202D3E20
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "MEM_memcpy ok!">`:
   \   000000   4D454D5F     DB "MEM_memcpy ok!"
   \            6D656D63
   \            7079206F
   \            6B2100  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "\\r\\n">_3`:
   \   000000   0D0A00       DB "\015\012"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "MEM_memset ok!">`:
   \   000000   4D454D5F     DB "MEM_memset ok!"
   \            6D656D73
   \            6574206F
   \            6B2100  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Test function not ass...">`:
   \   000000   54657374     DB "Test function not assigned!!!"
   \            2066756E
   \            6374696F
   \            6E206E6F
   \            74206173
   \            7369676E
   \            65642121
   \            2100    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "TESTING:\\t%-32s">`:
   \   000000   54455354     DB "TESTING:\t%-32s"
   \            494E473A
   \            09252D33
   \            327300  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "\\tPASSED\\r\\n">`:
   \   000000   09504153     DB "\tPASSED\015\012"
   \            5345440D
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "\\tERR = %d. FAILED <--...">`:
   \   000000   09455252     DB "\tERR = %d. FAILED <--------------\015\012"
   \            203D2025
   \            642E2046
   \            41494C45
   \            44203C2D
   \            2D2D2D2D
   \            2D2D2D2D
   \            2D2D2D2D
   \            2D0D0A00

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Begin unit test\\r\\n">`:
   \   000000   42656769     DB "Begin unit test\015\012"
   \            6E20756E
   \            69742074
   \            6573740D
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "\\r\\n###################...">`:
   \   000000   0D0A2323     DB "\015\012##########################################\015\012"
   \            23232323
   \            23232323
   \            23232323
   \            23232323
   \            23232323
   \            23232323
   \            23232323
   \            23232323
   \            23232323
   \            23232323
   \            0D0A00  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Test runned: \\t%d\\r\\n">`:
   \   000000   54657374     DB "Test runned: \t%d\015\012"
   \            2072756E
   \            6E65643A
   \            20092564
   \            0D0A00  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Test passed: \\t%d\\r\\n">`:
   \   000000   54657374     DB "Test passed: \t%d\015\012"
   \            20706173
   \            7365643A
   \            20092564
   \            0D0A00  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Succes!\\r\\n">`:
   \   000000   53756363     DB "Succes!\015\012"
   \            6573210D
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Failed!\\r\\n">`:
   \   000000   4661696C     DB "Failed!\015\012"
   \            6564210D
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_7fff:
   \   000000   FF7F0000     DD 32767

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffff8000:
   \   000000   0080FFFF     DD 4294934528

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_8000:
   \   000000   00800000     DD 32768

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffffff:
   \   000000   FFFFFF00     DD 16777215

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_9c4:
   \   000000   C4090000     DD 2500

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_396:
   \   000000   96030000     DD 918

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_19833891:
   \   000000   91388319     DD 428030097

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_a:
   \   000000   0A000000     DD 10

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3d:
   \   000000   3D000000     DD 61

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_20:
   \   000000   20000000     DD 32

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1f4:
   \   000000   F4010000     DD 500

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffffc180:
   \   000000   80C1FFFF     DD 4294951296

   Maximum stack usage in bytes:

   EXT_STACK Function
   --------- --------
        67   AES_CCMDecrypt
          61   -> CBCMAC_buf_encrypt
          65   -> CTR_enc_decrypt
          63   -> generateAuthData
          63   -> memcpy
          63   -> memset
        51   AES_CCMEncrypt
          45   -> CBCMAC_buf_encrypt
          49   -> CTR_enc_decrypt
          47   -> generateAuthData
          47   -> memcpy
          47   -> memset
        96   AES_StreamCoder
          37   -> memcpy
          37   -> memset
         4   AM_Callback
           0   -> DBG_CORE_HALT
           4   -> printf
         8   AM_Cold_start
           1   -> DBG_CORE_HALT
           5   -> printf
         5   AM_HW_Init
           1   -> DBG_CORE_HALT
           5   -> printf
         8   AM_Hot_start
           1   -> DBG_CORE_HALT
           5   -> printf
         5   AM_IRQ_Init
           1   -> DBG_CORE_HALT
           5   -> printf
        10   AM_SW_Init
           1   -> DBG_CORE_HALT
           5   -> printf
         6   AM_set_callback
           2   -> DBG_CORE_HALT
           6   -> printf
         5   AT_enable
           2   -> IRQEnable
           2   -> __cli
         9   AT_interval
        20   AT_set_alarm
           7   -> DBG_CORE_HALT
           7   -> IRQEnable
           7   -> calcCompareTime
           7   -> loadTimerCompare
          11   -> printf
        22   AT_set_time
           9   -> AT_set_alarm
           9   -> DBG_CORE_HALT
           9   -> ReadTimer
           9   -> isIRQEnable
          13   -> printf
        74   AT_time
          11   -> ReadTimer
        70   AT_wait
           7   -> DBG_CORE_HALT
          11   -> printf
        59   BF_available
           2   -> DBG_CORE_HALT
           6   -> printf
         0   BF_available_rx
         0   BF_available_tx
        53   BF_content
       114   BF_cursor_next
          61   -> __cli
          61   -> list_is_last
        58   BF_cursor_rx
           5   -> __cli
           5   -> list_empty
        58   BF_cursor_tx
           5   -> __cli
           5   -> list_empty
        57   BF_push_rx
           4   -> __cli
           4   -> _push
        57   BF_push_tx
           4   -> __cli
           4   -> _push
         6   BF_remove_rx
           6   -> __cli
           6   -> list_del
        59   BF_remove_tx
           6   -> __cli
           6   -> list_del
        53   BF_rx_busy
        53   BF_tx_busy
       104   CBCMAC_buf_encrypt
          43   -> memcpy
          43   -> memset
        98   CTR_enc_decrypt
          33   -> memcpy
          33   -> memset
         0   Cold_Start
         0   Cold_Start
           0   -> scheduler_rx
           0   -> scheduler_tx
         0   Cold_Start
         0   Cold_Start
         0   DBG_CORE_FAULT
        59   DBG_CORE_HALT
        19   DelayCalibrate
          15   -> UST_delay
          15   -> UST_now
          19   -> _interval
        50   FR_add_header
          18   -> MEM_memcpy
        47   FR_available
           0   -> SL_available
        47   FR_busy
           0   -> SL_busy
        53   FR_create
           0   -> SL_alloc
        31   FR_del_header
          12   -> MEM_memcpy
          12   -> MEM_memset
        71   FR_delete
           2   -> SL_free
         0   HW_Init
           0   -> IRQEnable
         0   HW_Init
           0   -> DelayCalibrate
         0   HW_Init
         0   HW_Init
         0   HW_Init
           0   -> uart_init
        86   HW_Init
          84   -> MEM_memcpy
         2   HW_Init
         0   HW_Init
         6   Hot_Start
           0   -> DBG_CORE_HALT
           0   -> mode_1_process
           0   -> mode_2_process
           0   -> printf
           6   -> printf
         2   Hot_Start
           2   -> receive
           2   -> transmite
         0   Hot_Start
         4   Hot_Start
         2   INIT_LIST_HEAD
        14   IRQEnable
         0   IRQ_Init
         0   IRQ_Init
         0   IRQ_Init
         6   LLC_add_tx_frame
           2   -> AES_StreamCoder
           2   -> BF_push_tx
           2   -> DBG_CORE_HALT
           6   -> printf
         5   LLC_close_slot
           1   -> DBG_CORE_HALT
           5   -> printf
         6   LLC_open_slot
           2   -> DBG_CORE_HALT
           6   -> printf
        55   LoadTXData
        14   MAC_Receive
           7   -> AES_StreamCoder
           7   -> BF_push_rx
           7   -> FR_delete
           7   -> _recv_frame
           7   -> _send_ack
          13   -> printf
           7   -> printf
        12   MAC_Send
           3   -> FR_delete
           3   -> _recv_ack
           3   -> _send_frame
        85   MEM_memcpy
        35   MEM_memset
        11   MyLowLevelPutchar
         6   Neocore_start
           0   -> DBG_CORE_HALT
           0   -> printf
           6   -> printf
           0   -> start_mode_1
           0   -> start_mode_2
        12   RI_Measure_POW
           9   -> UST_delay
        94   RI_Receive
          31   -> DBG_CORE_HALT
          31   -> FR_add_header
          31   -> FR_create
          33   -> RecvData
          35   -> UST_interval
          31   -> UST_now
          31   -> UnLoadRXData
          31   -> pre_config
          35   -> printf
        45   RI_Send
          25   -> DBG_CORE_HALT
          25   -> SendData
          29   -> UST_interval
          25   -> UST_now
          25   -> pre_config
          29   -> printf
        59   RI_SetChannel
        17   ReadTimer
       100   RecvData
          63   -> AT_time
          63   -> UST_now
          67   -> UST_time_over
        59   SL_alloc
          10   -> MEM_memset
          10   -> __cli
        51   SL_available
           0   -> DBG_CORE_HALT
           4   -> printf
        51   SL_busy
           0   -> DBG_CORE_HALT
           4   -> printf
        51   SL_free
           4   -> __cli
           4   -> _free
        11   SL_zone_check
         2   SW_Init
           2   -> INIT_LIST_HEAD
         0   SW_Init
         0   SW_Init
         0   SW_Init
         0   SW_Init
         8   SW_Init
           6   -> MEM_memset
         0   SW_Init
         0   SW_Init
           0   -> random_core_init
         0   SW_Init
         0   SW_Init
        80   SendData
          55   -> AT_time
          55   -> AT_wait
          55   -> LoadTXData
        15   TM_ClrAlarm
           2   -> DBG_CORE_HALT
           6   -> printf
        17   TM_IRQ
           3   -> AM_Cold_start
           3   -> AM_Hot_start
           3   -> AT_enable
           3   -> __cli
           3   -> scheulder_next_alarm
        15   TM_SetAlarm
           2   -> DBG_CORE_HALT
           6   -> printf
        14   TimerCompareInterrupt
          14   -> AT_time
          14   -> IRQEnable
          14   -> TM_IRQ
        42   UST_delay
          27   -> UST_now
        54   UST_interval
        74   UST_now
        96   UST_time_over
          23   -> UST_interval
          19   -> UST_now
        32   UnLoadRXData
         3   __cli
        10   __cli
        61   __cli
         2   __cli
        18   __list_add
           9   -> __list_add_valid
         9   __list_add_valid
         2   __list_del
         4   __list_del_entry
           2   -> __list_del
           2   -> __list_del_entry_valid
         2   __list_del_entry_valid
        13   __write
          11   -> MyLowLevelPutchar
         0   _clr_all
         4   _find_next_active
           1   -> _inc_timeslot
        13   _free
           9   -> array_index
           9   -> is_array_ptr
         1   _inc_timeslot
        38   _interval
        17   _push
           9   -> DBG_CORE_HALT
           9   -> find_free_node
           9   -> list_add
          13   -> printf
         3   _recv_ack
        22   _recv_frame
           9   -> AT_time
           9   -> DBG_CORE_HALT
           9   -> RI_Receive
           9   -> RI_SetChannel
          15   -> printf
           9   -> printf
        16   _send_ack
           8   -> FR_add_header
           8   -> FR_create
           8   -> FR_delete
           8   -> RI_Send
           8   -> xor_calc
        11   _send_frame
           2   -> DBG_CORE_HALT
           2   -> RI_Send
           2   -> RI_SetChannel
           2   -> UST_delay
           2   -> printf
           8   -> printf
         2   _throw_dice
           2   -> rand
        11   accept_sync_data
        16   array_index
         2   bits_count
        26   calcCompareTime
          17   -> ReadTimer
        21   ch_cmp
        19   ch_cmp_val
        11   find_free_node
           2   -> INIT_LIST_HEAD
        74   generateAuthData
          11   -> memcpy
         2   getRNDByte
         0   init
           0   -> AT_enable
           0   -> _clr_all
           0   -> scheulder_next_alarm
         9   isIRQEnable
        16   is_array_ptr
        18   list_add
           9   -> __list_add
         8   list_del
           2   -> __list_del_entry
         5   list_empty
        61   list_is_last
        15   loadTimerCompare
         0   main
           0   -> run_tests
         0   mcu_sleep
        10   mode_1_process
           4   -> mode_1_receive_process
           4   -> mode_1_retransmition_process
          10   -> printf
           4   -> printf
        19   mode_1_receive_process
           9   -> FR_delete
           9   -> accept_sync_data
          11   -> printf
          15   -> printf
           9   -> printf
           9   -> recv_sync
           9   -> syncronize_timer
           9   -> validate_sync
         4   mode_1_retransmition_process
           0   -> _throw_dice
           0   -> send_sync
         4   mode_2_process
           4   -> send_sync
       134   network_recv_sync
          59   -> AES_StreamCoder
          59   -> DBG_CORE_HALT
          59   -> FR_delete
          59   -> RI_Receive
          59   -> RI_SetChannel
          59   -> printf
          65   -> printf
        73   network_sync
          69   -> FR_delete
          69   -> UST_now
          73   -> UST_time_over
          69   -> network_recv_sync
          69   -> syncronize_timer
        31   pre_config
           0   -> setFreq
         2   random_core_init
           2   -> pre_config
           2   -> rand
           2   -> readRandom
           2   -> srand
         4   readRandom
           2   -> bits_count
           2   -> getRNDByte
         3   receive
           1   -> MAC_Receive
        74   recv_sync
          59   -> AES_StreamCoder
          59   -> AT_wait
          59   -> DBG_CORE_HALT
          59   -> FR_delete
          59   -> RI_Receive
          59   -> RI_SetChannel
          59   -> printf
          65   -> printf
         5   run_tests
           5   -> AM_SW_Init
           5   -> run_unit_fun
           5   -> show_grating
           5   -> show_statistic
        14   run_unit_fun
           7   -> printf
           9   -> printf
         5   scheduler_rx
           1   -> DBG_CORE_HALT
           1   -> TM_ClrAlarm
           1   -> TM_SetAlarm
           5   -> printf
        15   scheduler_tx
           9   -> BF_content
           9   -> BF_cursor_next
           9   -> BF_cursor_tx
           9   -> BF_remove_tx
           9   -> DBG_CORE_HALT
           9   -> TM_SetAlarm
          13   -> printf
          15   -> printf
           9   -> printf
         6   scheulder_next_alarm
           3   -> AT_set_alarm
           3   -> _find_next_active
        26   send_sync
          16   -> AES_StreamCoder
          16   -> DBG_CORE_HALT
          16   -> FR_add_header
          16   -> FR_create
          16   -> FR_delete
          16   -> RI_Send
          16   -> RI_SetChannel
          16   -> printf
          18   -> printf
          20   -> printf
          22   -> printf
         6   setFreq
           2   -> DBG_CORE_HALT
           6   -> printf
         5   show_grating
           0   -> printf
         9   show_statistic
           2   -> printf
           4   -> printf
         0   start_mode_1
           0   -> AM_Callback
           0   -> AM_IRQ_Init
           0   -> AT_enable
           0   -> init
           0   -> mcu_sleep
         0   start_mode_2
           0   -> AM_IRQ_Init
           0   -> init
        84   syncronize_timer
           9   -> AT_interval
           9   -> AT_set_time
           9   -> AT_time
          11   -> printf
          15   -> printf
           9   -> printf
        53   test1
         5   test1
           5   -> SL_alloc
           5   -> SL_available
           5   -> SL_busy
           5   -> SL_free
        13   test1
          13   -> BF_content
          13   -> BF_cursor_next
          13   -> BF_cursor_tx
          13   -> BF_push_tx
          13   -> BF_remove_tx
          13   -> FR_create
          13   -> FR_delete
         7   test1
           7   -> FR_available
           7   -> FR_busy
           7   -> FR_create
           7   -> FR_delete
        47   test2
          47   -> FR_available
          47   -> FR_busy
          47   -> FR_create
          47   -> FR_delete
        53   test2
          53   -> BF_content
          53   -> BF_cursor_next
          53   -> BF_cursor_tx
          53   -> BF_push_tx
          53   -> BF_remove_tx
          53   -> FR_create
          53   -> FR_delete
        47   test2
          47   -> SL_alloc
          47   -> SL_available
          47   -> SL_busy
          47   -> SL_free
        53   test2
        11   test3
          11   -> SL_alloc
          11   -> SL_zone_check
        19   test3
          17   -> FR_add_header
          17   -> FR_create
          17   -> FR_del_header
          19   -> ch_cmp
          17   -> ch_cmp_val
        53   test3
          53   -> BF_available
          53   -> BF_content
          53   -> BF_cursor_next
          53   -> BF_cursor_rx
          53   -> BF_cursor_tx
          53   -> BF_push_rx
          53   -> BF_push_tx
          53   -> BF_remove_tx
          53   -> BF_rx_busy
          53   -> BF_tx_busy
          53   -> FR_create
          53   -> FR_delete
        17   transmite
           9   -> DBG_CORE_HALT
           9   -> MAC_Send
           9   -> TM_ClrAlarm
          15   -> printf
           9   -> printf
         2   u_alarm_timer
           2   -> AT_set_alarm
        40   u_mem_utils
          34   -> DBG_CORE_HALT
          34   -> MEM_memcpy
          34   -> MEM_memset
          34   -> printf
          38   -> printf
          40   -> printf
         0   uart_init
        13   validate_sync
        10   xor_calc


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  ?<Constant "!%s:%d\r\n">
       9  ?<Constant "!%s:%d\r\n">_1
       9  ?<Constant "!%s:%d\r\n">_2
       9  ?<Constant "!%s:%d\r\n">_3
       9  ?<Constant "!%s:%d\r\n">_4
       9  ?<Constant "!%s:%d\r\n">_5
       9  ?<Constant "!%s:%d\r\n">_6
       9  ?<Constant "!%s:%d\r\n">_7
       9  ?<Constant "!%s:%d\r\n">_8
      13  ?<Constant "%s:%d:%s -> ">
      13  ?<Constant "%s:%d:%s -> ">_1
      13  ?<Constant "%s:%d:%s -> ">_2
      13  ?<Constant "%s:%d:%s -> ">_3
      13  ?<Constant "%s:%d:%s -> ">_4
      16  ?<Constant "Attempts exired">
      18  ?<Constant "Begin unit test\r\n">
      12  ?<Constant "CCA/ACK err">
       6  ?<Constant "Error">
      10  ?<Constant "Failed!\r\n">
      24  ?<Constant "Incorrect MODEL.TM.MODE">
      15  ?<Constant "MEM_memcpy ok!">
      15  ?<Constant "MEM_memset ok!">
      22  ?<Constant "SYNC sended, res = %d">
      13  ?<Constant "Send success">
      26  ?<Constant "Sichronize sync RSSI ...">
      10  ?<Constant "Succes!\r\n">
      12  ?<Constant "Sync err %d">
      15  ?<Constant "TESTING:\t%-32s">
      30  ?<Constant "Test function not ass...">
      19  ?<Constant "Test passed: \t%d\r\n">
      19  ?<Constant "Test runned: \t%d\r\n">
      14  ?<Constant "Wrong channel">
      14  ?<Constant "Wrong channel">_1
      11  ?<Constant "Wrong mode">
       3  ?<Constant "\r\n">
       3  ?<Constant "\r\n">_1
       3  ?<Constant "\r\n">_2
       3  ?<Constant "\r\n">_3
      47  ?<Constant "\r\n###################...">
      36  ?<Constant "\tERR = %d. FAILED <--...">
      10  ?<Constant "\tPASSED\r\n">
      17  ?<Constant "action_manager.c">
      14  ?<Constant "alarm_timer.c">
       9  ?<Constant "buffer.c">
       6  ?<Constant "llc.c">
       6  ?<Constant "mac.c">
      12  ?<Constant "mem_slots.c">
       9  ?<Constant "push del">
       5  ?<Constant "push">
       8  ?<Constant "radio.c">
       7  ?<Constant "sync.c">
      15  ?<Constant "time_manager.c">
      14  ?<Constant "u_mem_utils.c">
       9  ?<Constant "unsynced">
       5  ?<Constant {(char *)0, (char *)0, 10}>
       4  ?<Constant {(char *)0, 0, 0}>
       4  ?<Constant {(char *)0, 10, 7}>
       4  ?<Constant {(char *)0, 150, 0}>
       4  ?<Constant {(char *)0, 150, 0}>_1
       5  ?<Constant {(char *)MODEL.AES.CCM_IV, (char *)
       5  ?<Constant {(char *)MODEL.AES.CCM_KEY, (char *
       5  ?<Constant {(char *)MODEL.AES.STREAM_IV, (char
       5  ?<Constant {(char *)MODEL.AES.STREAM_KEY, (cha
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_1
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_2
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_3
      10  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}>
      10  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}>_1
      10  ?<Initializer for AT_MODULE>
      10  ?<Initializer for BF_MODULE>
      10  ?<Initializer for CODER_MODULE>
       6  ?<Initializer for COLD_MOD>
      10  ?<Initializer for CPU_MODULE>
      10  ?<Initializer for DBG_MODULE>
      10  ?<Initializer for DMA_MODULE>
      10  ?<Initializer for FR_MODULE>
       8  ?<Initializer for HOT_MOD>
      16  ?<Initializer for HW_MOD>
       6  ?<Initializer for IRQ_MOD>
      10  ?<Initializer for LED_MODULE>
      10  ?<Initializer for LLC_MODULE>
      10  ?<Initializer for MAC_MODULE>
      10  ?<Initializer for MD_MODULE>
      10  ?<Initializer for MS_MODULE>
      10  ?<Initializer for RADIO_MODULE>
      10  ?<Initializer for RTC_MODULE>
       4  ?<Initializer for RX_LIST_HEAD>
      16  ?<Initializer for SW_MOD>
      10  ?<Initializer for SYNC_MODULE>
      22  ?<Initializer for TEST_FUN>
       4  ?<Initializer for TX_LIST_HEAD>
      10  ?<Initializer for UST_MODULE>
      34  ?<Initializer for UTEST_DEBUG>
      34  ?<Initializer for UT_BF_1>
      34  ?<Initializer for UT_BF_2>
      34  ?<Initializer for UT_BF_3>
      34  ?<Initializer for UT_FR_1>
      34  ?<Initializer for UT_FR_2>
      34  ?<Initializer for UT_FR_3>
      34  ?<Initializer for UT_MACR_1>
      34  ?<Initializer for UT_MACR_2>
      34  ?<Initializer for UT_MS_1>
      34  ?<Initializer for UT_MS_2>
      34  ?<Initializer for UT_MS_3>
     150  ACTIONSLOTS
     454  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     424  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     625  AES_StreamCoder
       6  AES_StreamCoder::?relay
      50  ALARMS
      60  AM_Callback
       6  AM_Callback::?relay
     173  AM_Cold_start
       6  AM_Cold_start::?relay
     161  AM_HW_Init
       6  AM_HW_Init::?relay
     173  AM_Hot_start
       6  AM_Hot_start::?relay
     169  AM_IRQ_Init
       6  AM_IRQ_Init::?relay
     165  AM_SW_Init
       6  AM_SW_Init::?relay
      62  AM_set_callback
       6  AM_set_callback::?relay
      10  AT_MODULE
      46  AT_enable
       6  AT_enable::?relay
      34  AT_interval
       6  AT_interval::?relay
     106  AT_set_alarm
       6  AT_set_alarm::?relay
     120  AT_set_time
       6  AT_set_time::?relay
      55  AT_time
       6  AT_time::?relay
     154  AT_wait
       6  AT_wait::?relay
      10  BF_MODULE
      87  BF_available
       6  BF_available::?relay
      20  BF_available_rx
       6  BF_available_rx::?relay
      20  BF_available_tx
       6  BF_available_tx::?relay
      26  BF_content
       6  BF_content::?relay
     207  BF_cursor_next
       6  BF_cursor_next::?relay
      77  BF_cursor_rx
       6  BF_cursor_rx::?relay
      77  BF_cursor_tx
       6  BF_cursor_tx::?relay
      89  BF_push_rx
       6  BF_push_rx::?relay
      89  BF_push_tx
       6  BF_push_tx::?relay
      85  BF_remove_rx
       6  BF_remove_rx::?relay
      85  BF_remove_tx
       6  BF_remove_tx::?relay
      11  BF_rx_busy
       6  BF_rx_busy::?relay
      11  BF_tx_busy
       6  BF_tx_busy::?relay
       2  CALLBACK
     488  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
       1  CLKCONCMD
       1  CLKCONSTA
      10  CODER_MODULE
       6  COLD_MOD
       4  COMPARE_TIME
      10  CPU_MODULE
     599  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
       3  Cold_Start
       3  Cold_Start
       3  Cold_Start
      15  Cold_Start
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       2  DBG_CORE_FAULT
       6  DBG_CORE_FAULT::?relay
       2  DBG_CORE_HALT
       6  DBG_CORE_HALT::?relay
      10  DBG_MODULE
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
      40  DMA_CH
      10  DMA_MODULE
     116  DelayCalibrate
       6  DelayCalibrate::?relay
       1  ENCCS
      10  FR_MODULE
     227  FR_add_header
       6  FR_add_header::?relay
       6  FR_available
       6  FR_available::?relay
       6  FR_busy
       6  FR_busy::?relay
       6  FR_create
       6  FR_create::?relay
     217  FR_del_header
       6  FR_del_header::?relay
      26  FR_delete
       6  FR_delete::?relay
       8  HOT_MOD
       3  HW_Init
       9  HW_Init
      11  HW_Init
      23  HW_Init
      36  HW_Init
      37  HW_Init
      59  HW_Init
     551  HW_Init
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
      16  HW_MOD
       3  Hot_Start
      46  Hot_Start
      57  Hot_Start
      79  Hot_Start
       6  Hot_Start::?relay
       6  Hot_Start::?relay
       6  Hot_Start::?relay
       6  Hot_Start::?relay
      23  INIT_LIST_HEAD
       6  INIT_LIST_HEAD::?relay
      17  IRQEnable
       6  IRQEnable::?relay
       3  IRQ_Init
       3  IRQ_Init
      44  IRQ_Init
       6  IRQ_Init::?relay
       6  IRQ_Init::?relay
       6  IRQ_Init::?relay
       6  IRQ_MOD
      10  LED_MODULE
      10  LLC_MODULE
      92  LLC_add_tx_frame
       6  LLC_add_tx_frame::?relay
      89  LLC_close_slot
       6  LLC_close_slot::?relay
     143  LLC_open_slot
       6  LLC_open_slot::?relay
      46  LoadTXData
       6  LoadTXData::?relay
      10  MAC_MODULE
     211  MAC_Receive
       6  MAC_Receive::?relay
     129  MAC_Send
       6  MAC_Send::?relay
       4  MAC_TIMER_MAX
      10  MD_MODULE
     108  MEM_memcpy
       6  MEM_memcpy::?relay
      71  MEM_memset
       6  MEM_memset::?relay
     152  MODEL
      10  MS_MODULE
      12  MyLowLevelPutchar
       6  MyLowLevelPutchar::?relay
     120  NODE_LIST
      73  Neocore_start
       6  Neocore_start::?relay
       1  P0SEL
       1  P1DIR
       1  PCON
       1  PERCFG
      10  RADIO_MODULE
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
      97  RI_Measure_POW
       6  RI_Measure_POW::?relay
     568  RI_Receive
       6  RI_Receive::?relay
     246  RI_Send
       6  RI_Send::?relay
      24  RI_SetChannel
       6  RI_SetChannel::?relay
      10  RTC_MODULE
     128  RXBUFF
       2  RX_BUFF_FRAME_COUNT
       4  RX_LIST_HEAD
      51  ReadTimer
       6  ReadTimer::?relay
     207  RecvData
       6  RecvData::?relay
       1  SLEEPCMD
       1  SLEEPSTA
    3060  SLOT_POOL
     179  SL_alloc
       6  SL_alloc::?relay
      69  SL_available
       6  SL_available::?relay
      60  SL_busy
       6  SL_busy::?relay
      49  SL_free
       6  SL_free::?relay
      68  SL_zone_check
       6  SL_zone_check::?relay
       1  ST0
       1  ST1
       1  ST2
       1  STLOAD
       3  SW_Init
       3  SW_Init
       3  SW_Init
       3  SW_Init
       3  SW_Init
      44  SW_Init
      54  SW_Init
      75  SW_Init
      92  SW_Init
     142  SW_Init
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
      16  SW_MOD
      10  SYNC_MODULE
     281  SendData
       6  SendData::?relay
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
      22  TEST_FUN
      76  TM_ClrAlarm
       6  TM_ClrAlarm::?relay
     119  TM_IRQ
       6  TM_IRQ::?relay
      73  TM_SetAlarm
       6  TM_SetAlarm::?relay
       2  TOFFSET
       2  TX_BUFF_FRAME_COUNT
       4  TX_LIST_HEAD
      37  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
      10  UST_MODULE
     198  UST_delay
       6  UST_delay::?relay
     145  UST_interval
       6  UST_interval::?relay
      74  UST_now
       6  UST_now::?relay
     118  UST_time_over
       6  UST_time_over::?relay
      34  UTEST_DEBUG
      34  UT_BF_1
      34  UT_BF_2
      34  UT_BF_3
      34  UT_FR_1
      34  UT_FR_2
      34  UT_FR_3
      34  UT_MACR_1
      34  UT_MACR_2
      34  UT_MS_1
      34  UT_MS_2
      34  UT_MS_3
      36  UnLoadRXData
       6  UnLoadRXData::?relay
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P1
       4  __Constant_1
       4  __Constant_19833891
       4  __Constant_1f4
       4  __Constant_20
       4  __Constant_396
       4  __Constant_3d
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_9c4
       4  __Constant_a
       4  __Constant_ffff8000
       4  __Constant_ffffc180
       4  __Constant_ffffff
       7  __cli
       7  __cli
       7  __cli
       7  __cli
       6  __cli::?relay
       6  __cli::?relay
       6  __cli::?relay
       6  __cli::?relay
     100  __list_add
       6  __list_add::?relay
       4  __list_add_valid
       6  __list_add_valid::?relay
      23  __list_del
       6  __list_del::?relay
      51  __list_del_entry
       6  __list_del_entry::?relay
       4  __list_del_entry_valid
       6  __list_del_entry_valid::?relay
     157  __write
       6  __write::?relay
      26  _clr_all
       6  _clr_all::?relay
      49  _find_next_active
       6  _find_next_active::?relay
     128  _free
       6  _free::?relay
      18  _inc_timeslot
       6  _inc_timeslot::?relay
     131  _interval
       6  _interval::?relay
      99  _push
       6  _push::?relay
       4  _recv_ack
       6  _recv_ack::?relay
     110  _recv_frame
       6  _recv_frame::?relay
     102  _send_ack
       6  _send_ack::?relay
     102  _send_frame
       6  _send_frame::?relay
      53  _throw_dice
       6  _throw_dice::?relay
      31  accept_sync_data
       6  accept_sync_data::?relay
      49  array_index
       6  array_index::?relay
      34  bits_count
       6  bits_count::?relay
     162  buf
     191  calcCompareTime
       6  calcCompareTime::?relay
      60  ch_cmp
       6  ch_cmp::?relay
      43  ch_cmp_val
       6  ch_cmp_val::?relay
       2  common_count
      70  find_free_node
       6  find_free_node::?relay
     235  generateAuthData
       6  generateAuthData::?relay
      45  getRNDByte
       6  getRNDByte::?relay
      18  init
       6  init::?relay
       5  isIRQEnable
       6  isIRQEnable::?relay
      61  is_array_ptr
       6  is_array_ptr::?relay
      40  list_add
       6  list_add::?relay
      50  list_del
       6  list_del::?relay
      33  list_empty
       6  list_empty::?relay
      33  list_is_last
       6  list_is_last::?relay
      81  loadTimerCompare
       6  loadTimerCompare::?relay
       5  main
       6  main::?relay
       9  mcu_sleep
       6  mcu_sleep::?relay
     153  mode_1_process
       6  mode_1_process::?relay
     210  mode_1_receive_process
       6  mode_1_receive_process::?relay
      24  mode_1_retransmition_process
       6  mode_1_retransmition_process::?relay
      68  mode_2_process
       6  mode_2_process::?relay
     235  network_recv_sync
       6  network_recv_sync::?relay
     424  network_sync
       6  network_sync::?relay
       2  passed
      19  pre_config
       6  pre_config::?relay
      83  random_core_init
       6  random_core_init::?relay
      59  readRandom
       6  readRandom::?relay
      54  receive
       6  receive::?relay
     242  recv_sync
       6  recv_sync::?relay
       4  ret_val
       1  retransmite
      90  run_tests
       6  run_tests::?relay
     142  run_unit_fun
       6  run_unit_fun::?relay
     111  scheduler_rx
       6  scheduler_rx::?relay
     327  scheduler_tx
       6  scheduler_tx::?relay
      74  scheulder_next_alarm
       6  scheulder_next_alarm::?relay
     337  send_sync
       6  send_sync::?relay
      95  setFreq
       6  setFreq::?relay
      10  show_grating
       6  show_grating::?relay
      88  show_statistic
       6  show_statistic::?relay
       2  slot_busy
      30  start_mode_1
       6  start_mode_1::?relay
       9  start_mode_2
       6  start_mode_2::?relay
     153  syncronize_timer
       6  syncronize_timer::?relay
     113  test1
     151  test1
     180  test1
     305  test1
       6  test1::?relay
       6  test1::?relay
       6  test1::?relay
       6  test1::?relay
     113  test2
     482  test2
     683  test2
     686  test2
       6  test2::?relay
       6  test2::?relay
       6  test2::?relay
       6  test2::?relay
     135  test3
     315  test3
    1030  test3
       6  test3::?relay
       6  test3::?relay
       6  test3::?relay
     450  transmite
       6  transmite::?relay
      21  u_alarm_timer
       6  u_alarm_timer::?relay
     496  u_mem_utils
       6  u_mem_utils::?relay
      23  uart_init
       6  uart_init::?relay
       4  val
      68  validate_sync
       6  validate_sync::?relay
      56  xor_calc
       6  xor_calc::?relay
     188  -- Other

 
 21 348 bytes in segment BANKED_CODE
  1 086 bytes in segment BANK_RELAYS
      3 bytes in segment INTVEC
     37 bytes in segment NEAR_CODE
     35 bytes in segment SFR_AN
    650 bytes in segment XDATA_I
    650 bytes in segment XDATA_ID
  1 072 bytes in segment XDATA_ROM_C
  3 893 bytes in segment XDATA_Z
 
  1 773 bytes of CODE     memory (+  3 bytes shared)
  1 020 bytes of CONST    memory (+ 52 bytes shared)
      0 bytes of DATA     memory (+ 35 bytes shared)
 21 348 bytes of HUGECODE memory
  4 543 bytes of XDATA    memory

Errors: none
Warnings: 11
